// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package nobl9

import (
	"context"
	"reflect"

	"errors"
	"github.com/piclemx/pulumi-nobl9/sdk/go/nobl9/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Example Usage
//
// Here's an example of RBAC resource configuration:
//
// ```go
// package main
//
// import (
//
//	"github.com/piclemx/pulumi-nobl9/sdk/go/nobl9"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := nobl9.NewRoleBinding(ctx, "this", &nobl9.RoleBindingArgs{
//				GroupRef:   pulumi.String("test"),
//				ProjectRef: pulumi.String("default"),
//				RoleRef:    pulumi.String("project-owner"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ## Useful Links
//
// [Role Based Access Control in Nobl9 | Nobl9 Documentation](https://docs.nobl9.com/Getting_Started/RBAC/)
//
// [Role Binding YAML Configuration | Nobl9 Documentation](https://docs.nobl9.com/Getting_Started/RBAC/role-binding-yaml)
type RoleBinding struct {
	pulumi.CustomResourceState

	// User-friendly display name of the resource.
	DisplayName pulumi.StringPtrOutput `pulumi:"displayName"`
	// Group name that can be retrieved from the Nobl9 UI (**Settings** > **Access Controls** > **Groups**) or using sloctl `get usergroups` command.
	GroupRef pulumi.StringPtrOutput `pulumi:"groupRef"`
	// Automatically generated, unique name of the resource, must conform to the naming convention from [DNS RFC1123](https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	Name pulumi.StringOutput `pulumi:"name"`
	// Project name, the project in which we want the user or group to assume the specified role. When `projectRef` is empty, `roleRef` must contain an Organization Role.
	ProjectRef pulumi.StringPtrOutput `pulumi:"projectRef"`
	// Role name; the role that you want the user or group to assume.
	RoleRef pulumi.StringOutput `pulumi:"roleRef"`
	// Okta User ID that can be retrieved from the Nobl9 UI (**Settings** > **Access Controls** > **Users**).
	User pulumi.StringPtrOutput `pulumi:"user"`
}

// NewRoleBinding registers a new resource with the given unique name, arguments, and options.
func NewRoleBinding(ctx *pulumi.Context,
	name string, args *RoleBindingArgs, opts ...pulumi.ResourceOption) (*RoleBinding, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.RoleRef == nil {
		return nil, errors.New("invalid value for required argument 'RoleRef'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource RoleBinding
	err := ctx.RegisterResource("nobl9:index/roleBinding:RoleBinding", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetRoleBinding gets an existing RoleBinding resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetRoleBinding(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *RoleBindingState, opts ...pulumi.ResourceOption) (*RoleBinding, error) {
	var resource RoleBinding
	err := ctx.ReadResource("nobl9:index/roleBinding:RoleBinding", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering RoleBinding resources.
type roleBindingState struct {
	// User-friendly display name of the resource.
	DisplayName *string `pulumi:"displayName"`
	// Group name that can be retrieved from the Nobl9 UI (**Settings** > **Access Controls** > **Groups**) or using sloctl `get usergroups` command.
	GroupRef *string `pulumi:"groupRef"`
	// Automatically generated, unique name of the resource, must conform to the naming convention from [DNS RFC1123](https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	Name *string `pulumi:"name"`
	// Project name, the project in which we want the user or group to assume the specified role. When `projectRef` is empty, `roleRef` must contain an Organization Role.
	ProjectRef *string `pulumi:"projectRef"`
	// Role name; the role that you want the user or group to assume.
	RoleRef *string `pulumi:"roleRef"`
	// Okta User ID that can be retrieved from the Nobl9 UI (**Settings** > **Access Controls** > **Users**).
	User *string `pulumi:"user"`
}

type RoleBindingState struct {
	// User-friendly display name of the resource.
	DisplayName pulumi.StringPtrInput
	// Group name that can be retrieved from the Nobl9 UI (**Settings** > **Access Controls** > **Groups**) or using sloctl `get usergroups` command.
	GroupRef pulumi.StringPtrInput
	// Automatically generated, unique name of the resource, must conform to the naming convention from [DNS RFC1123](https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	Name pulumi.StringPtrInput
	// Project name, the project in which we want the user or group to assume the specified role. When `projectRef` is empty, `roleRef` must contain an Organization Role.
	ProjectRef pulumi.StringPtrInput
	// Role name; the role that you want the user or group to assume.
	RoleRef pulumi.StringPtrInput
	// Okta User ID that can be retrieved from the Nobl9 UI (**Settings** > **Access Controls** > **Users**).
	User pulumi.StringPtrInput
}

func (RoleBindingState) ElementType() reflect.Type {
	return reflect.TypeOf((*roleBindingState)(nil)).Elem()
}

type roleBindingArgs struct {
	// User-friendly display name of the resource.
	DisplayName *string `pulumi:"displayName"`
	// Group name that can be retrieved from the Nobl9 UI (**Settings** > **Access Controls** > **Groups**) or using sloctl `get usergroups` command.
	GroupRef *string `pulumi:"groupRef"`
	// Automatically generated, unique name of the resource, must conform to the naming convention from [DNS RFC1123](https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	Name *string `pulumi:"name"`
	// Project name, the project in which we want the user or group to assume the specified role. When `projectRef` is empty, `roleRef` must contain an Organization Role.
	ProjectRef *string `pulumi:"projectRef"`
	// Role name; the role that you want the user or group to assume.
	RoleRef string `pulumi:"roleRef"`
	// Okta User ID that can be retrieved from the Nobl9 UI (**Settings** > **Access Controls** > **Users**).
	User *string `pulumi:"user"`
}

// The set of arguments for constructing a RoleBinding resource.
type RoleBindingArgs struct {
	// User-friendly display name of the resource.
	DisplayName pulumi.StringPtrInput
	// Group name that can be retrieved from the Nobl9 UI (**Settings** > **Access Controls** > **Groups**) or using sloctl `get usergroups` command.
	GroupRef pulumi.StringPtrInput
	// Automatically generated, unique name of the resource, must conform to the naming convention from [DNS RFC1123](https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	Name pulumi.StringPtrInput
	// Project name, the project in which we want the user or group to assume the specified role. When `projectRef` is empty, `roleRef` must contain an Organization Role.
	ProjectRef pulumi.StringPtrInput
	// Role name; the role that you want the user or group to assume.
	RoleRef pulumi.StringInput
	// Okta User ID that can be retrieved from the Nobl9 UI (**Settings** > **Access Controls** > **Users**).
	User pulumi.StringPtrInput
}

func (RoleBindingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*roleBindingArgs)(nil)).Elem()
}

type RoleBindingInput interface {
	pulumi.Input

	ToRoleBindingOutput() RoleBindingOutput
	ToRoleBindingOutputWithContext(ctx context.Context) RoleBindingOutput
}

func (*RoleBinding) ElementType() reflect.Type {
	return reflect.TypeOf((**RoleBinding)(nil)).Elem()
}

func (i *RoleBinding) ToRoleBindingOutput() RoleBindingOutput {
	return i.ToRoleBindingOutputWithContext(context.Background())
}

func (i *RoleBinding) ToRoleBindingOutputWithContext(ctx context.Context) RoleBindingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RoleBindingOutput)
}

// RoleBindingArrayInput is an input type that accepts RoleBindingArray and RoleBindingArrayOutput values.
// You can construct a concrete instance of `RoleBindingArrayInput` via:
//
//	RoleBindingArray{ RoleBindingArgs{...} }
type RoleBindingArrayInput interface {
	pulumi.Input

	ToRoleBindingArrayOutput() RoleBindingArrayOutput
	ToRoleBindingArrayOutputWithContext(context.Context) RoleBindingArrayOutput
}

type RoleBindingArray []RoleBindingInput

func (RoleBindingArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RoleBinding)(nil)).Elem()
}

func (i RoleBindingArray) ToRoleBindingArrayOutput() RoleBindingArrayOutput {
	return i.ToRoleBindingArrayOutputWithContext(context.Background())
}

func (i RoleBindingArray) ToRoleBindingArrayOutputWithContext(ctx context.Context) RoleBindingArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RoleBindingArrayOutput)
}

// RoleBindingMapInput is an input type that accepts RoleBindingMap and RoleBindingMapOutput values.
// You can construct a concrete instance of `RoleBindingMapInput` via:
//
//	RoleBindingMap{ "key": RoleBindingArgs{...} }
type RoleBindingMapInput interface {
	pulumi.Input

	ToRoleBindingMapOutput() RoleBindingMapOutput
	ToRoleBindingMapOutputWithContext(context.Context) RoleBindingMapOutput
}

type RoleBindingMap map[string]RoleBindingInput

func (RoleBindingMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RoleBinding)(nil)).Elem()
}

func (i RoleBindingMap) ToRoleBindingMapOutput() RoleBindingMapOutput {
	return i.ToRoleBindingMapOutputWithContext(context.Background())
}

func (i RoleBindingMap) ToRoleBindingMapOutputWithContext(ctx context.Context) RoleBindingMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RoleBindingMapOutput)
}

type RoleBindingOutput struct{ *pulumi.OutputState }

func (RoleBindingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RoleBinding)(nil)).Elem()
}

func (o RoleBindingOutput) ToRoleBindingOutput() RoleBindingOutput {
	return o
}

func (o RoleBindingOutput) ToRoleBindingOutputWithContext(ctx context.Context) RoleBindingOutput {
	return o
}

// User-friendly display name of the resource.
func (o RoleBindingOutput) DisplayName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RoleBinding) pulumi.StringPtrOutput { return v.DisplayName }).(pulumi.StringPtrOutput)
}

// Group name that can be retrieved from the Nobl9 UI (**Settings** > **Access Controls** > **Groups**) or using sloctl `get usergroups` command.
func (o RoleBindingOutput) GroupRef() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RoleBinding) pulumi.StringPtrOutput { return v.GroupRef }).(pulumi.StringPtrOutput)
}

// Automatically generated, unique name of the resource, must conform to the naming convention from [DNS RFC1123](https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
func (o RoleBindingOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *RoleBinding) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Project name, the project in which we want the user or group to assume the specified role. When `projectRef` is empty, `roleRef` must contain an Organization Role.
func (o RoleBindingOutput) ProjectRef() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RoleBinding) pulumi.StringPtrOutput { return v.ProjectRef }).(pulumi.StringPtrOutput)
}

// Role name; the role that you want the user or group to assume.
func (o RoleBindingOutput) RoleRef() pulumi.StringOutput {
	return o.ApplyT(func(v *RoleBinding) pulumi.StringOutput { return v.RoleRef }).(pulumi.StringOutput)
}

// Okta User ID that can be retrieved from the Nobl9 UI (**Settings** > **Access Controls** > **Users**).
func (o RoleBindingOutput) User() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RoleBinding) pulumi.StringPtrOutput { return v.User }).(pulumi.StringPtrOutput)
}

type RoleBindingArrayOutput struct{ *pulumi.OutputState }

func (RoleBindingArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RoleBinding)(nil)).Elem()
}

func (o RoleBindingArrayOutput) ToRoleBindingArrayOutput() RoleBindingArrayOutput {
	return o
}

func (o RoleBindingArrayOutput) ToRoleBindingArrayOutputWithContext(ctx context.Context) RoleBindingArrayOutput {
	return o
}

func (o RoleBindingArrayOutput) Index(i pulumi.IntInput) RoleBindingOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *RoleBinding {
		return vs[0].([]*RoleBinding)[vs[1].(int)]
	}).(RoleBindingOutput)
}

type RoleBindingMapOutput struct{ *pulumi.OutputState }

func (RoleBindingMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RoleBinding)(nil)).Elem()
}

func (o RoleBindingMapOutput) ToRoleBindingMapOutput() RoleBindingMapOutput {
	return o
}

func (o RoleBindingMapOutput) ToRoleBindingMapOutputWithContext(ctx context.Context) RoleBindingMapOutput {
	return o
}

func (o RoleBindingMapOutput) MapIndex(k pulumi.StringInput) RoleBindingOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *RoleBinding {
		return vs[0].(map[string]*RoleBinding)[vs[1].(string)]
	}).(RoleBindingOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*RoleBindingInput)(nil)).Elem(), &RoleBinding{})
	pulumi.RegisterInputType(reflect.TypeOf((*RoleBindingArrayInput)(nil)).Elem(), RoleBindingArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RoleBindingMapInput)(nil)).Elem(), RoleBindingMap{})
	pulumi.RegisterOutputType(RoleBindingOutput{})
	pulumi.RegisterOutputType(RoleBindingArrayOutput{})
	pulumi.RegisterOutputType(RoleBindingMapOutput{})
}

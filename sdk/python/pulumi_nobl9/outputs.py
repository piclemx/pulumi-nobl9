# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'AgentAmazonPrometheusConfig',
    'AgentAppdynamicsConfig',
    'AgentBigqueryConfig',
    'AgentCloudwatchConfig',
    'AgentDatadogConfig',
    'AgentDynatraceConfig',
    'AgentElasticsearchConfig',
    'AgentGcmConfig',
    'AgentGrafanaLokiConfig',
    'AgentGraphiteConfig',
    'AgentInfluxdbConfig',
    'AgentInstanaConfig',
    'AgentLightstepConfig',
    'AgentNewrelicConfig',
    'AgentOpentsdbConfig',
    'AgentPingdomConfig',
    'AgentPrometheusConfig',
    'AgentQueryDelay',
    'AgentRedshiftConfig',
    'AgentSplunkConfig',
    'AgentSplunkObservabilityConfig',
    'AgentSumologicConfig',
    'AgentThousandeyesConfig',
    'AlertPolicyAlertMethod',
    'AlertPolicyCondition',
    'DirectAppdynamicsQueryDelay',
    'DirectBigqueryQueryDelay',
    'DirectCloudwatchHistoricalDataRetrieval',
    'DirectCloudwatchHistoricalDataRetrievalDefaultDuration',
    'DirectCloudwatchHistoricalDataRetrievalMaxDuration',
    'DirectCloudwatchQueryDelay',
    'DirectDatadogHistoricalDataRetrieval',
    'DirectDatadogHistoricalDataRetrievalDefaultDuration',
    'DirectDatadogHistoricalDataRetrievalMaxDuration',
    'DirectDatadogQueryDelay',
    'DirectDynatraceHistoricalDataRetrieval',
    'DirectDynatraceHistoricalDataRetrievalDefaultDuration',
    'DirectDynatraceHistoricalDataRetrievalMaxDuration',
    'DirectDynatraceQueryDelay',
    'DirectGcmQueryDelay',
    'DirectInfluxdbQueryDelay',
    'DirectInstanaQueryDelay',
    'DirectLightstepHistoricalDataRetrieval',
    'DirectLightstepHistoricalDataRetrievalDefaultDuration',
    'DirectLightstepHistoricalDataRetrievalMaxDuration',
    'DirectLightstepQueryDelay',
    'DirectNewrelicHistoricalDataRetrieval',
    'DirectNewrelicHistoricalDataRetrievalDefaultDuration',
    'DirectNewrelicHistoricalDataRetrievalMaxDuration',
    'DirectNewrelicQueryDelay',
    'DirectPingdomQueryDelay',
    'DirectRedshiftQueryDelay',
    'DirectSplunkHistoricalDataRetrieval',
    'DirectSplunkHistoricalDataRetrievalDefaultDuration',
    'DirectSplunkHistoricalDataRetrievalMaxDuration',
    'DirectSplunkObservabilityQueryDelay',
    'DirectSplunkQueryDelay',
    'DirectSumologicQueryDelay',
    'DirectThousandeyesQueryDelay',
    'ProjectLabel',
    'ServiceLabel',
    'SloAttachment',
    'SloComposite',
    'SloCompositeBurnRateCondition',
    'SloIndicator',
    'SloLabel',
    'SloObjective',
    'SloObjectiveCountMetric',
    'SloObjectiveCountMetricGood',
    'SloObjectiveCountMetricGoodAmazonPrometheus',
    'SloObjectiveCountMetricGoodAppdynamic',
    'SloObjectiveCountMetricGoodBigquery',
    'SloObjectiveCountMetricGoodCloudwatch',
    'SloObjectiveCountMetricGoodCloudwatchDimension',
    'SloObjectiveCountMetricGoodDatadog',
    'SloObjectiveCountMetricGoodDynatrace',
    'SloObjectiveCountMetricGoodElasticsearch',
    'SloObjectiveCountMetricGoodGcm',
    'SloObjectiveCountMetricGoodGrafanaLoki',
    'SloObjectiveCountMetricGoodGraphite',
    'SloObjectiveCountMetricGoodInfluxdb',
    'SloObjectiveCountMetricGoodInstana',
    'SloObjectiveCountMetricGoodInstanaApplication',
    'SloObjectiveCountMetricGoodInstanaApplicationGroupBy',
    'SloObjectiveCountMetricGoodInstanaInfrastructure',
    'SloObjectiveCountMetricGoodLightstep',
    'SloObjectiveCountMetricGoodNewrelic',
    'SloObjectiveCountMetricGoodOpentsdb',
    'SloObjectiveCountMetricGoodPingdom',
    'SloObjectiveCountMetricGoodPrometheus',
    'SloObjectiveCountMetricGoodRedshift',
    'SloObjectiveCountMetricGoodSplunk',
    'SloObjectiveCountMetricGoodSplunkObservability',
    'SloObjectiveCountMetricGoodSumologic',
    'SloObjectiveCountMetricGoodThousandeye',
    'SloObjectiveCountMetricTotal',
    'SloObjectiveCountMetricTotalAmazonPrometheus',
    'SloObjectiveCountMetricTotalAppdynamic',
    'SloObjectiveCountMetricTotalBigquery',
    'SloObjectiveCountMetricTotalCloudwatch',
    'SloObjectiveCountMetricTotalCloudwatchDimension',
    'SloObjectiveCountMetricTotalDatadog',
    'SloObjectiveCountMetricTotalDynatrace',
    'SloObjectiveCountMetricTotalElasticsearch',
    'SloObjectiveCountMetricTotalGcm',
    'SloObjectiveCountMetricTotalGrafanaLoki',
    'SloObjectiveCountMetricTotalGraphite',
    'SloObjectiveCountMetricTotalInfluxdb',
    'SloObjectiveCountMetricTotalInstana',
    'SloObjectiveCountMetricTotalInstanaApplication',
    'SloObjectiveCountMetricTotalInstanaApplicationGroupBy',
    'SloObjectiveCountMetricTotalInstanaInfrastructure',
    'SloObjectiveCountMetricTotalLightstep',
    'SloObjectiveCountMetricTotalNewrelic',
    'SloObjectiveCountMetricTotalOpentsdb',
    'SloObjectiveCountMetricTotalPingdom',
    'SloObjectiveCountMetricTotalPrometheus',
    'SloObjectiveCountMetricTotalRedshift',
    'SloObjectiveCountMetricTotalSplunk',
    'SloObjectiveCountMetricTotalSplunkObservability',
    'SloObjectiveCountMetricTotalSumologic',
    'SloObjectiveCountMetricTotalThousandeye',
    'SloObjectiveRawMetric',
    'SloObjectiveRawMetricQuery',
    'SloObjectiveRawMetricQueryAmazonPrometheus',
    'SloObjectiveRawMetricQueryAppdynamic',
    'SloObjectiveRawMetricQueryBigquery',
    'SloObjectiveRawMetricQueryCloudwatch',
    'SloObjectiveRawMetricQueryCloudwatchDimension',
    'SloObjectiveRawMetricQueryDatadog',
    'SloObjectiveRawMetricQueryDynatrace',
    'SloObjectiveRawMetricQueryElasticsearch',
    'SloObjectiveRawMetricQueryGcm',
    'SloObjectiveRawMetricQueryGrafanaLoki',
    'SloObjectiveRawMetricQueryGraphite',
    'SloObjectiveRawMetricQueryInfluxdb',
    'SloObjectiveRawMetricQueryInstana',
    'SloObjectiveRawMetricQueryInstanaApplication',
    'SloObjectiveRawMetricQueryInstanaApplicationGroupBy',
    'SloObjectiveRawMetricQueryInstanaInfrastructure',
    'SloObjectiveRawMetricQueryLightstep',
    'SloObjectiveRawMetricQueryNewrelic',
    'SloObjectiveRawMetricQueryOpentsdb',
    'SloObjectiveRawMetricQueryPingdom',
    'SloObjectiveRawMetricQueryPrometheus',
    'SloObjectiveRawMetricQueryRedshift',
    'SloObjectiveRawMetricQuerySplunk',
    'SloObjectiveRawMetricQuerySplunkObservability',
    'SloObjectiveRawMetricQuerySumologic',
    'SloObjectiveRawMetricQueryThousandeye',
    'SloTimeWindow',
    'SloTimeWindowCalendar',
]

@pulumi.output_type
class AgentAmazonPrometheusConfig(dict):
    def __init__(__self__, *,
                 region: str,
                 url: str):
        """
        :param str region: AWS region e.g., eu-central-1
        :param str url: Base URL to Amazon Prometheus server.
        """
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        AWS region e.g., eu-central-1
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Base URL to Amazon Prometheus server.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AgentAppdynamicsConfig(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: Base URL to the AppDynamics Controller.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Base URL to the AppDynamics Controller.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AgentBigqueryConfig(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class AgentCloudwatchConfig(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class AgentDatadogConfig(dict):
    def __init__(__self__, *,
                 site: str):
        """
        :param str site: `com` or `eu`, Datadog SaaS instance, which corresponds to one of Datadog's two locations (https://www.datadoghq.com/ in the U.S. or https://datadoghq.eu/ in the European Union)
        """
        pulumi.set(__self__, "site", site)

    @property
    @pulumi.getter
    def site(self) -> str:
        """
        `com` or `eu`, Datadog SaaS instance, which corresponds to one of Datadog's two locations (https://www.datadoghq.com/ in the U.S. or https://datadoghq.eu/ in the European Union)
        """
        return pulumi.get(self, "site")


@pulumi.output_type
class AgentDynatraceConfig(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: Dynatrace API URL.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Dynatrace API URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AgentElasticsearchConfig(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: API URL endpoint to the Elasticsearch's instance.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        API URL endpoint to the Elasticsearch's instance.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AgentGcmConfig(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class AgentGrafanaLokiConfig(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: API URL endpoint to the Grafana Loki instance.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        API URL endpoint to the Grafana Loki instance.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AgentGraphiteConfig(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: API URL endpoint to the Graphite's instance.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        API URL endpoint to the Graphite's instance.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AgentInfluxdbConfig(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: API URL endpoint to the InfluxDB's instance.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        API URL endpoint to the InfluxDB's instance.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AgentInstanaConfig(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: API URL endpoint to the InfluxDB's instance.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        API URL endpoint to the InfluxDB's instance.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AgentLightstepConfig(dict):
    def __init__(__self__, *,
                 organization: str,
                 project: str):
        """
        :param str organization: Organization name registered in Lightstep.
        :param str project: Name of the Lightstep project.
        """
        pulumi.set(__self__, "organization", organization)
        pulumi.set(__self__, "project", project)

    @property
    @pulumi.getter
    def organization(self) -> str:
        """
        Organization name registered in Lightstep.
        """
        return pulumi.get(self, "organization")

    @property
    @pulumi.getter
    def project(self) -> str:
        """
        Name of the Lightstep project.
        """
        return pulumi.get(self, "project")


@pulumi.output_type
class AgentNewrelicConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountId":
            suggest = "account_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentNewrelicConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentNewrelicConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentNewrelicConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_id: str):
        """
        :param str account_id: ID number assigned to the New Relic user account.
        """
        pulumi.set(__self__, "account_id", account_id)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> str:
        """
        ID number assigned to the New Relic user account.
        """
        return pulumi.get(self, "account_id")


@pulumi.output_type
class AgentOpentsdbConfig(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: OpenTSDB cluster URL.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        OpenTSDB cluster URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AgentPingdomConfig(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class AgentPrometheusConfig(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: Base URL to Prometheus server.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Base URL to Prometheus server.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AgentQueryDelay(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute or Second.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute or Second.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AgentRedshiftConfig(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class AgentSplunkConfig(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: Base API URL to the Splunk Search app.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Base API URL to the Splunk Search app.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AgentSplunkObservabilityConfig(dict):
    def __init__(__self__, *,
                 realm: str):
        """
        :param str realm: SplunkObservability Realm.
        """
        pulumi.set(__self__, "realm", realm)

    @property
    @pulumi.getter
    def realm(self) -> str:
        """
        SplunkObservability Realm.
        """
        return pulumi.get(self, "realm")


@pulumi.output_type
class AgentSumologicConfig(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: Sumo Logic API URL.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Sumo Logic API URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AgentThousandeyesConfig(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class AlertPolicyAlertMethod(dict):
    def __init__(__self__, *,
                 name: str,
                 project: Optional[str] = None):
        """
        :param str name: The name of the previously defined alert method.
        :param str project: Project name the Alert Method is in, must conform to the naming convention from [DNS RFC1123](https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names). If not defined, Nobl9 returns a default value for this field.
        """
        pulumi.set(__self__, "name", name)
        if project is not None:
            pulumi.set(__self__, "project", project)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the previously defined alert method.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def project(self) -> Optional[str]:
        """
        Project name the Alert Method is in, must conform to the naming convention from [DNS RFC1123](https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names). If not defined, Nobl9 returns a default value for this field.
        """
        return pulumi.get(self, "project")


@pulumi.output_type
class AlertPolicyCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastsFor":
            suggest = "lasts_for"
        elif key == "valueString":
            suggest = "value_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertPolicyCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertPolicyCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertPolicyCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 measurement: str,
                 lasts_for: Optional[str] = None,
                 value: Optional[float] = None,
                 value_string: Optional[str] = None):
        """
        :param str measurement: One of `timeToBurnBudget` | `burnRate` | `burnedBudget`.
        :param str lasts_for: Indicates how long a given condition needs to be valid to mark the condition as true.
        :param float value: For `averageBurnRate`, it indicates how fast the error budget is burning. For `burnedBudget`, it tells how much error budget is already burned.
        :param str value_string: Used with `timeToBurnBudget`, indicates when the budget would be exhausted. The expected value is a string in time duration string format.
        """
        pulumi.set(__self__, "measurement", measurement)
        if lasts_for is not None:
            pulumi.set(__self__, "lasts_for", lasts_for)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_string is not None:
            pulumi.set(__self__, "value_string", value_string)

    @property
    @pulumi.getter
    def measurement(self) -> str:
        """
        One of `timeToBurnBudget` | `burnRate` | `burnedBudget`.
        """
        return pulumi.get(self, "measurement")

    @property
    @pulumi.getter(name="lastsFor")
    def lasts_for(self) -> Optional[str]:
        """
        Indicates how long a given condition needs to be valid to mark the condition as true.
        """
        return pulumi.get(self, "lasts_for")

    @property
    @pulumi.getter
    def value(self) -> Optional[float]:
        """
        For `averageBurnRate`, it indicates how fast the error budget is burning. For `burnedBudget`, it tells how much error budget is already burned.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueString")
    def value_string(self) -> Optional[str]:
        """
        Used with `timeToBurnBudget`, indicates when the budget would be exhausted. The expected value is a string in time duration string format.
        """
        return pulumi.get(self, "value_string")


@pulumi.output_type
class DirectAppdynamicsQueryDelay(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute or Second.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute or Second.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectBigqueryQueryDelay(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute or Second.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute or Second.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectCloudwatchHistoricalDataRetrieval(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultDurations":
            suggest = "default_durations"
        elif key == "maxDurations":
            suggest = "max_durations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DirectCloudwatchHistoricalDataRetrieval. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DirectCloudwatchHistoricalDataRetrieval.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DirectCloudwatchHistoricalDataRetrieval.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_durations: Sequence['outputs.DirectCloudwatchHistoricalDataRetrievalDefaultDuration'],
                 max_durations: Sequence['outputs.DirectCloudwatchHistoricalDataRetrievalMaxDuration']):
        """
        :param Sequence['DirectCloudwatchHistoricalDataRetrievalDefaultDurationArgs'] default_durations: Used by default for any SLOs connected to this data source.
        :param Sequence['DirectCloudwatchHistoricalDataRetrievalMaxDurationArgs'] max_durations: Defines the maximum period for which data can be retrieved.
        """
        pulumi.set(__self__, "default_durations", default_durations)
        pulumi.set(__self__, "max_durations", max_durations)

    @property
    @pulumi.getter(name="defaultDurations")
    def default_durations(self) -> Sequence['outputs.DirectCloudwatchHistoricalDataRetrievalDefaultDuration']:
        """
        Used by default for any SLOs connected to this data source.
        """
        return pulumi.get(self, "default_durations")

    @property
    @pulumi.getter(name="maxDurations")
    def max_durations(self) -> Sequence['outputs.DirectCloudwatchHistoricalDataRetrievalMaxDuration']:
        """
        Defines the maximum period for which data can be retrieved.
        """
        return pulumi.get(self, "max_durations")


@pulumi.output_type
class DirectCloudwatchHistoricalDataRetrievalDefaultDuration(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectCloudwatchHistoricalDataRetrievalMaxDuration(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectCloudwatchQueryDelay(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute or Second.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute or Second.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectDatadogHistoricalDataRetrieval(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultDurations":
            suggest = "default_durations"
        elif key == "maxDurations":
            suggest = "max_durations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DirectDatadogHistoricalDataRetrieval. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DirectDatadogHistoricalDataRetrieval.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DirectDatadogHistoricalDataRetrieval.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_durations: Sequence['outputs.DirectDatadogHistoricalDataRetrievalDefaultDuration'],
                 max_durations: Sequence['outputs.DirectDatadogHistoricalDataRetrievalMaxDuration']):
        """
        :param Sequence['DirectDatadogHistoricalDataRetrievalDefaultDurationArgs'] default_durations: Used by default for any SLOs connected to this data source.
        :param Sequence['DirectDatadogHistoricalDataRetrievalMaxDurationArgs'] max_durations: Defines the maximum period for which data can be retrieved.
        """
        pulumi.set(__self__, "default_durations", default_durations)
        pulumi.set(__self__, "max_durations", max_durations)

    @property
    @pulumi.getter(name="defaultDurations")
    def default_durations(self) -> Sequence['outputs.DirectDatadogHistoricalDataRetrievalDefaultDuration']:
        """
        Used by default for any SLOs connected to this data source.
        """
        return pulumi.get(self, "default_durations")

    @property
    @pulumi.getter(name="maxDurations")
    def max_durations(self) -> Sequence['outputs.DirectDatadogHistoricalDataRetrievalMaxDuration']:
        """
        Defines the maximum period for which data can be retrieved.
        """
        return pulumi.get(self, "max_durations")


@pulumi.output_type
class DirectDatadogHistoricalDataRetrievalDefaultDuration(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectDatadogHistoricalDataRetrievalMaxDuration(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectDatadogQueryDelay(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute or Second.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute or Second.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectDynatraceHistoricalDataRetrieval(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultDurations":
            suggest = "default_durations"
        elif key == "maxDurations":
            suggest = "max_durations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DirectDynatraceHistoricalDataRetrieval. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DirectDynatraceHistoricalDataRetrieval.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DirectDynatraceHistoricalDataRetrieval.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_durations: Sequence['outputs.DirectDynatraceHistoricalDataRetrievalDefaultDuration'],
                 max_durations: Sequence['outputs.DirectDynatraceHistoricalDataRetrievalMaxDuration']):
        """
        :param Sequence['DirectDynatraceHistoricalDataRetrievalDefaultDurationArgs'] default_durations: Used by default for any SLOs connected to this data source.
        :param Sequence['DirectDynatraceHistoricalDataRetrievalMaxDurationArgs'] max_durations: Defines the maximum period for which data can be retrieved.
        """
        pulumi.set(__self__, "default_durations", default_durations)
        pulumi.set(__self__, "max_durations", max_durations)

    @property
    @pulumi.getter(name="defaultDurations")
    def default_durations(self) -> Sequence['outputs.DirectDynatraceHistoricalDataRetrievalDefaultDuration']:
        """
        Used by default for any SLOs connected to this data source.
        """
        return pulumi.get(self, "default_durations")

    @property
    @pulumi.getter(name="maxDurations")
    def max_durations(self) -> Sequence['outputs.DirectDynatraceHistoricalDataRetrievalMaxDuration']:
        """
        Defines the maximum period for which data can be retrieved.
        """
        return pulumi.get(self, "max_durations")


@pulumi.output_type
class DirectDynatraceHistoricalDataRetrievalDefaultDuration(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectDynatraceHistoricalDataRetrievalMaxDuration(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectDynatraceQueryDelay(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute or Second.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute or Second.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectGcmQueryDelay(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute or Second.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute or Second.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectInfluxdbQueryDelay(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute or Second.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute or Second.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectInstanaQueryDelay(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute or Second.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute or Second.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectLightstepHistoricalDataRetrieval(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultDurations":
            suggest = "default_durations"
        elif key == "maxDurations":
            suggest = "max_durations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DirectLightstepHistoricalDataRetrieval. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DirectLightstepHistoricalDataRetrieval.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DirectLightstepHistoricalDataRetrieval.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_durations: Sequence['outputs.DirectLightstepHistoricalDataRetrievalDefaultDuration'],
                 max_durations: Sequence['outputs.DirectLightstepHistoricalDataRetrievalMaxDuration']):
        """
        :param Sequence['DirectLightstepHistoricalDataRetrievalDefaultDurationArgs'] default_durations: Used by default for any SLOs connected to this data source.
        :param Sequence['DirectLightstepHistoricalDataRetrievalMaxDurationArgs'] max_durations: Defines the maximum period for which data can be retrieved.
        """
        pulumi.set(__self__, "default_durations", default_durations)
        pulumi.set(__self__, "max_durations", max_durations)

    @property
    @pulumi.getter(name="defaultDurations")
    def default_durations(self) -> Sequence['outputs.DirectLightstepHistoricalDataRetrievalDefaultDuration']:
        """
        Used by default for any SLOs connected to this data source.
        """
        return pulumi.get(self, "default_durations")

    @property
    @pulumi.getter(name="maxDurations")
    def max_durations(self) -> Sequence['outputs.DirectLightstepHistoricalDataRetrievalMaxDuration']:
        """
        Defines the maximum period for which data can be retrieved.
        """
        return pulumi.get(self, "max_durations")


@pulumi.output_type
class DirectLightstepHistoricalDataRetrievalDefaultDuration(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectLightstepHistoricalDataRetrievalMaxDuration(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectLightstepQueryDelay(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute or Second.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute or Second.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectNewrelicHistoricalDataRetrieval(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultDurations":
            suggest = "default_durations"
        elif key == "maxDurations":
            suggest = "max_durations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DirectNewrelicHistoricalDataRetrieval. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DirectNewrelicHistoricalDataRetrieval.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DirectNewrelicHistoricalDataRetrieval.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_durations: Sequence['outputs.DirectNewrelicHistoricalDataRetrievalDefaultDuration'],
                 max_durations: Sequence['outputs.DirectNewrelicHistoricalDataRetrievalMaxDuration']):
        """
        :param Sequence['DirectNewrelicHistoricalDataRetrievalDefaultDurationArgs'] default_durations: Used by default for any SLOs connected to this data source.
        :param Sequence['DirectNewrelicHistoricalDataRetrievalMaxDurationArgs'] max_durations: Defines the maximum period for which data can be retrieved.
        """
        pulumi.set(__self__, "default_durations", default_durations)
        pulumi.set(__self__, "max_durations", max_durations)

    @property
    @pulumi.getter(name="defaultDurations")
    def default_durations(self) -> Sequence['outputs.DirectNewrelicHistoricalDataRetrievalDefaultDuration']:
        """
        Used by default for any SLOs connected to this data source.
        """
        return pulumi.get(self, "default_durations")

    @property
    @pulumi.getter(name="maxDurations")
    def max_durations(self) -> Sequence['outputs.DirectNewrelicHistoricalDataRetrievalMaxDuration']:
        """
        Defines the maximum period for which data can be retrieved.
        """
        return pulumi.get(self, "max_durations")


@pulumi.output_type
class DirectNewrelicHistoricalDataRetrievalDefaultDuration(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectNewrelicHistoricalDataRetrievalMaxDuration(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectNewrelicQueryDelay(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute or Second.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute or Second.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectPingdomQueryDelay(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute or Second.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute or Second.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectRedshiftQueryDelay(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute or Second.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute or Second.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectSplunkHistoricalDataRetrieval(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultDurations":
            suggest = "default_durations"
        elif key == "maxDurations":
            suggest = "max_durations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DirectSplunkHistoricalDataRetrieval. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DirectSplunkHistoricalDataRetrieval.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DirectSplunkHistoricalDataRetrieval.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_durations: Sequence['outputs.DirectSplunkHistoricalDataRetrievalDefaultDuration'],
                 max_durations: Sequence['outputs.DirectSplunkHistoricalDataRetrievalMaxDuration']):
        """
        :param Sequence['DirectSplunkHistoricalDataRetrievalDefaultDurationArgs'] default_durations: Used by default for any SLOs connected to this data source.
        :param Sequence['DirectSplunkHistoricalDataRetrievalMaxDurationArgs'] max_durations: Defines the maximum period for which data can be retrieved.
        """
        pulumi.set(__self__, "default_durations", default_durations)
        pulumi.set(__self__, "max_durations", max_durations)

    @property
    @pulumi.getter(name="defaultDurations")
    def default_durations(self) -> Sequence['outputs.DirectSplunkHistoricalDataRetrievalDefaultDuration']:
        """
        Used by default for any SLOs connected to this data source.
        """
        return pulumi.get(self, "default_durations")

    @property
    @pulumi.getter(name="maxDurations")
    def max_durations(self) -> Sequence['outputs.DirectSplunkHistoricalDataRetrievalMaxDuration']:
        """
        Defines the maximum period for which data can be retrieved.
        """
        return pulumi.get(self, "max_durations")


@pulumi.output_type
class DirectSplunkHistoricalDataRetrievalDefaultDuration(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectSplunkHistoricalDataRetrievalMaxDuration(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectSplunkObservabilityQueryDelay(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute or Second.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute or Second.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectSplunkQueryDelay(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute or Second.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute or Second.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectSumologicQueryDelay(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute or Second.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute or Second.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectThousandeyesQueryDelay(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute or Second.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute or Second.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProjectLabel(dict):
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str]):
        """
        :param str key: A key for the label, unique within the associated resource.
        :param Sequence[str] values: A list of unique values for a single key.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        A key for the label, unique within the associated resource.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        A list of unique values for a single key.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class ServiceLabel(dict):
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str]):
        """
        :param str key: A key for the label, unique within the associated resource.
        :param Sequence[str] values: A list of unique values for a single key.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        A key for the label, unique within the associated resource.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        A list of unique values for a single key.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class SloAttachment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloAttachment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloAttachment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloAttachment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 display_name: Optional[str] = None):
        """
        :param str url: URL to the attachment
        :param str display_name: Name displayed for the attachment. Max. length: 63 characters.
        """
        pulumi.set(__self__, "url", url)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        URL to the attachment
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        Name displayed for the attachment. Max. length: 63 characters.
        """
        return pulumi.get(self, "display_name")


@pulumi.output_type
class SloComposite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "burnRateConditions":
            suggest = "burn_rate_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloComposite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloComposite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloComposite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target: float,
                 burn_rate_conditions: Optional[Sequence['outputs.SloCompositeBurnRateCondition']] = None):
        """
        :param float target: Designated value
        :param Sequence['SloCompositeBurnRateConditionArgs'] burn_rate_conditions: Condition when the Composite SLO’s error budget is burning.
        """
        pulumi.set(__self__, "target", target)
        if burn_rate_conditions is not None:
            pulumi.set(__self__, "burn_rate_conditions", burn_rate_conditions)

    @property
    @pulumi.getter
    def target(self) -> float:
        """
        Designated value
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="burnRateConditions")
    def burn_rate_conditions(self) -> Optional[Sequence['outputs.SloCompositeBurnRateCondition']]:
        """
        Condition when the Composite SLO’s error budget is burning.
        """
        return pulumi.get(self, "burn_rate_conditions")


@pulumi.output_type
class SloCompositeBurnRateCondition(dict):
    def __init__(__self__, *,
                 op: str,
                 value: float):
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def op(self) -> str:
        return pulumi.get(self, "op")

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class SloIndicator(dict):
    def __init__(__self__, *,
                 name: str,
                 kind: Optional[str] = None,
                 project: Optional[str] = None):
        """
        :param str name: Name of the metric source (agent).
        :param str kind: Kind of the metric source. One of {Agent, Direct}.
        :param str project: Name of the metric source project.
        """
        pulumi.set(__self__, "name", name)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if project is not None:
            pulumi.set(__self__, "project", project)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the metric source (agent).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the metric source. One of {Agent, Direct}.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def project(self) -> Optional[str]:
        """
        Name of the metric source project.
        """
        return pulumi.get(self, "project")


@pulumi.output_type
class SloLabel(dict):
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str]):
        """
        :param str key: A key for the label, unique within the associated resource.
        :param Sequence[str] values: A list of unique values for a single key.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        A key for the label, unique within the associated resource.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        A list of unique values for a single key.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class SloObjective(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "countMetrics":
            suggest = "count_metrics"
        elif key == "rawMetrics":
            suggest = "raw_metrics"
        elif key == "timeSliceTarget":
            suggest = "time_slice_target"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjective. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjective.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjective.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: str,
                 target: float,
                 value: float,
                 count_metrics: Optional[Sequence['outputs.SloObjectiveCountMetric']] = None,
                 name: Optional[str] = None,
                 op: Optional[str] = None,
                 raw_metrics: Optional[Sequence['outputs.SloObjectiveRawMetric']] = None,
                 time_slice_target: Optional[float] = None):
        """
        :param str display_name: Name to be displayed
        :param float target: Designated value
        :param float value: Value
        :param Sequence['SloObjectiveCountMetricArgs'] count_metrics: Compares two time series, indicating the ratio of the count of good values to total values.
        :param str name: Objective's name. This field is computed if not provided.
        :param str op: Type of logical operation
        :param Sequence['SloObjectiveRawMetricArgs'] raw_metrics: Raw data is used to compare objective values.
        :param float time_slice_target: Designated value for slice
        """
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "value", value)
        if count_metrics is not None:
            pulumi.set(__self__, "count_metrics", count_metrics)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if op is not None:
            pulumi.set(__self__, "op", op)
        if raw_metrics is not None:
            pulumi.set(__self__, "raw_metrics", raw_metrics)
        if time_slice_target is not None:
            pulumi.set(__self__, "time_slice_target", time_slice_target)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        Name to be displayed
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def target(self) -> float:
        """
        Designated value
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        Value
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="countMetrics")
    def count_metrics(self) -> Optional[Sequence['outputs.SloObjectiveCountMetric']]:
        """
        Compares two time series, indicating the ratio of the count of good values to total values.
        """
        return pulumi.get(self, "count_metrics")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Objective's name. This field is computed if not provided.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def op(self) -> Optional[str]:
        """
        Type of logical operation
        """
        return pulumi.get(self, "op")

    @property
    @pulumi.getter(name="rawMetrics")
    def raw_metrics(self) -> Optional[Sequence['outputs.SloObjectiveRawMetric']]:
        """
        Raw data is used to compare objective values.
        """
        return pulumi.get(self, "raw_metrics")

    @property
    @pulumi.getter(name="timeSliceTarget")
    def time_slice_target(self) -> Optional[float]:
        """
        Designated value for slice
        """
        return pulumi.get(self, "time_slice_target")


@pulumi.output_type
class SloObjectiveCountMetric(dict):
    def __init__(__self__, *,
                 incremental: bool,
                 goods: Optional[Sequence['outputs.SloObjectiveCountMetricGood']] = None,
                 totals: Optional[Sequence['outputs.SloObjectiveCountMetricTotal']] = None):
        pulumi.set(__self__, "incremental", incremental)
        if goods is not None:
            pulumi.set(__self__, "goods", goods)
        if totals is not None:
            pulumi.set(__self__, "totals", totals)

    @property
    @pulumi.getter
    def incremental(self) -> bool:
        return pulumi.get(self, "incremental")

    @property
    @pulumi.getter
    def goods(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGood']]:
        return pulumi.get(self, "goods")

    @property
    @pulumi.getter
    def totals(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotal']]:
        return pulumi.get(self, "totals")


@pulumi.output_type
class SloObjectiveCountMetricGood(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "amazonPrometheuses":
            suggest = "amazon_prometheuses"
        elif key == "grafanaLokis":
            suggest = "grafana_lokis"
        elif key == "splunkObservabilities":
            suggest = "splunk_observabilities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricGood. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricGood.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricGood.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amazon_prometheuses: Optional[Sequence['outputs.SloObjectiveCountMetricGoodAmazonPrometheus']] = None,
                 appdynamics: Optional[Sequence['outputs.SloObjectiveCountMetricGoodAppdynamic']] = None,
                 bigqueries: Optional[Sequence['outputs.SloObjectiveCountMetricGoodBigquery']] = None,
                 cloudwatches: Optional[Sequence['outputs.SloObjectiveCountMetricGoodCloudwatch']] = None,
                 datadogs: Optional[Sequence['outputs.SloObjectiveCountMetricGoodDatadog']] = None,
                 dynatraces: Optional[Sequence['outputs.SloObjectiveCountMetricGoodDynatrace']] = None,
                 elasticsearches: Optional[Sequence['outputs.SloObjectiveCountMetricGoodElasticsearch']] = None,
                 gcms: Optional[Sequence['outputs.SloObjectiveCountMetricGoodGcm']] = None,
                 grafana_lokis: Optional[Sequence['outputs.SloObjectiveCountMetricGoodGrafanaLoki']] = None,
                 graphites: Optional[Sequence['outputs.SloObjectiveCountMetricGoodGraphite']] = None,
                 influxdbs: Optional[Sequence['outputs.SloObjectiveCountMetricGoodInfluxdb']] = None,
                 instanas: Optional[Sequence['outputs.SloObjectiveCountMetricGoodInstana']] = None,
                 lightsteps: Optional[Sequence['outputs.SloObjectiveCountMetricGoodLightstep']] = None,
                 newrelics: Optional[Sequence['outputs.SloObjectiveCountMetricGoodNewrelic']] = None,
                 opentsdbs: Optional[Sequence['outputs.SloObjectiveCountMetricGoodOpentsdb']] = None,
                 pingdoms: Optional[Sequence['outputs.SloObjectiveCountMetricGoodPingdom']] = None,
                 prometheuses: Optional[Sequence['outputs.SloObjectiveCountMetricGoodPrometheus']] = None,
                 redshifts: Optional[Sequence['outputs.SloObjectiveCountMetricGoodRedshift']] = None,
                 splunk_observabilities: Optional[Sequence['outputs.SloObjectiveCountMetricGoodSplunkObservability']] = None,
                 splunks: Optional[Sequence['outputs.SloObjectiveCountMetricGoodSplunk']] = None,
                 sumologics: Optional[Sequence['outputs.SloObjectiveCountMetricGoodSumologic']] = None,
                 thousandeyes: Optional[Sequence['outputs.SloObjectiveCountMetricGoodThousandeye']] = None):
        if amazon_prometheuses is not None:
            pulumi.set(__self__, "amazon_prometheuses", amazon_prometheuses)
        if appdynamics is not None:
            pulumi.set(__self__, "appdynamics", appdynamics)
        if bigqueries is not None:
            pulumi.set(__self__, "bigqueries", bigqueries)
        if cloudwatches is not None:
            pulumi.set(__self__, "cloudwatches", cloudwatches)
        if datadogs is not None:
            pulumi.set(__self__, "datadogs", datadogs)
        if dynatraces is not None:
            pulumi.set(__self__, "dynatraces", dynatraces)
        if elasticsearches is not None:
            pulumi.set(__self__, "elasticsearches", elasticsearches)
        if gcms is not None:
            pulumi.set(__self__, "gcms", gcms)
        if grafana_lokis is not None:
            pulumi.set(__self__, "grafana_lokis", grafana_lokis)
        if graphites is not None:
            pulumi.set(__self__, "graphites", graphites)
        if influxdbs is not None:
            pulumi.set(__self__, "influxdbs", influxdbs)
        if instanas is not None:
            pulumi.set(__self__, "instanas", instanas)
        if lightsteps is not None:
            pulumi.set(__self__, "lightsteps", lightsteps)
        if newrelics is not None:
            pulumi.set(__self__, "newrelics", newrelics)
        if opentsdbs is not None:
            pulumi.set(__self__, "opentsdbs", opentsdbs)
        if pingdoms is not None:
            pulumi.set(__self__, "pingdoms", pingdoms)
        if prometheuses is not None:
            pulumi.set(__self__, "prometheuses", prometheuses)
        if redshifts is not None:
            pulumi.set(__self__, "redshifts", redshifts)
        if splunk_observabilities is not None:
            pulumi.set(__self__, "splunk_observabilities", splunk_observabilities)
        if splunks is not None:
            pulumi.set(__self__, "splunks", splunks)
        if sumologics is not None:
            pulumi.set(__self__, "sumologics", sumologics)
        if thousandeyes is not None:
            pulumi.set(__self__, "thousandeyes", thousandeyes)

    @property
    @pulumi.getter(name="amazonPrometheuses")
    def amazon_prometheuses(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodAmazonPrometheus']]:
        return pulumi.get(self, "amazon_prometheuses")

    @property
    @pulumi.getter
    def appdynamics(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodAppdynamic']]:
        return pulumi.get(self, "appdynamics")

    @property
    @pulumi.getter
    def bigqueries(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodBigquery']]:
        return pulumi.get(self, "bigqueries")

    @property
    @pulumi.getter
    def cloudwatches(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodCloudwatch']]:
        return pulumi.get(self, "cloudwatches")

    @property
    @pulumi.getter
    def datadogs(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodDatadog']]:
        return pulumi.get(self, "datadogs")

    @property
    @pulumi.getter
    def dynatraces(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodDynatrace']]:
        return pulumi.get(self, "dynatraces")

    @property
    @pulumi.getter
    def elasticsearches(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodElasticsearch']]:
        return pulumi.get(self, "elasticsearches")

    @property
    @pulumi.getter
    def gcms(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodGcm']]:
        return pulumi.get(self, "gcms")

    @property
    @pulumi.getter(name="grafanaLokis")
    def grafana_lokis(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodGrafanaLoki']]:
        return pulumi.get(self, "grafana_lokis")

    @property
    @pulumi.getter
    def graphites(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodGraphite']]:
        return pulumi.get(self, "graphites")

    @property
    @pulumi.getter
    def influxdbs(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodInfluxdb']]:
        return pulumi.get(self, "influxdbs")

    @property
    @pulumi.getter
    def instanas(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodInstana']]:
        return pulumi.get(self, "instanas")

    @property
    @pulumi.getter
    def lightsteps(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodLightstep']]:
        return pulumi.get(self, "lightsteps")

    @property
    @pulumi.getter
    def newrelics(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodNewrelic']]:
        return pulumi.get(self, "newrelics")

    @property
    @pulumi.getter
    def opentsdbs(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodOpentsdb']]:
        return pulumi.get(self, "opentsdbs")

    @property
    @pulumi.getter
    def pingdoms(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodPingdom']]:
        return pulumi.get(self, "pingdoms")

    @property
    @pulumi.getter
    def prometheuses(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodPrometheus']]:
        return pulumi.get(self, "prometheuses")

    @property
    @pulumi.getter
    def redshifts(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodRedshift']]:
        return pulumi.get(self, "redshifts")

    @property
    @pulumi.getter(name="splunkObservabilities")
    def splunk_observabilities(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodSplunkObservability']]:
        return pulumi.get(self, "splunk_observabilities")

    @property
    @pulumi.getter
    def splunks(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodSplunk']]:
        return pulumi.get(self, "splunks")

    @property
    @pulumi.getter
    def sumologics(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodSumologic']]:
        return pulumi.get(self, "sumologics")

    @property
    @pulumi.getter
    def thousandeyes(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodThousandeye']]:
        return pulumi.get(self, "thousandeyes")


@pulumi.output_type
class SloObjectiveCountMetricGoodAmazonPrometheus(dict):
    def __init__(__self__, *,
                 promql: str):
        pulumi.set(__self__, "promql", promql)

    @property
    @pulumi.getter
    def promql(self) -> str:
        return pulumi.get(self, "promql")


@pulumi.output_type
class SloObjectiveCountMetricGoodAppdynamic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationName":
            suggest = "application_name"
        elif key == "metricPath":
            suggest = "metric_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricGoodAppdynamic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricGoodAppdynamic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricGoodAppdynamic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_name: str,
                 metric_path: str):
        pulumi.set(__self__, "application_name", application_name)
        pulumi.set(__self__, "metric_path", metric_path)

    @property
    @pulumi.getter(name="applicationName")
    def application_name(self) -> str:
        return pulumi.get(self, "application_name")

    @property
    @pulumi.getter(name="metricPath")
    def metric_path(self) -> str:
        return pulumi.get(self, "metric_path")


@pulumi.output_type
class SloObjectiveCountMetricGoodBigquery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricGoodBigquery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricGoodBigquery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricGoodBigquery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 location: str,
                 project_id: str,
                 query: str):
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def location(self) -> str:
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveCountMetricGoodCloudwatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricGoodCloudwatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricGoodCloudwatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricGoodCloudwatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region: str,
                 dimensions: Optional[Sequence['outputs.SloObjectiveCountMetricGoodCloudwatchDimension']] = None,
                 json: Optional[str] = None,
                 metric_name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 sql: Optional[str] = None,
                 stat: Optional[str] = None):
        pulumi.set(__self__, "region", region)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if json is not None:
            pulumi.set(__self__, "json", json)
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if sql is not None:
            pulumi.set(__self__, "sql", sql)
        if stat is not None:
            pulumi.set(__self__, "stat", stat)

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodCloudwatchDimension']]:
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def json(self) -> Optional[str]:
        return pulumi.get(self, "json")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[str]:
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def sql(self) -> Optional[str]:
        return pulumi.get(self, "sql")

    @property
    @pulumi.getter
    def stat(self) -> Optional[str]:
        return pulumi.get(self, "stat")


@pulumi.output_type
class SloObjectiveCountMetricGoodCloudwatchDimension(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Unique name of the resource, must conform to the naming convention from [DNS RFC1123](https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique name of the resource, must conform to the naming convention from [DNS RFC1123](https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SloObjectiveCountMetricGoodDatadog(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveCountMetricGoodDynatrace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricSelector":
            suggest = "metric_selector"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricGoodDynatrace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricGoodDynatrace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricGoodDynatrace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_selector: str):
        pulumi.set(__self__, "metric_selector", metric_selector)

    @property
    @pulumi.getter(name="metricSelector")
    def metric_selector(self) -> str:
        return pulumi.get(self, "metric_selector")


@pulumi.output_type
class SloObjectiveCountMetricGoodElasticsearch(dict):
    def __init__(__self__, *,
                 index: str,
                 query: str):
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveCountMetricGoodGcm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricGoodGcm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricGoodGcm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricGoodGcm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 project_id: str,
                 query: str):
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveCountMetricGoodGrafanaLoki(dict):
    def __init__(__self__, *,
                 logql: str):
        pulumi.set(__self__, "logql", logql)

    @property
    @pulumi.getter
    def logql(self) -> str:
        return pulumi.get(self, "logql")


@pulumi.output_type
class SloObjectiveCountMetricGoodGraphite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricPath":
            suggest = "metric_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricGoodGraphite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricGoodGraphite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricGoodGraphite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_path: str):
        pulumi.set(__self__, "metric_path", metric_path)

    @property
    @pulumi.getter(name="metricPath")
    def metric_path(self) -> str:
        return pulumi.get(self, "metric_path")


@pulumi.output_type
class SloObjectiveCountMetricGoodInfluxdb(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveCountMetricGoodInstana(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricType":
            suggest = "metric_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricGoodInstana. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricGoodInstana.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricGoodInstana.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_type: str,
                 applications: Optional[Sequence['outputs.SloObjectiveCountMetricGoodInstanaApplication']] = None,
                 infrastructures: Optional[Sequence['outputs.SloObjectiveCountMetricGoodInstanaInfrastructure']] = None):
        pulumi.set(__self__, "metric_type", metric_type)
        if applications is not None:
            pulumi.set(__self__, "applications", applications)
        if infrastructures is not None:
            pulumi.set(__self__, "infrastructures", infrastructures)

    @property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> str:
        return pulumi.get(self, "metric_type")

    @property
    @pulumi.getter
    def applications(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodInstanaApplication']]:
        return pulumi.get(self, "applications")

    @property
    @pulumi.getter
    def infrastructures(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodInstanaInfrastructure']]:
        return pulumi.get(self, "infrastructures")


@pulumi.output_type
class SloObjectiveCountMetricGoodInstanaApplication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiQuery":
            suggest = "api_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "metricId":
            suggest = "metric_id"
        elif key == "includeInternal":
            suggest = "include_internal"
        elif key == "includeSynthetic":
            suggest = "include_synthetic"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricGoodInstanaApplication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricGoodInstanaApplication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricGoodInstanaApplication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation: str,
                 api_query: str,
                 group_bies: Sequence['outputs.SloObjectiveCountMetricGoodInstanaApplicationGroupBy'],
                 metric_id: str,
                 include_internal: Optional[bool] = None,
                 include_synthetic: Optional[bool] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "api_query", api_query)
        pulumi.set(__self__, "group_bies", group_bies)
        pulumi.set(__self__, "metric_id", metric_id)
        if include_internal is not None:
            pulumi.set(__self__, "include_internal", include_internal)
        if include_synthetic is not None:
            pulumi.set(__self__, "include_synthetic", include_synthetic)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="apiQuery")
    def api_query(self) -> str:
        return pulumi.get(self, "api_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Sequence['outputs.SloObjectiveCountMetricGoodInstanaApplicationGroupBy']:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="metricId")
    def metric_id(self) -> str:
        return pulumi.get(self, "metric_id")

    @property
    @pulumi.getter(name="includeInternal")
    def include_internal(self) -> Optional[bool]:
        return pulumi.get(self, "include_internal")

    @property
    @pulumi.getter(name="includeSynthetic")
    def include_synthetic(self) -> Optional[bool]:
        return pulumi.get(self, "include_synthetic")


@pulumi.output_type
class SloObjectiveCountMetricGoodInstanaApplicationGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagEntity":
            suggest = "tag_entity"
        elif key == "tagSecondLevelKey":
            suggest = "tag_second_level_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricGoodInstanaApplicationGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricGoodInstanaApplicationGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricGoodInstanaApplicationGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tag: str,
                 tag_entity: str,
                 tag_second_level_key: Optional[str] = None):
        pulumi.set(__self__, "tag", tag)
        pulumi.set(__self__, "tag_entity", tag_entity)
        if tag_second_level_key is not None:
            pulumi.set(__self__, "tag_second_level_key", tag_second_level_key)

    @property
    @pulumi.getter
    def tag(self) -> str:
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter(name="tagEntity")
    def tag_entity(self) -> str:
        return pulumi.get(self, "tag_entity")

    @property
    @pulumi.getter(name="tagSecondLevelKey")
    def tag_second_level_key(self) -> Optional[str]:
        return pulumi.get(self, "tag_second_level_key")


@pulumi.output_type
class SloObjectiveCountMetricGoodInstanaInfrastructure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricId":
            suggest = "metric_id"
        elif key == "metricRetrievalMethod":
            suggest = "metric_retrieval_method"
        elif key == "pluginId":
            suggest = "plugin_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricGoodInstanaInfrastructure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricGoodInstanaInfrastructure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricGoodInstanaInfrastructure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_id: str,
                 metric_retrieval_method: str,
                 plugin_id: str,
                 query: Optional[str] = None,
                 snapshot_id: Optional[str] = None):
        pulumi.set(__self__, "metric_id", metric_id)
        pulumi.set(__self__, "metric_retrieval_method", metric_retrieval_method)
        pulumi.set(__self__, "plugin_id", plugin_id)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)

    @property
    @pulumi.getter(name="metricId")
    def metric_id(self) -> str:
        return pulumi.get(self, "metric_id")

    @property
    @pulumi.getter(name="metricRetrievalMethod")
    def metric_retrieval_method(self) -> str:
        return pulumi.get(self, "metric_retrieval_method")

    @property
    @pulumi.getter(name="pluginId")
    def plugin_id(self) -> str:
        return pulumi.get(self, "plugin_id")

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        return pulumi.get(self, "snapshot_id")


@pulumi.output_type
class SloObjectiveCountMetricGoodLightstep(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeOfData":
            suggest = "type_of_data"
        elif key == "streamId":
            suggest = "stream_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricGoodLightstep. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricGoodLightstep.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricGoodLightstep.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type_of_data: str,
                 percentile: Optional[float] = None,
                 stream_id: Optional[str] = None,
                 uql: Optional[str] = None):
        pulumi.set(__self__, "type_of_data", type_of_data)
        if percentile is not None:
            pulumi.set(__self__, "percentile", percentile)
        if stream_id is not None:
            pulumi.set(__self__, "stream_id", stream_id)
        if uql is not None:
            pulumi.set(__self__, "uql", uql)

    @property
    @pulumi.getter(name="typeOfData")
    def type_of_data(self) -> str:
        return pulumi.get(self, "type_of_data")

    @property
    @pulumi.getter
    def percentile(self) -> Optional[float]:
        return pulumi.get(self, "percentile")

    @property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> Optional[str]:
        return pulumi.get(self, "stream_id")

    @property
    @pulumi.getter
    def uql(self) -> Optional[str]:
        return pulumi.get(self, "uql")


@pulumi.output_type
class SloObjectiveCountMetricGoodNewrelic(dict):
    def __init__(__self__, *,
                 nrql: str):
        pulumi.set(__self__, "nrql", nrql)

    @property
    @pulumi.getter
    def nrql(self) -> str:
        return pulumi.get(self, "nrql")


@pulumi.output_type
class SloObjectiveCountMetricGoodOpentsdb(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveCountMetricGoodPingdom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkId":
            suggest = "check_id"
        elif key == "checkType":
            suggest = "check_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricGoodPingdom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricGoodPingdom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricGoodPingdom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check_id: str,
                 check_type: Optional[str] = None,
                 status: Optional[str] = None):
        pulumi.set(__self__, "check_id", check_id)
        if check_type is not None:
            pulumi.set(__self__, "check_type", check_type)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="checkId")
    def check_id(self) -> str:
        return pulumi.get(self, "check_id")

    @property
    @pulumi.getter(name="checkType")
    def check_type(self) -> Optional[str]:
        return pulumi.get(self, "check_type")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        return pulumi.get(self, "status")


@pulumi.output_type
class SloObjectiveCountMetricGoodPrometheus(dict):
    def __init__(__self__, *,
                 promql: str):
        pulumi.set(__self__, "promql", promql)

    @property
    @pulumi.getter
    def promql(self) -> str:
        return pulumi.get(self, "promql")


@pulumi.output_type
class SloObjectiveCountMetricGoodRedshift(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterId":
            suggest = "cluster_id"
        elif key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricGoodRedshift. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricGoodRedshift.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricGoodRedshift.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_id: str,
                 database_name: str,
                 query: str,
                 region: str):
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> str:
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")


@pulumi.output_type
class SloObjectiveCountMetricGoodSplunk(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveCountMetricGoodSplunkObservability(dict):
    def __init__(__self__, *,
                 program: str):
        pulumi.set(__self__, "program", program)

    @property
    @pulumi.getter
    def program(self) -> str:
        return pulumi.get(self, "program")


@pulumi.output_type
class SloObjectiveCountMetricGoodSumologic(dict):
    def __init__(__self__, *,
                 query: str,
                 type: str,
                 quantization: Optional[str] = None,
                 rollup: Optional[str] = None):
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "type", type)
        if quantization is not None:
            pulumi.set(__self__, "quantization", quantization)
        if rollup is not None:
            pulumi.set(__self__, "rollup", rollup)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def quantization(self) -> Optional[str]:
        return pulumi.get(self, "quantization")

    @property
    @pulumi.getter
    def rollup(self) -> Optional[str]:
        return pulumi.get(self, "rollup")


@pulumi.output_type
class SloObjectiveCountMetricGoodThousandeye(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "testId":
            suggest = "test_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricGoodThousandeye. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricGoodThousandeye.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricGoodThousandeye.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 test_id: int):
        pulumi.set(__self__, "test_id", test_id)

    @property
    @pulumi.getter(name="testId")
    def test_id(self) -> int:
        return pulumi.get(self, "test_id")


@pulumi.output_type
class SloObjectiveCountMetricTotal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "amazonPrometheuses":
            suggest = "amazon_prometheuses"
        elif key == "grafanaLokis":
            suggest = "grafana_lokis"
        elif key == "splunkObservabilities":
            suggest = "splunk_observabilities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricTotal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricTotal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricTotal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amazon_prometheuses: Optional[Sequence['outputs.SloObjectiveCountMetricTotalAmazonPrometheus']] = None,
                 appdynamics: Optional[Sequence['outputs.SloObjectiveCountMetricTotalAppdynamic']] = None,
                 bigqueries: Optional[Sequence['outputs.SloObjectiveCountMetricTotalBigquery']] = None,
                 cloudwatches: Optional[Sequence['outputs.SloObjectiveCountMetricTotalCloudwatch']] = None,
                 datadogs: Optional[Sequence['outputs.SloObjectiveCountMetricTotalDatadog']] = None,
                 dynatraces: Optional[Sequence['outputs.SloObjectiveCountMetricTotalDynatrace']] = None,
                 elasticsearches: Optional[Sequence['outputs.SloObjectiveCountMetricTotalElasticsearch']] = None,
                 gcms: Optional[Sequence['outputs.SloObjectiveCountMetricTotalGcm']] = None,
                 grafana_lokis: Optional[Sequence['outputs.SloObjectiveCountMetricTotalGrafanaLoki']] = None,
                 graphites: Optional[Sequence['outputs.SloObjectiveCountMetricTotalGraphite']] = None,
                 influxdbs: Optional[Sequence['outputs.SloObjectiveCountMetricTotalInfluxdb']] = None,
                 instanas: Optional[Sequence['outputs.SloObjectiveCountMetricTotalInstana']] = None,
                 lightsteps: Optional[Sequence['outputs.SloObjectiveCountMetricTotalLightstep']] = None,
                 newrelics: Optional[Sequence['outputs.SloObjectiveCountMetricTotalNewrelic']] = None,
                 opentsdbs: Optional[Sequence['outputs.SloObjectiveCountMetricTotalOpentsdb']] = None,
                 pingdoms: Optional[Sequence['outputs.SloObjectiveCountMetricTotalPingdom']] = None,
                 prometheuses: Optional[Sequence['outputs.SloObjectiveCountMetricTotalPrometheus']] = None,
                 redshifts: Optional[Sequence['outputs.SloObjectiveCountMetricTotalRedshift']] = None,
                 splunk_observabilities: Optional[Sequence['outputs.SloObjectiveCountMetricTotalSplunkObservability']] = None,
                 splunks: Optional[Sequence['outputs.SloObjectiveCountMetricTotalSplunk']] = None,
                 sumologics: Optional[Sequence['outputs.SloObjectiveCountMetricTotalSumologic']] = None,
                 thousandeyes: Optional[Sequence['outputs.SloObjectiveCountMetricTotalThousandeye']] = None):
        if amazon_prometheuses is not None:
            pulumi.set(__self__, "amazon_prometheuses", amazon_prometheuses)
        if appdynamics is not None:
            pulumi.set(__self__, "appdynamics", appdynamics)
        if bigqueries is not None:
            pulumi.set(__self__, "bigqueries", bigqueries)
        if cloudwatches is not None:
            pulumi.set(__self__, "cloudwatches", cloudwatches)
        if datadogs is not None:
            pulumi.set(__self__, "datadogs", datadogs)
        if dynatraces is not None:
            pulumi.set(__self__, "dynatraces", dynatraces)
        if elasticsearches is not None:
            pulumi.set(__self__, "elasticsearches", elasticsearches)
        if gcms is not None:
            pulumi.set(__self__, "gcms", gcms)
        if grafana_lokis is not None:
            pulumi.set(__self__, "grafana_lokis", grafana_lokis)
        if graphites is not None:
            pulumi.set(__self__, "graphites", graphites)
        if influxdbs is not None:
            pulumi.set(__self__, "influxdbs", influxdbs)
        if instanas is not None:
            pulumi.set(__self__, "instanas", instanas)
        if lightsteps is not None:
            pulumi.set(__self__, "lightsteps", lightsteps)
        if newrelics is not None:
            pulumi.set(__self__, "newrelics", newrelics)
        if opentsdbs is not None:
            pulumi.set(__self__, "opentsdbs", opentsdbs)
        if pingdoms is not None:
            pulumi.set(__self__, "pingdoms", pingdoms)
        if prometheuses is not None:
            pulumi.set(__self__, "prometheuses", prometheuses)
        if redshifts is not None:
            pulumi.set(__self__, "redshifts", redshifts)
        if splunk_observabilities is not None:
            pulumi.set(__self__, "splunk_observabilities", splunk_observabilities)
        if splunks is not None:
            pulumi.set(__self__, "splunks", splunks)
        if sumologics is not None:
            pulumi.set(__self__, "sumologics", sumologics)
        if thousandeyes is not None:
            pulumi.set(__self__, "thousandeyes", thousandeyes)

    @property
    @pulumi.getter(name="amazonPrometheuses")
    def amazon_prometheuses(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalAmazonPrometheus']]:
        return pulumi.get(self, "amazon_prometheuses")

    @property
    @pulumi.getter
    def appdynamics(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalAppdynamic']]:
        return pulumi.get(self, "appdynamics")

    @property
    @pulumi.getter
    def bigqueries(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalBigquery']]:
        return pulumi.get(self, "bigqueries")

    @property
    @pulumi.getter
    def cloudwatches(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalCloudwatch']]:
        return pulumi.get(self, "cloudwatches")

    @property
    @pulumi.getter
    def datadogs(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalDatadog']]:
        return pulumi.get(self, "datadogs")

    @property
    @pulumi.getter
    def dynatraces(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalDynatrace']]:
        return pulumi.get(self, "dynatraces")

    @property
    @pulumi.getter
    def elasticsearches(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalElasticsearch']]:
        return pulumi.get(self, "elasticsearches")

    @property
    @pulumi.getter
    def gcms(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalGcm']]:
        return pulumi.get(self, "gcms")

    @property
    @pulumi.getter(name="grafanaLokis")
    def grafana_lokis(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalGrafanaLoki']]:
        return pulumi.get(self, "grafana_lokis")

    @property
    @pulumi.getter
    def graphites(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalGraphite']]:
        return pulumi.get(self, "graphites")

    @property
    @pulumi.getter
    def influxdbs(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalInfluxdb']]:
        return pulumi.get(self, "influxdbs")

    @property
    @pulumi.getter
    def instanas(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalInstana']]:
        return pulumi.get(self, "instanas")

    @property
    @pulumi.getter
    def lightsteps(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalLightstep']]:
        return pulumi.get(self, "lightsteps")

    @property
    @pulumi.getter
    def newrelics(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalNewrelic']]:
        return pulumi.get(self, "newrelics")

    @property
    @pulumi.getter
    def opentsdbs(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalOpentsdb']]:
        return pulumi.get(self, "opentsdbs")

    @property
    @pulumi.getter
    def pingdoms(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalPingdom']]:
        return pulumi.get(self, "pingdoms")

    @property
    @pulumi.getter
    def prometheuses(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalPrometheus']]:
        return pulumi.get(self, "prometheuses")

    @property
    @pulumi.getter
    def redshifts(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalRedshift']]:
        return pulumi.get(self, "redshifts")

    @property
    @pulumi.getter(name="splunkObservabilities")
    def splunk_observabilities(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalSplunkObservability']]:
        return pulumi.get(self, "splunk_observabilities")

    @property
    @pulumi.getter
    def splunks(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalSplunk']]:
        return pulumi.get(self, "splunks")

    @property
    @pulumi.getter
    def sumologics(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalSumologic']]:
        return pulumi.get(self, "sumologics")

    @property
    @pulumi.getter
    def thousandeyes(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalThousandeye']]:
        return pulumi.get(self, "thousandeyes")


@pulumi.output_type
class SloObjectiveCountMetricTotalAmazonPrometheus(dict):
    def __init__(__self__, *,
                 promql: str):
        pulumi.set(__self__, "promql", promql)

    @property
    @pulumi.getter
    def promql(self) -> str:
        return pulumi.get(self, "promql")


@pulumi.output_type
class SloObjectiveCountMetricTotalAppdynamic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationName":
            suggest = "application_name"
        elif key == "metricPath":
            suggest = "metric_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricTotalAppdynamic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricTotalAppdynamic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricTotalAppdynamic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_name: str,
                 metric_path: str):
        pulumi.set(__self__, "application_name", application_name)
        pulumi.set(__self__, "metric_path", metric_path)

    @property
    @pulumi.getter(name="applicationName")
    def application_name(self) -> str:
        return pulumi.get(self, "application_name")

    @property
    @pulumi.getter(name="metricPath")
    def metric_path(self) -> str:
        return pulumi.get(self, "metric_path")


@pulumi.output_type
class SloObjectiveCountMetricTotalBigquery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricTotalBigquery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricTotalBigquery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricTotalBigquery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 location: str,
                 project_id: str,
                 query: str):
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def location(self) -> str:
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveCountMetricTotalCloudwatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricTotalCloudwatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricTotalCloudwatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricTotalCloudwatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region: str,
                 dimensions: Optional[Sequence['outputs.SloObjectiveCountMetricTotalCloudwatchDimension']] = None,
                 json: Optional[str] = None,
                 metric_name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 sql: Optional[str] = None,
                 stat: Optional[str] = None):
        pulumi.set(__self__, "region", region)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if json is not None:
            pulumi.set(__self__, "json", json)
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if sql is not None:
            pulumi.set(__self__, "sql", sql)
        if stat is not None:
            pulumi.set(__self__, "stat", stat)

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalCloudwatchDimension']]:
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def json(self) -> Optional[str]:
        return pulumi.get(self, "json")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[str]:
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def sql(self) -> Optional[str]:
        return pulumi.get(self, "sql")

    @property
    @pulumi.getter
    def stat(self) -> Optional[str]:
        return pulumi.get(self, "stat")


@pulumi.output_type
class SloObjectiveCountMetricTotalCloudwatchDimension(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Unique name of the resource, must conform to the naming convention from [DNS RFC1123](https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique name of the resource, must conform to the naming convention from [DNS RFC1123](https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SloObjectiveCountMetricTotalDatadog(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveCountMetricTotalDynatrace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricSelector":
            suggest = "metric_selector"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricTotalDynatrace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricTotalDynatrace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricTotalDynatrace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_selector: str):
        pulumi.set(__self__, "metric_selector", metric_selector)

    @property
    @pulumi.getter(name="metricSelector")
    def metric_selector(self) -> str:
        return pulumi.get(self, "metric_selector")


@pulumi.output_type
class SloObjectiveCountMetricTotalElasticsearch(dict):
    def __init__(__self__, *,
                 index: str,
                 query: str):
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveCountMetricTotalGcm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricTotalGcm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricTotalGcm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricTotalGcm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 project_id: str,
                 query: str):
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveCountMetricTotalGrafanaLoki(dict):
    def __init__(__self__, *,
                 logql: str):
        pulumi.set(__self__, "logql", logql)

    @property
    @pulumi.getter
    def logql(self) -> str:
        return pulumi.get(self, "logql")


@pulumi.output_type
class SloObjectiveCountMetricTotalGraphite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricPath":
            suggest = "metric_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricTotalGraphite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricTotalGraphite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricTotalGraphite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_path: str):
        pulumi.set(__self__, "metric_path", metric_path)

    @property
    @pulumi.getter(name="metricPath")
    def metric_path(self) -> str:
        return pulumi.get(self, "metric_path")


@pulumi.output_type
class SloObjectiveCountMetricTotalInfluxdb(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveCountMetricTotalInstana(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricType":
            suggest = "metric_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricTotalInstana. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricTotalInstana.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricTotalInstana.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_type: str,
                 applications: Optional[Sequence['outputs.SloObjectiveCountMetricTotalInstanaApplication']] = None,
                 infrastructures: Optional[Sequence['outputs.SloObjectiveCountMetricTotalInstanaInfrastructure']] = None):
        pulumi.set(__self__, "metric_type", metric_type)
        if applications is not None:
            pulumi.set(__self__, "applications", applications)
        if infrastructures is not None:
            pulumi.set(__self__, "infrastructures", infrastructures)

    @property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> str:
        return pulumi.get(self, "metric_type")

    @property
    @pulumi.getter
    def applications(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalInstanaApplication']]:
        return pulumi.get(self, "applications")

    @property
    @pulumi.getter
    def infrastructures(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalInstanaInfrastructure']]:
        return pulumi.get(self, "infrastructures")


@pulumi.output_type
class SloObjectiveCountMetricTotalInstanaApplication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiQuery":
            suggest = "api_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "metricId":
            suggest = "metric_id"
        elif key == "includeInternal":
            suggest = "include_internal"
        elif key == "includeSynthetic":
            suggest = "include_synthetic"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricTotalInstanaApplication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricTotalInstanaApplication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricTotalInstanaApplication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation: str,
                 api_query: str,
                 group_bies: Sequence['outputs.SloObjectiveCountMetricTotalInstanaApplicationGroupBy'],
                 metric_id: str,
                 include_internal: Optional[bool] = None,
                 include_synthetic: Optional[bool] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "api_query", api_query)
        pulumi.set(__self__, "group_bies", group_bies)
        pulumi.set(__self__, "metric_id", metric_id)
        if include_internal is not None:
            pulumi.set(__self__, "include_internal", include_internal)
        if include_synthetic is not None:
            pulumi.set(__self__, "include_synthetic", include_synthetic)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="apiQuery")
    def api_query(self) -> str:
        return pulumi.get(self, "api_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Sequence['outputs.SloObjectiveCountMetricTotalInstanaApplicationGroupBy']:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="metricId")
    def metric_id(self) -> str:
        return pulumi.get(self, "metric_id")

    @property
    @pulumi.getter(name="includeInternal")
    def include_internal(self) -> Optional[bool]:
        return pulumi.get(self, "include_internal")

    @property
    @pulumi.getter(name="includeSynthetic")
    def include_synthetic(self) -> Optional[bool]:
        return pulumi.get(self, "include_synthetic")


@pulumi.output_type
class SloObjectiveCountMetricTotalInstanaApplicationGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagEntity":
            suggest = "tag_entity"
        elif key == "tagSecondLevelKey":
            suggest = "tag_second_level_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricTotalInstanaApplicationGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricTotalInstanaApplicationGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricTotalInstanaApplicationGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tag: str,
                 tag_entity: str,
                 tag_second_level_key: Optional[str] = None):
        pulumi.set(__self__, "tag", tag)
        pulumi.set(__self__, "tag_entity", tag_entity)
        if tag_second_level_key is not None:
            pulumi.set(__self__, "tag_second_level_key", tag_second_level_key)

    @property
    @pulumi.getter
    def tag(self) -> str:
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter(name="tagEntity")
    def tag_entity(self) -> str:
        return pulumi.get(self, "tag_entity")

    @property
    @pulumi.getter(name="tagSecondLevelKey")
    def tag_second_level_key(self) -> Optional[str]:
        return pulumi.get(self, "tag_second_level_key")


@pulumi.output_type
class SloObjectiveCountMetricTotalInstanaInfrastructure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricId":
            suggest = "metric_id"
        elif key == "metricRetrievalMethod":
            suggest = "metric_retrieval_method"
        elif key == "pluginId":
            suggest = "plugin_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricTotalInstanaInfrastructure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricTotalInstanaInfrastructure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricTotalInstanaInfrastructure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_id: str,
                 metric_retrieval_method: str,
                 plugin_id: str,
                 query: Optional[str] = None,
                 snapshot_id: Optional[str] = None):
        pulumi.set(__self__, "metric_id", metric_id)
        pulumi.set(__self__, "metric_retrieval_method", metric_retrieval_method)
        pulumi.set(__self__, "plugin_id", plugin_id)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)

    @property
    @pulumi.getter(name="metricId")
    def metric_id(self) -> str:
        return pulumi.get(self, "metric_id")

    @property
    @pulumi.getter(name="metricRetrievalMethod")
    def metric_retrieval_method(self) -> str:
        return pulumi.get(self, "metric_retrieval_method")

    @property
    @pulumi.getter(name="pluginId")
    def plugin_id(self) -> str:
        return pulumi.get(self, "plugin_id")

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        return pulumi.get(self, "snapshot_id")


@pulumi.output_type
class SloObjectiveCountMetricTotalLightstep(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeOfData":
            suggest = "type_of_data"
        elif key == "streamId":
            suggest = "stream_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricTotalLightstep. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricTotalLightstep.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricTotalLightstep.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type_of_data: str,
                 percentile: Optional[float] = None,
                 stream_id: Optional[str] = None,
                 uql: Optional[str] = None):
        pulumi.set(__self__, "type_of_data", type_of_data)
        if percentile is not None:
            pulumi.set(__self__, "percentile", percentile)
        if stream_id is not None:
            pulumi.set(__self__, "stream_id", stream_id)
        if uql is not None:
            pulumi.set(__self__, "uql", uql)

    @property
    @pulumi.getter(name="typeOfData")
    def type_of_data(self) -> str:
        return pulumi.get(self, "type_of_data")

    @property
    @pulumi.getter
    def percentile(self) -> Optional[float]:
        return pulumi.get(self, "percentile")

    @property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> Optional[str]:
        return pulumi.get(self, "stream_id")

    @property
    @pulumi.getter
    def uql(self) -> Optional[str]:
        return pulumi.get(self, "uql")


@pulumi.output_type
class SloObjectiveCountMetricTotalNewrelic(dict):
    def __init__(__self__, *,
                 nrql: str):
        pulumi.set(__self__, "nrql", nrql)

    @property
    @pulumi.getter
    def nrql(self) -> str:
        return pulumi.get(self, "nrql")


@pulumi.output_type
class SloObjectiveCountMetricTotalOpentsdb(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveCountMetricTotalPingdom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkId":
            suggest = "check_id"
        elif key == "checkType":
            suggest = "check_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricTotalPingdom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricTotalPingdom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricTotalPingdom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check_id: str,
                 check_type: Optional[str] = None,
                 status: Optional[str] = None):
        pulumi.set(__self__, "check_id", check_id)
        if check_type is not None:
            pulumi.set(__self__, "check_type", check_type)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="checkId")
    def check_id(self) -> str:
        return pulumi.get(self, "check_id")

    @property
    @pulumi.getter(name="checkType")
    def check_type(self) -> Optional[str]:
        return pulumi.get(self, "check_type")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        return pulumi.get(self, "status")


@pulumi.output_type
class SloObjectiveCountMetricTotalPrometheus(dict):
    def __init__(__self__, *,
                 promql: str):
        pulumi.set(__self__, "promql", promql)

    @property
    @pulumi.getter
    def promql(self) -> str:
        return pulumi.get(self, "promql")


@pulumi.output_type
class SloObjectiveCountMetricTotalRedshift(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterId":
            suggest = "cluster_id"
        elif key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricTotalRedshift. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricTotalRedshift.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricTotalRedshift.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_id: str,
                 database_name: str,
                 query: str,
                 region: str):
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> str:
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")


@pulumi.output_type
class SloObjectiveCountMetricTotalSplunk(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveCountMetricTotalSplunkObservability(dict):
    def __init__(__self__, *,
                 program: str):
        pulumi.set(__self__, "program", program)

    @property
    @pulumi.getter
    def program(self) -> str:
        return pulumi.get(self, "program")


@pulumi.output_type
class SloObjectiveCountMetricTotalSumologic(dict):
    def __init__(__self__, *,
                 query: str,
                 type: str,
                 quantization: Optional[str] = None,
                 rollup: Optional[str] = None):
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "type", type)
        if quantization is not None:
            pulumi.set(__self__, "quantization", quantization)
        if rollup is not None:
            pulumi.set(__self__, "rollup", rollup)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def quantization(self) -> Optional[str]:
        return pulumi.get(self, "quantization")

    @property
    @pulumi.getter
    def rollup(self) -> Optional[str]:
        return pulumi.get(self, "rollup")


@pulumi.output_type
class SloObjectiveCountMetricTotalThousandeye(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "testId":
            suggest = "test_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricTotalThousandeye. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricTotalThousandeye.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricTotalThousandeye.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 test_id: int):
        pulumi.set(__self__, "test_id", test_id)

    @property
    @pulumi.getter(name="testId")
    def test_id(self) -> int:
        return pulumi.get(self, "test_id")


@pulumi.output_type
class SloObjectiveRawMetric(dict):
    def __init__(__self__, *,
                 queries: Optional[Sequence['outputs.SloObjectiveRawMetricQuery']] = None):
        if queries is not None:
            pulumi.set(__self__, "queries", queries)

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQuery']]:
        return pulumi.get(self, "queries")


@pulumi.output_type
class SloObjectiveRawMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "amazonPrometheuses":
            suggest = "amazon_prometheuses"
        elif key == "grafanaLokis":
            suggest = "grafana_lokis"
        elif key == "splunkObservabilities":
            suggest = "splunk_observabilities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveRawMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveRawMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveRawMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amazon_prometheuses: Optional[Sequence['outputs.SloObjectiveRawMetricQueryAmazonPrometheus']] = None,
                 appdynamics: Optional[Sequence['outputs.SloObjectiveRawMetricQueryAppdynamic']] = None,
                 bigqueries: Optional[Sequence['outputs.SloObjectiveRawMetricQueryBigquery']] = None,
                 cloudwatches: Optional[Sequence['outputs.SloObjectiveRawMetricQueryCloudwatch']] = None,
                 datadogs: Optional[Sequence['outputs.SloObjectiveRawMetricQueryDatadog']] = None,
                 dynatraces: Optional[Sequence['outputs.SloObjectiveRawMetricQueryDynatrace']] = None,
                 elasticsearches: Optional[Sequence['outputs.SloObjectiveRawMetricQueryElasticsearch']] = None,
                 gcms: Optional[Sequence['outputs.SloObjectiveRawMetricQueryGcm']] = None,
                 grafana_lokis: Optional[Sequence['outputs.SloObjectiveRawMetricQueryGrafanaLoki']] = None,
                 graphites: Optional[Sequence['outputs.SloObjectiveRawMetricQueryGraphite']] = None,
                 influxdbs: Optional[Sequence['outputs.SloObjectiveRawMetricQueryInfluxdb']] = None,
                 instanas: Optional[Sequence['outputs.SloObjectiveRawMetricQueryInstana']] = None,
                 lightsteps: Optional[Sequence['outputs.SloObjectiveRawMetricQueryLightstep']] = None,
                 newrelics: Optional[Sequence['outputs.SloObjectiveRawMetricQueryNewrelic']] = None,
                 opentsdbs: Optional[Sequence['outputs.SloObjectiveRawMetricQueryOpentsdb']] = None,
                 pingdoms: Optional[Sequence['outputs.SloObjectiveRawMetricQueryPingdom']] = None,
                 prometheuses: Optional[Sequence['outputs.SloObjectiveRawMetricQueryPrometheus']] = None,
                 redshifts: Optional[Sequence['outputs.SloObjectiveRawMetricQueryRedshift']] = None,
                 splunk_observabilities: Optional[Sequence['outputs.SloObjectiveRawMetricQuerySplunkObservability']] = None,
                 splunks: Optional[Sequence['outputs.SloObjectiveRawMetricQuerySplunk']] = None,
                 sumologics: Optional[Sequence['outputs.SloObjectiveRawMetricQuerySumologic']] = None,
                 thousandeyes: Optional[Sequence['outputs.SloObjectiveRawMetricQueryThousandeye']] = None):
        if amazon_prometheuses is not None:
            pulumi.set(__self__, "amazon_prometheuses", amazon_prometheuses)
        if appdynamics is not None:
            pulumi.set(__self__, "appdynamics", appdynamics)
        if bigqueries is not None:
            pulumi.set(__self__, "bigqueries", bigqueries)
        if cloudwatches is not None:
            pulumi.set(__self__, "cloudwatches", cloudwatches)
        if datadogs is not None:
            pulumi.set(__self__, "datadogs", datadogs)
        if dynatraces is not None:
            pulumi.set(__self__, "dynatraces", dynatraces)
        if elasticsearches is not None:
            pulumi.set(__self__, "elasticsearches", elasticsearches)
        if gcms is not None:
            pulumi.set(__self__, "gcms", gcms)
        if grafana_lokis is not None:
            pulumi.set(__self__, "grafana_lokis", grafana_lokis)
        if graphites is not None:
            pulumi.set(__self__, "graphites", graphites)
        if influxdbs is not None:
            pulumi.set(__self__, "influxdbs", influxdbs)
        if instanas is not None:
            pulumi.set(__self__, "instanas", instanas)
        if lightsteps is not None:
            pulumi.set(__self__, "lightsteps", lightsteps)
        if newrelics is not None:
            pulumi.set(__self__, "newrelics", newrelics)
        if opentsdbs is not None:
            pulumi.set(__self__, "opentsdbs", opentsdbs)
        if pingdoms is not None:
            pulumi.set(__self__, "pingdoms", pingdoms)
        if prometheuses is not None:
            pulumi.set(__self__, "prometheuses", prometheuses)
        if redshifts is not None:
            pulumi.set(__self__, "redshifts", redshifts)
        if splunk_observabilities is not None:
            pulumi.set(__self__, "splunk_observabilities", splunk_observabilities)
        if splunks is not None:
            pulumi.set(__self__, "splunks", splunks)
        if sumologics is not None:
            pulumi.set(__self__, "sumologics", sumologics)
        if thousandeyes is not None:
            pulumi.set(__self__, "thousandeyes", thousandeyes)

    @property
    @pulumi.getter(name="amazonPrometheuses")
    def amazon_prometheuses(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryAmazonPrometheus']]:
        return pulumi.get(self, "amazon_prometheuses")

    @property
    @pulumi.getter
    def appdynamics(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryAppdynamic']]:
        return pulumi.get(self, "appdynamics")

    @property
    @pulumi.getter
    def bigqueries(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryBigquery']]:
        return pulumi.get(self, "bigqueries")

    @property
    @pulumi.getter
    def cloudwatches(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryCloudwatch']]:
        return pulumi.get(self, "cloudwatches")

    @property
    @pulumi.getter
    def datadogs(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryDatadog']]:
        return pulumi.get(self, "datadogs")

    @property
    @pulumi.getter
    def dynatraces(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryDynatrace']]:
        return pulumi.get(self, "dynatraces")

    @property
    @pulumi.getter
    def elasticsearches(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryElasticsearch']]:
        return pulumi.get(self, "elasticsearches")

    @property
    @pulumi.getter
    def gcms(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryGcm']]:
        return pulumi.get(self, "gcms")

    @property
    @pulumi.getter(name="grafanaLokis")
    def grafana_lokis(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryGrafanaLoki']]:
        return pulumi.get(self, "grafana_lokis")

    @property
    @pulumi.getter
    def graphites(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryGraphite']]:
        return pulumi.get(self, "graphites")

    @property
    @pulumi.getter
    def influxdbs(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryInfluxdb']]:
        return pulumi.get(self, "influxdbs")

    @property
    @pulumi.getter
    def instanas(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryInstana']]:
        return pulumi.get(self, "instanas")

    @property
    @pulumi.getter
    def lightsteps(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryLightstep']]:
        return pulumi.get(self, "lightsteps")

    @property
    @pulumi.getter
    def newrelics(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryNewrelic']]:
        return pulumi.get(self, "newrelics")

    @property
    @pulumi.getter
    def opentsdbs(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryOpentsdb']]:
        return pulumi.get(self, "opentsdbs")

    @property
    @pulumi.getter
    def pingdoms(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryPingdom']]:
        return pulumi.get(self, "pingdoms")

    @property
    @pulumi.getter
    def prometheuses(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryPrometheus']]:
        return pulumi.get(self, "prometheuses")

    @property
    @pulumi.getter
    def redshifts(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryRedshift']]:
        return pulumi.get(self, "redshifts")

    @property
    @pulumi.getter(name="splunkObservabilities")
    def splunk_observabilities(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQuerySplunkObservability']]:
        return pulumi.get(self, "splunk_observabilities")

    @property
    @pulumi.getter
    def splunks(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQuerySplunk']]:
        return pulumi.get(self, "splunks")

    @property
    @pulumi.getter
    def sumologics(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQuerySumologic']]:
        return pulumi.get(self, "sumologics")

    @property
    @pulumi.getter
    def thousandeyes(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryThousandeye']]:
        return pulumi.get(self, "thousandeyes")


@pulumi.output_type
class SloObjectiveRawMetricQueryAmazonPrometheus(dict):
    def __init__(__self__, *,
                 promql: str):
        pulumi.set(__self__, "promql", promql)

    @property
    @pulumi.getter
    def promql(self) -> str:
        return pulumi.get(self, "promql")


@pulumi.output_type
class SloObjectiveRawMetricQueryAppdynamic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationName":
            suggest = "application_name"
        elif key == "metricPath":
            suggest = "metric_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveRawMetricQueryAppdynamic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveRawMetricQueryAppdynamic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveRawMetricQueryAppdynamic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_name: str,
                 metric_path: str):
        pulumi.set(__self__, "application_name", application_name)
        pulumi.set(__self__, "metric_path", metric_path)

    @property
    @pulumi.getter(name="applicationName")
    def application_name(self) -> str:
        return pulumi.get(self, "application_name")

    @property
    @pulumi.getter(name="metricPath")
    def metric_path(self) -> str:
        return pulumi.get(self, "metric_path")


@pulumi.output_type
class SloObjectiveRawMetricQueryBigquery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveRawMetricQueryBigquery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveRawMetricQueryBigquery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveRawMetricQueryBigquery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 location: str,
                 project_id: str,
                 query: str):
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def location(self) -> str:
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveRawMetricQueryCloudwatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveRawMetricQueryCloudwatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveRawMetricQueryCloudwatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveRawMetricQueryCloudwatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region: str,
                 dimensions: Optional[Sequence['outputs.SloObjectiveRawMetricQueryCloudwatchDimension']] = None,
                 json: Optional[str] = None,
                 metric_name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 sql: Optional[str] = None,
                 stat: Optional[str] = None):
        pulumi.set(__self__, "region", region)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if json is not None:
            pulumi.set(__self__, "json", json)
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if sql is not None:
            pulumi.set(__self__, "sql", sql)
        if stat is not None:
            pulumi.set(__self__, "stat", stat)

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryCloudwatchDimension']]:
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def json(self) -> Optional[str]:
        return pulumi.get(self, "json")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[str]:
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def sql(self) -> Optional[str]:
        return pulumi.get(self, "sql")

    @property
    @pulumi.getter
    def stat(self) -> Optional[str]:
        return pulumi.get(self, "stat")


@pulumi.output_type
class SloObjectiveRawMetricQueryCloudwatchDimension(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Unique name of the resource, must conform to the naming convention from [DNS RFC1123](https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique name of the resource, must conform to the naming convention from [DNS RFC1123](https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SloObjectiveRawMetricQueryDatadog(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveRawMetricQueryDynatrace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricSelector":
            suggest = "metric_selector"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveRawMetricQueryDynatrace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveRawMetricQueryDynatrace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveRawMetricQueryDynatrace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_selector: str):
        pulumi.set(__self__, "metric_selector", metric_selector)

    @property
    @pulumi.getter(name="metricSelector")
    def metric_selector(self) -> str:
        return pulumi.get(self, "metric_selector")


@pulumi.output_type
class SloObjectiveRawMetricQueryElasticsearch(dict):
    def __init__(__self__, *,
                 index: str,
                 query: str):
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveRawMetricQueryGcm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveRawMetricQueryGcm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveRawMetricQueryGcm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveRawMetricQueryGcm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 project_id: str,
                 query: str):
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveRawMetricQueryGrafanaLoki(dict):
    def __init__(__self__, *,
                 logql: str):
        pulumi.set(__self__, "logql", logql)

    @property
    @pulumi.getter
    def logql(self) -> str:
        return pulumi.get(self, "logql")


@pulumi.output_type
class SloObjectiveRawMetricQueryGraphite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricPath":
            suggest = "metric_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveRawMetricQueryGraphite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveRawMetricQueryGraphite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveRawMetricQueryGraphite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_path: str):
        pulumi.set(__self__, "metric_path", metric_path)

    @property
    @pulumi.getter(name="metricPath")
    def metric_path(self) -> str:
        return pulumi.get(self, "metric_path")


@pulumi.output_type
class SloObjectiveRawMetricQueryInfluxdb(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveRawMetricQueryInstana(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricType":
            suggest = "metric_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveRawMetricQueryInstana. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveRawMetricQueryInstana.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveRawMetricQueryInstana.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_type: str,
                 applications: Optional[Sequence['outputs.SloObjectiveRawMetricQueryInstanaApplication']] = None,
                 infrastructures: Optional[Sequence['outputs.SloObjectiveRawMetricQueryInstanaInfrastructure']] = None):
        pulumi.set(__self__, "metric_type", metric_type)
        if applications is not None:
            pulumi.set(__self__, "applications", applications)
        if infrastructures is not None:
            pulumi.set(__self__, "infrastructures", infrastructures)

    @property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> str:
        return pulumi.get(self, "metric_type")

    @property
    @pulumi.getter
    def applications(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryInstanaApplication']]:
        return pulumi.get(self, "applications")

    @property
    @pulumi.getter
    def infrastructures(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryInstanaInfrastructure']]:
        return pulumi.get(self, "infrastructures")


@pulumi.output_type
class SloObjectiveRawMetricQueryInstanaApplication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiQuery":
            suggest = "api_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "metricId":
            suggest = "metric_id"
        elif key == "includeInternal":
            suggest = "include_internal"
        elif key == "includeSynthetic":
            suggest = "include_synthetic"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveRawMetricQueryInstanaApplication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveRawMetricQueryInstanaApplication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveRawMetricQueryInstanaApplication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation: str,
                 api_query: str,
                 group_bies: Sequence['outputs.SloObjectiveRawMetricQueryInstanaApplicationGroupBy'],
                 metric_id: str,
                 include_internal: Optional[bool] = None,
                 include_synthetic: Optional[bool] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "api_query", api_query)
        pulumi.set(__self__, "group_bies", group_bies)
        pulumi.set(__self__, "metric_id", metric_id)
        if include_internal is not None:
            pulumi.set(__self__, "include_internal", include_internal)
        if include_synthetic is not None:
            pulumi.set(__self__, "include_synthetic", include_synthetic)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="apiQuery")
    def api_query(self) -> str:
        return pulumi.get(self, "api_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Sequence['outputs.SloObjectiveRawMetricQueryInstanaApplicationGroupBy']:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="metricId")
    def metric_id(self) -> str:
        return pulumi.get(self, "metric_id")

    @property
    @pulumi.getter(name="includeInternal")
    def include_internal(self) -> Optional[bool]:
        return pulumi.get(self, "include_internal")

    @property
    @pulumi.getter(name="includeSynthetic")
    def include_synthetic(self) -> Optional[bool]:
        return pulumi.get(self, "include_synthetic")


@pulumi.output_type
class SloObjectiveRawMetricQueryInstanaApplicationGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagEntity":
            suggest = "tag_entity"
        elif key == "tagSecondLevelKey":
            suggest = "tag_second_level_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveRawMetricQueryInstanaApplicationGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveRawMetricQueryInstanaApplicationGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveRawMetricQueryInstanaApplicationGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tag: str,
                 tag_entity: str,
                 tag_second_level_key: Optional[str] = None):
        pulumi.set(__self__, "tag", tag)
        pulumi.set(__self__, "tag_entity", tag_entity)
        if tag_second_level_key is not None:
            pulumi.set(__self__, "tag_second_level_key", tag_second_level_key)

    @property
    @pulumi.getter
    def tag(self) -> str:
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter(name="tagEntity")
    def tag_entity(self) -> str:
        return pulumi.get(self, "tag_entity")

    @property
    @pulumi.getter(name="tagSecondLevelKey")
    def tag_second_level_key(self) -> Optional[str]:
        return pulumi.get(self, "tag_second_level_key")


@pulumi.output_type
class SloObjectiveRawMetricQueryInstanaInfrastructure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricId":
            suggest = "metric_id"
        elif key == "metricRetrievalMethod":
            suggest = "metric_retrieval_method"
        elif key == "pluginId":
            suggest = "plugin_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveRawMetricQueryInstanaInfrastructure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveRawMetricQueryInstanaInfrastructure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveRawMetricQueryInstanaInfrastructure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_id: str,
                 metric_retrieval_method: str,
                 plugin_id: str,
                 query: Optional[str] = None,
                 snapshot_id: Optional[str] = None):
        pulumi.set(__self__, "metric_id", metric_id)
        pulumi.set(__self__, "metric_retrieval_method", metric_retrieval_method)
        pulumi.set(__self__, "plugin_id", plugin_id)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)

    @property
    @pulumi.getter(name="metricId")
    def metric_id(self) -> str:
        return pulumi.get(self, "metric_id")

    @property
    @pulumi.getter(name="metricRetrievalMethod")
    def metric_retrieval_method(self) -> str:
        return pulumi.get(self, "metric_retrieval_method")

    @property
    @pulumi.getter(name="pluginId")
    def plugin_id(self) -> str:
        return pulumi.get(self, "plugin_id")

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        return pulumi.get(self, "snapshot_id")


@pulumi.output_type
class SloObjectiveRawMetricQueryLightstep(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeOfData":
            suggest = "type_of_data"
        elif key == "streamId":
            suggest = "stream_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveRawMetricQueryLightstep. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveRawMetricQueryLightstep.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveRawMetricQueryLightstep.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type_of_data: str,
                 percentile: Optional[float] = None,
                 stream_id: Optional[str] = None,
                 uql: Optional[str] = None):
        pulumi.set(__self__, "type_of_data", type_of_data)
        if percentile is not None:
            pulumi.set(__self__, "percentile", percentile)
        if stream_id is not None:
            pulumi.set(__self__, "stream_id", stream_id)
        if uql is not None:
            pulumi.set(__self__, "uql", uql)

    @property
    @pulumi.getter(name="typeOfData")
    def type_of_data(self) -> str:
        return pulumi.get(self, "type_of_data")

    @property
    @pulumi.getter
    def percentile(self) -> Optional[float]:
        return pulumi.get(self, "percentile")

    @property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> Optional[str]:
        return pulumi.get(self, "stream_id")

    @property
    @pulumi.getter
    def uql(self) -> Optional[str]:
        return pulumi.get(self, "uql")


@pulumi.output_type
class SloObjectiveRawMetricQueryNewrelic(dict):
    def __init__(__self__, *,
                 nrql: str):
        pulumi.set(__self__, "nrql", nrql)

    @property
    @pulumi.getter
    def nrql(self) -> str:
        return pulumi.get(self, "nrql")


@pulumi.output_type
class SloObjectiveRawMetricQueryOpentsdb(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveRawMetricQueryPingdom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkId":
            suggest = "check_id"
        elif key == "checkType":
            suggest = "check_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveRawMetricQueryPingdom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveRawMetricQueryPingdom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveRawMetricQueryPingdom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check_id: str,
                 check_type: Optional[str] = None,
                 status: Optional[str] = None):
        pulumi.set(__self__, "check_id", check_id)
        if check_type is not None:
            pulumi.set(__self__, "check_type", check_type)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="checkId")
    def check_id(self) -> str:
        return pulumi.get(self, "check_id")

    @property
    @pulumi.getter(name="checkType")
    def check_type(self) -> Optional[str]:
        return pulumi.get(self, "check_type")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        return pulumi.get(self, "status")


@pulumi.output_type
class SloObjectiveRawMetricQueryPrometheus(dict):
    def __init__(__self__, *,
                 promql: str):
        pulumi.set(__self__, "promql", promql)

    @property
    @pulumi.getter
    def promql(self) -> str:
        return pulumi.get(self, "promql")


@pulumi.output_type
class SloObjectiveRawMetricQueryRedshift(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterId":
            suggest = "cluster_id"
        elif key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveRawMetricQueryRedshift. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveRawMetricQueryRedshift.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveRawMetricQueryRedshift.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_id: str,
                 database_name: str,
                 query: str,
                 region: str):
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> str:
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")


@pulumi.output_type
class SloObjectiveRawMetricQuerySplunk(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveRawMetricQuerySplunkObservability(dict):
    def __init__(__self__, *,
                 program: str):
        pulumi.set(__self__, "program", program)

    @property
    @pulumi.getter
    def program(self) -> str:
        return pulumi.get(self, "program")


@pulumi.output_type
class SloObjectiveRawMetricQuerySumologic(dict):
    def __init__(__self__, *,
                 query: str,
                 type: str,
                 quantization: Optional[str] = None,
                 rollup: Optional[str] = None):
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "type", type)
        if quantization is not None:
            pulumi.set(__self__, "quantization", quantization)
        if rollup is not None:
            pulumi.set(__self__, "rollup", rollup)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def quantization(self) -> Optional[str]:
        return pulumi.get(self, "quantization")

    @property
    @pulumi.getter
    def rollup(self) -> Optional[str]:
        return pulumi.get(self, "rollup")


@pulumi.output_type
class SloObjectiveRawMetricQueryThousandeye(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "testId":
            suggest = "test_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveRawMetricQueryThousandeye. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveRawMetricQueryThousandeye.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveRawMetricQueryThousandeye.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 test_id: int):
        pulumi.set(__self__, "test_id", test_id)

    @property
    @pulumi.getter(name="testId")
    def test_id(self) -> int:
        return pulumi.get(self, "test_id")


@pulumi.output_type
class SloTimeWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isRolling":
            suggest = "is_rolling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloTimeWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloTimeWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloTimeWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: int,
                 unit: str,
                 calendars: Optional[Sequence['outputs.SloTimeWindowCalendar']] = None,
                 is_rolling: Optional[bool] = None,
                 period: Optional[Mapping[str, str]] = None):
        """
        :param int count: Count of the time unit
        :param str unit: Unit of time
        :param Sequence['SloTimeWindowCalendarArgs'] calendars: Alert Policies attached to SLO
        :param bool is_rolling: Is the window moving or not
        :param Mapping[str, str] period: Period between start time and added count
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "unit", unit)
        if calendars is not None:
            pulumi.set(__self__, "calendars", calendars)
        if is_rolling is not None:
            pulumi.set(__self__, "is_rolling", is_rolling)
        if period is not None:
            pulumi.set(__self__, "period", period)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        Count of the time unit
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Unit of time
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def calendars(self) -> Optional[Sequence['outputs.SloTimeWindowCalendar']]:
        """
        Alert Policies attached to SLO
        """
        return pulumi.get(self, "calendars")

    @property
    @pulumi.getter(name="isRolling")
    def is_rolling(self) -> Optional[bool]:
        """
        Is the window moving or not
        """
        return pulumi.get(self, "is_rolling")

    @property
    @pulumi.getter
    def period(self) -> Optional[Mapping[str, str]]:
        """
        Period between start time and added count
        """
        return pulumi.get(self, "period")


@pulumi.output_type
class SloTimeWindowCalendar(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startTime":
            suggest = "start_time"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloTimeWindowCalendar. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloTimeWindowCalendar.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloTimeWindowCalendar.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 start_time: str,
                 time_zone: str):
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> str:
        return pulumi.get(self, "time_zone")



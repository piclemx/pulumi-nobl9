# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'AgentAmazonPrometheusConfig',
    'AgentAppdynamicsConfig',
    'AgentAzureMonitorConfig',
    'AgentBigqueryConfig',
    'AgentCloudwatchConfig',
    'AgentDatadogConfig',
    'AgentDynatraceConfig',
    'AgentElasticsearchConfig',
    'AgentGcmConfig',
    'AgentGrafanaLokiConfig',
    'AgentGraphiteConfig',
    'AgentHistoricalDataRetrieval',
    'AgentHistoricalDataRetrievalDefaultDuration',
    'AgentHistoricalDataRetrievalMaxDuration',
    'AgentHoneycombConfig',
    'AgentInfluxdbConfig',
    'AgentInstanaConfig',
    'AgentLightstepConfig',
    'AgentNewrelicConfig',
    'AgentOpentsdbConfig',
    'AgentPingdomConfig',
    'AgentPrometheusConfig',
    'AgentQueryDelay',
    'AgentRedshiftConfig',
    'AgentSplunkConfig',
    'AgentSplunkObservabilityConfig',
    'AgentSumologicConfig',
    'AgentThousandeyesConfig',
    'AlertMethodPagerdutySendResolution',
    'AlertPolicyAlertMethod',
    'AlertPolicyCondition',
    'DirectAppdynamicsHistoricalDataRetrieval',
    'DirectAppdynamicsHistoricalDataRetrievalDefaultDuration',
    'DirectAppdynamicsHistoricalDataRetrievalMaxDuration',
    'DirectAppdynamicsQueryDelay',
    'DirectAzureMonitorHistoricalDataRetrieval',
    'DirectAzureMonitorHistoricalDataRetrievalDefaultDuration',
    'DirectAzureMonitorHistoricalDataRetrievalMaxDuration',
    'DirectAzureMonitorQueryDelay',
    'DirectBigqueryQueryDelay',
    'DirectCloudwatchHistoricalDataRetrieval',
    'DirectCloudwatchHistoricalDataRetrievalDefaultDuration',
    'DirectCloudwatchHistoricalDataRetrievalMaxDuration',
    'DirectCloudwatchQueryDelay',
    'DirectDatadogHistoricalDataRetrieval',
    'DirectDatadogHistoricalDataRetrievalDefaultDuration',
    'DirectDatadogHistoricalDataRetrievalMaxDuration',
    'DirectDatadogQueryDelay',
    'DirectDynatraceHistoricalDataRetrieval',
    'DirectDynatraceHistoricalDataRetrievalDefaultDuration',
    'DirectDynatraceHistoricalDataRetrievalMaxDuration',
    'DirectDynatraceQueryDelay',
    'DirectGcmQueryDelay',
    'DirectHoneycombHistoricalDataRetrieval',
    'DirectHoneycombHistoricalDataRetrievalDefaultDuration',
    'DirectHoneycombHistoricalDataRetrievalMaxDuration',
    'DirectHoneycombQueryDelay',
    'DirectInfluxdbQueryDelay',
    'DirectInstanaQueryDelay',
    'DirectLightstepHistoricalDataRetrieval',
    'DirectLightstepHistoricalDataRetrievalDefaultDuration',
    'DirectLightstepHistoricalDataRetrievalMaxDuration',
    'DirectLightstepQueryDelay',
    'DirectNewrelicHistoricalDataRetrieval',
    'DirectNewrelicHistoricalDataRetrievalDefaultDuration',
    'DirectNewrelicHistoricalDataRetrievalMaxDuration',
    'DirectNewrelicQueryDelay',
    'DirectPingdomQueryDelay',
    'DirectRedshiftQueryDelay',
    'DirectSplunkHistoricalDataRetrieval',
    'DirectSplunkHistoricalDataRetrievalDefaultDuration',
    'DirectSplunkHistoricalDataRetrievalMaxDuration',
    'DirectSplunkObservabilityQueryDelay',
    'DirectSplunkQueryDelay',
    'DirectSumologicQueryDelay',
    'DirectThousandeyesQueryDelay',
    'ProjectLabel',
    'ServiceLabel',
    'SloAnomalyConfig',
    'SloAnomalyConfigNoData',
    'SloAnomalyConfigNoDataAlertMethod',
    'SloAttachment',
    'SloComposite',
    'SloCompositeBurnRateCondition',
    'SloIndicator',
    'SloLabel',
    'SloObjective',
    'SloObjectiveCountMetric',
    'SloObjectiveCountMetricBad',
    'SloObjectiveCountMetricBadAmazonPrometheus',
    'SloObjectiveCountMetricBadAppdynamic',
    'SloObjectiveCountMetricBadAzureMonitor',
    'SloObjectiveCountMetricBadAzureMonitorDimension',
    'SloObjectiveCountMetricBadAzureMonitorWorkspace',
    'SloObjectiveCountMetricBadBigquery',
    'SloObjectiveCountMetricBadCloudwatch',
    'SloObjectiveCountMetricBadCloudwatchDimension',
    'SloObjectiveCountMetricBadDatadog',
    'SloObjectiveCountMetricBadDynatrace',
    'SloObjectiveCountMetricBadElasticsearch',
    'SloObjectiveCountMetricBadGcm',
    'SloObjectiveCountMetricBadGrafanaLoki',
    'SloObjectiveCountMetricBadGraphite',
    'SloObjectiveCountMetricBadHoneycomb',
    'SloObjectiveCountMetricBadInfluxdb',
    'SloObjectiveCountMetricBadInstana',
    'SloObjectiveCountMetricBadInstanaApplication',
    'SloObjectiveCountMetricBadInstanaApplicationGroupBy',
    'SloObjectiveCountMetricBadInstanaInfrastructure',
    'SloObjectiveCountMetricBadLightstep',
    'SloObjectiveCountMetricBadNewrelic',
    'SloObjectiveCountMetricBadOpentsdb',
    'SloObjectiveCountMetricBadPingdom',
    'SloObjectiveCountMetricBadPrometheus',
    'SloObjectiveCountMetricBadRedshift',
    'SloObjectiveCountMetricBadSplunk',
    'SloObjectiveCountMetricBadSplunkObservability',
    'SloObjectiveCountMetricBadSumologic',
    'SloObjectiveCountMetricBadThousandeye',
    'SloObjectiveCountMetricGood',
    'SloObjectiveCountMetricGoodAmazonPrometheus',
    'SloObjectiveCountMetricGoodAppdynamic',
    'SloObjectiveCountMetricGoodAzureMonitor',
    'SloObjectiveCountMetricGoodAzureMonitorDimension',
    'SloObjectiveCountMetricGoodAzureMonitorWorkspace',
    'SloObjectiveCountMetricGoodBigquery',
    'SloObjectiveCountMetricGoodCloudwatch',
    'SloObjectiveCountMetricGoodCloudwatchDimension',
    'SloObjectiveCountMetricGoodDatadog',
    'SloObjectiveCountMetricGoodDynatrace',
    'SloObjectiveCountMetricGoodElasticsearch',
    'SloObjectiveCountMetricGoodGcm',
    'SloObjectiveCountMetricGoodGrafanaLoki',
    'SloObjectiveCountMetricGoodGraphite',
    'SloObjectiveCountMetricGoodHoneycomb',
    'SloObjectiveCountMetricGoodInfluxdb',
    'SloObjectiveCountMetricGoodInstana',
    'SloObjectiveCountMetricGoodInstanaApplication',
    'SloObjectiveCountMetricGoodInstanaApplicationGroupBy',
    'SloObjectiveCountMetricGoodInstanaInfrastructure',
    'SloObjectiveCountMetricGoodLightstep',
    'SloObjectiveCountMetricGoodNewrelic',
    'SloObjectiveCountMetricGoodOpentsdb',
    'SloObjectiveCountMetricGoodPingdom',
    'SloObjectiveCountMetricGoodPrometheus',
    'SloObjectiveCountMetricGoodRedshift',
    'SloObjectiveCountMetricGoodSplunk',
    'SloObjectiveCountMetricGoodSplunkObservability',
    'SloObjectiveCountMetricGoodSumologic',
    'SloObjectiveCountMetricGoodThousandeye',
    'SloObjectiveCountMetricTotal',
    'SloObjectiveCountMetricTotalAmazonPrometheus',
    'SloObjectiveCountMetricTotalAppdynamic',
    'SloObjectiveCountMetricTotalAzureMonitor',
    'SloObjectiveCountMetricTotalAzureMonitorDimension',
    'SloObjectiveCountMetricTotalAzureMonitorWorkspace',
    'SloObjectiveCountMetricTotalBigquery',
    'SloObjectiveCountMetricTotalCloudwatch',
    'SloObjectiveCountMetricTotalCloudwatchDimension',
    'SloObjectiveCountMetricTotalDatadog',
    'SloObjectiveCountMetricTotalDynatrace',
    'SloObjectiveCountMetricTotalElasticsearch',
    'SloObjectiveCountMetricTotalGcm',
    'SloObjectiveCountMetricTotalGrafanaLoki',
    'SloObjectiveCountMetricTotalGraphite',
    'SloObjectiveCountMetricTotalHoneycomb',
    'SloObjectiveCountMetricTotalInfluxdb',
    'SloObjectiveCountMetricTotalInstana',
    'SloObjectiveCountMetricTotalInstanaApplication',
    'SloObjectiveCountMetricTotalInstanaApplicationGroupBy',
    'SloObjectiveCountMetricTotalInstanaInfrastructure',
    'SloObjectiveCountMetricTotalLightstep',
    'SloObjectiveCountMetricTotalNewrelic',
    'SloObjectiveCountMetricTotalOpentsdb',
    'SloObjectiveCountMetricTotalPingdom',
    'SloObjectiveCountMetricTotalPrometheus',
    'SloObjectiveCountMetricTotalRedshift',
    'SloObjectiveCountMetricTotalSplunk',
    'SloObjectiveCountMetricTotalSplunkObservability',
    'SloObjectiveCountMetricTotalSumologic',
    'SloObjectiveCountMetricTotalThousandeye',
    'SloObjectiveRawMetric',
    'SloObjectiveRawMetricQuery',
    'SloObjectiveRawMetricQueryAmazonPrometheus',
    'SloObjectiveRawMetricQueryAppdynamic',
    'SloObjectiveRawMetricQueryAzureMonitor',
    'SloObjectiveRawMetricQueryAzureMonitorDimension',
    'SloObjectiveRawMetricQueryAzureMonitorWorkspace',
    'SloObjectiveRawMetricQueryBigquery',
    'SloObjectiveRawMetricQueryCloudwatch',
    'SloObjectiveRawMetricQueryCloudwatchDimension',
    'SloObjectiveRawMetricQueryDatadog',
    'SloObjectiveRawMetricQueryDynatrace',
    'SloObjectiveRawMetricQueryElasticsearch',
    'SloObjectiveRawMetricQueryGcm',
    'SloObjectiveRawMetricQueryGrafanaLoki',
    'SloObjectiveRawMetricQueryGraphite',
    'SloObjectiveRawMetricQueryHoneycomb',
    'SloObjectiveRawMetricQueryInfluxdb',
    'SloObjectiveRawMetricQueryInstana',
    'SloObjectiveRawMetricQueryInstanaApplication',
    'SloObjectiveRawMetricQueryInstanaApplicationGroupBy',
    'SloObjectiveRawMetricQueryInstanaInfrastructure',
    'SloObjectiveRawMetricQueryLightstep',
    'SloObjectiveRawMetricQueryNewrelic',
    'SloObjectiveRawMetricQueryOpentsdb',
    'SloObjectiveRawMetricQueryPingdom',
    'SloObjectiveRawMetricQueryPrometheus',
    'SloObjectiveRawMetricQueryRedshift',
    'SloObjectiveRawMetricQuerySplunk',
    'SloObjectiveRawMetricQuerySplunkObservability',
    'SloObjectiveRawMetricQuerySumologic',
    'SloObjectiveRawMetricQueryThousandeye',
    'SloTimeWindow',
    'SloTimeWindowCalendar',
]

@pulumi.output_type
class AgentAmazonPrometheusConfig(dict):
    def __init__(__self__, *,
                 region: str,
                 url: str):
        """
        :param str region: AWS region e.g., eu-central-1
        :param str url: Base URL to Amazon Prometheus server.
        """
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        AWS region e.g., eu-central-1
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Base URL to Amazon Prometheus server.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AgentAppdynamicsConfig(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: Base URL to the AppDynamics Controller.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Base URL to the AppDynamics Controller.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AgentAzureMonitorConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentAzureMonitorConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentAzureMonitorConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentAzureMonitorConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tenant_id: str):
        """
        :param str tenant_id: Azure Tenant Id.
        """
        pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        Azure Tenant Id.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class AgentBigqueryConfig(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class AgentCloudwatchConfig(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class AgentDatadogConfig(dict):
    def __init__(__self__, *,
                 site: str):
        """
        :param str site: `com` or `eu`, Datadog SaaS instance, which corresponds to one of Datadog's two locations (https://www.datadoghq.com/ in the U.S. or https://datadoghq.eu/ in the European Union)
        """
        pulumi.set(__self__, "site", site)

    @property
    @pulumi.getter
    def site(self) -> str:
        """
        `com` or `eu`, Datadog SaaS instance, which corresponds to one of Datadog's two locations (https://www.datadoghq.com/ in the U.S. or https://datadoghq.eu/ in the European Union)
        """
        return pulumi.get(self, "site")


@pulumi.output_type
class AgentDynatraceConfig(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: Dynatrace API URL.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Dynatrace API URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AgentElasticsearchConfig(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: API URL endpoint to the Elasticsearch's instance.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        API URL endpoint to the Elasticsearch's instance.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AgentGcmConfig(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class AgentGrafanaLokiConfig(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: API URL endpoint to the Grafana Loki instance.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        API URL endpoint to the Grafana Loki instance.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AgentGraphiteConfig(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: API URL endpoint to the Graphite's instance.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        API URL endpoint to the Graphite's instance.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AgentHistoricalDataRetrieval(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultDurations":
            suggest = "default_durations"
        elif key == "maxDurations":
            suggest = "max_durations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentHistoricalDataRetrieval. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentHistoricalDataRetrieval.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentHistoricalDataRetrieval.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_durations: Sequence['outputs.AgentHistoricalDataRetrievalDefaultDuration'],
                 max_durations: Sequence['outputs.AgentHistoricalDataRetrievalMaxDuration']):
        """
        :param Sequence['AgentHistoricalDataRetrievalDefaultDurationArgs'] default_durations: Used by default for any SLOs connected to this data source.
        :param Sequence['AgentHistoricalDataRetrievalMaxDurationArgs'] max_durations: Defines the maximum period for which data can be retrieved.
        """
        pulumi.set(__self__, "default_durations", default_durations)
        pulumi.set(__self__, "max_durations", max_durations)

    @property
    @pulumi.getter(name="defaultDurations")
    def default_durations(self) -> Sequence['outputs.AgentHistoricalDataRetrievalDefaultDuration']:
        """
        Used by default for any SLOs connected to this data source.
        """
        return pulumi.get(self, "default_durations")

    @property
    @pulumi.getter(name="maxDurations")
    def max_durations(self) -> Sequence['outputs.AgentHistoricalDataRetrievalMaxDuration']:
        """
        Defines the maximum period for which data can be retrieved.
        """
        return pulumi.get(self, "max_durations")


@pulumi.output_type
class AgentHistoricalDataRetrievalDefaultDuration(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute, Hour, or Day.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute, Hour, or Day.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AgentHistoricalDataRetrievalMaxDuration(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute, Hour, or Day.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute, Hour, or Day.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AgentHoneycombConfig(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class AgentInfluxdbConfig(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: API URL endpoint to the InfluxDB's instance.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        API URL endpoint to the InfluxDB's instance.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AgentInstanaConfig(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: API URL endpoint to the InfluxDB's instance.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        API URL endpoint to the InfluxDB's instance.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AgentLightstepConfig(dict):
    def __init__(__self__, *,
                 organization: str,
                 project: str,
                 url: Optional[str] = None):
        """
        :param str organization: Organization name registered in Lightstep.
        :param str project: Name of the Lightstep project.
        :param str url: Lightstep API URL. Nobl9 will use https://api.lightstep.com if empty.
        """
        pulumi.set(__self__, "organization", organization)
        pulumi.set(__self__, "project", project)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def organization(self) -> str:
        """
        Organization name registered in Lightstep.
        """
        return pulumi.get(self, "organization")

    @property
    @pulumi.getter
    def project(self) -> str:
        """
        Name of the Lightstep project.
        """
        return pulumi.get(self, "project")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        Lightstep API URL. Nobl9 will use https://api.lightstep.com if empty.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AgentNewrelicConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountId":
            suggest = "account_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentNewrelicConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentNewrelicConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentNewrelicConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_id: str):
        """
        :param str account_id: ID number assigned to the New Relic user account.
        """
        pulumi.set(__self__, "account_id", account_id)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> str:
        """
        ID number assigned to the New Relic user account.
        """
        return pulumi.get(self, "account_id")


@pulumi.output_type
class AgentOpentsdbConfig(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: OpenTSDB cluster URL.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        OpenTSDB cluster URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AgentPingdomConfig(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class AgentPrometheusConfig(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: Base URL to Prometheus server.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Base URL to Prometheus server.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AgentQueryDelay(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute or Second.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute or Second.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AgentRedshiftConfig(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class AgentSplunkConfig(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: Base API URL to the Splunk Search app.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Base API URL to the Splunk Search app.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AgentSplunkObservabilityConfig(dict):
    def __init__(__self__, *,
                 realm: str):
        """
        :param str realm: SplunkObservability Realm.
        """
        pulumi.set(__self__, "realm", realm)

    @property
    @pulumi.getter
    def realm(self) -> str:
        """
        SplunkObservability Realm.
        """
        return pulumi.get(self, "realm")


@pulumi.output_type
class AgentSumologicConfig(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: Sumo Logic API URL.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Sumo Logic API URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AgentThousandeyesConfig(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class AlertMethodPagerdutySendResolution(dict):
    def __init__(__self__, *,
                 message: Optional[str] = None):
        """
        :param str message: A message that will be attached to your 'all clear' notification.
        """
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        A message that will be attached to your 'all clear' notification.
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class AlertPolicyAlertMethod(dict):
    def __init__(__self__, *,
                 name: str,
                 project: Optional[str] = None):
        """
        :param str name: The name of the previously defined alert method.
        :param str project: Project name the Alert Method is in, must conform to the naming convention from [DNS RFC1123](https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names). If not defined, Nobl9 returns a default value for this field.
        """
        pulumi.set(__self__, "name", name)
        if project is not None:
            pulumi.set(__self__, "project", project)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the previously defined alert method.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def project(self) -> Optional[str]:
        """
        Project name the Alert Method is in, must conform to the naming convention from [DNS RFC1123](https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names). If not defined, Nobl9 returns a default value for this field.
        """
        return pulumi.get(self, "project")


@pulumi.output_type
class AlertPolicyCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertingWindow":
            suggest = "alerting_window"
        elif key == "lastsFor":
            suggest = "lasts_for"
        elif key == "valueString":
            suggest = "value_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertPolicyCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertPolicyCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertPolicyCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 measurement: str,
                 alerting_window: Optional[str] = None,
                 lasts_for: Optional[str] = None,
                 value: Optional[float] = None,
                 value_string: Optional[str] = None):
        """
        :param str measurement: One of `timeToBurnBudget` | `timeToBurnEntireBudget` | `burnRate` | `burnedBudget`.
        :param str alerting_window: Duration over which the burn rate is evaluated.
        :param str lasts_for: Indicates how long a given condition needs to be valid to mark the condition as true.
        :param float value: For `averageBurnRate`, it indicates how fast the error budget is burning. For `burnedBudget`, it tells how much error budget is already burned.
        :param str value_string: Used with `timeToBurnBudget` or `timeToBurnEntireBudget`, indicates when the budget would be exhausted. The expected value is a string in time duration string format.
        """
        pulumi.set(__self__, "measurement", measurement)
        if alerting_window is not None:
            pulumi.set(__self__, "alerting_window", alerting_window)
        if lasts_for is not None:
            pulumi.set(__self__, "lasts_for", lasts_for)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_string is not None:
            pulumi.set(__self__, "value_string", value_string)

    @property
    @pulumi.getter
    def measurement(self) -> str:
        """
        One of `timeToBurnBudget` | `timeToBurnEntireBudget` | `burnRate` | `burnedBudget`.
        """
        return pulumi.get(self, "measurement")

    @property
    @pulumi.getter(name="alertingWindow")
    def alerting_window(self) -> Optional[str]:
        """
        Duration over which the burn rate is evaluated.
        """
        return pulumi.get(self, "alerting_window")

    @property
    @pulumi.getter(name="lastsFor")
    def lasts_for(self) -> Optional[str]:
        """
        Indicates how long a given condition needs to be valid to mark the condition as true.
        """
        return pulumi.get(self, "lasts_for")

    @property
    @pulumi.getter
    def value(self) -> Optional[float]:
        """
        For `averageBurnRate`, it indicates how fast the error budget is burning. For `burnedBudget`, it tells how much error budget is already burned.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueString")
    def value_string(self) -> Optional[str]:
        """
        Used with `timeToBurnBudget` or `timeToBurnEntireBudget`, indicates when the budget would be exhausted. The expected value is a string in time duration string format.
        """
        return pulumi.get(self, "value_string")


@pulumi.output_type
class DirectAppdynamicsHistoricalDataRetrieval(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultDurations":
            suggest = "default_durations"
        elif key == "maxDurations":
            suggest = "max_durations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DirectAppdynamicsHistoricalDataRetrieval. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DirectAppdynamicsHistoricalDataRetrieval.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DirectAppdynamicsHistoricalDataRetrieval.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_durations: Sequence['outputs.DirectAppdynamicsHistoricalDataRetrievalDefaultDuration'],
                 max_durations: Sequence['outputs.DirectAppdynamicsHistoricalDataRetrievalMaxDuration']):
        """
        :param Sequence['DirectAppdynamicsHistoricalDataRetrievalDefaultDurationArgs'] default_durations: Used by default for any SLOs connected to this data source.
        :param Sequence['DirectAppdynamicsHistoricalDataRetrievalMaxDurationArgs'] max_durations: Defines the maximum period for which data can be retrieved.
        """
        pulumi.set(__self__, "default_durations", default_durations)
        pulumi.set(__self__, "max_durations", max_durations)

    @property
    @pulumi.getter(name="defaultDurations")
    def default_durations(self) -> Sequence['outputs.DirectAppdynamicsHistoricalDataRetrievalDefaultDuration']:
        """
        Used by default for any SLOs connected to this data source.
        """
        return pulumi.get(self, "default_durations")

    @property
    @pulumi.getter(name="maxDurations")
    def max_durations(self) -> Sequence['outputs.DirectAppdynamicsHistoricalDataRetrievalMaxDuration']:
        """
        Defines the maximum period for which data can be retrieved.
        """
        return pulumi.get(self, "max_durations")


@pulumi.output_type
class DirectAppdynamicsHistoricalDataRetrievalDefaultDuration(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute, Hour, or Day.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute, Hour, or Day.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectAppdynamicsHistoricalDataRetrievalMaxDuration(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute, Hour, or Day.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute, Hour, or Day.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectAppdynamicsQueryDelay(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute or Second.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute or Second.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectAzureMonitorHistoricalDataRetrieval(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultDurations":
            suggest = "default_durations"
        elif key == "maxDurations":
            suggest = "max_durations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DirectAzureMonitorHistoricalDataRetrieval. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DirectAzureMonitorHistoricalDataRetrieval.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DirectAzureMonitorHistoricalDataRetrieval.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_durations: Sequence['outputs.DirectAzureMonitorHistoricalDataRetrievalDefaultDuration'],
                 max_durations: Sequence['outputs.DirectAzureMonitorHistoricalDataRetrievalMaxDuration']):
        """
        :param Sequence['DirectAzureMonitorHistoricalDataRetrievalDefaultDurationArgs'] default_durations: Used by default for any SLOs connected to this data source.
        :param Sequence['DirectAzureMonitorHistoricalDataRetrievalMaxDurationArgs'] max_durations: Defines the maximum period for which data can be retrieved.
        """
        pulumi.set(__self__, "default_durations", default_durations)
        pulumi.set(__self__, "max_durations", max_durations)

    @property
    @pulumi.getter(name="defaultDurations")
    def default_durations(self) -> Sequence['outputs.DirectAzureMonitorHistoricalDataRetrievalDefaultDuration']:
        """
        Used by default for any SLOs connected to this data source.
        """
        return pulumi.get(self, "default_durations")

    @property
    @pulumi.getter(name="maxDurations")
    def max_durations(self) -> Sequence['outputs.DirectAzureMonitorHistoricalDataRetrievalMaxDuration']:
        """
        Defines the maximum period for which data can be retrieved.
        """
        return pulumi.get(self, "max_durations")


@pulumi.output_type
class DirectAzureMonitorHistoricalDataRetrievalDefaultDuration(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute, Hour, or Day.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute, Hour, or Day.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectAzureMonitorHistoricalDataRetrievalMaxDuration(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute, Hour, or Day.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute, Hour, or Day.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectAzureMonitorQueryDelay(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute or Second.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute or Second.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectBigqueryQueryDelay(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute or Second.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute or Second.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectCloudwatchHistoricalDataRetrieval(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultDurations":
            suggest = "default_durations"
        elif key == "maxDurations":
            suggest = "max_durations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DirectCloudwatchHistoricalDataRetrieval. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DirectCloudwatchHistoricalDataRetrieval.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DirectCloudwatchHistoricalDataRetrieval.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_durations: Sequence['outputs.DirectCloudwatchHistoricalDataRetrievalDefaultDuration'],
                 max_durations: Sequence['outputs.DirectCloudwatchHistoricalDataRetrievalMaxDuration']):
        """
        :param Sequence['DirectCloudwatchHistoricalDataRetrievalDefaultDurationArgs'] default_durations: Used by default for any SLOs connected to this data source.
        :param Sequence['DirectCloudwatchHistoricalDataRetrievalMaxDurationArgs'] max_durations: Defines the maximum period for which data can be retrieved.
        """
        pulumi.set(__self__, "default_durations", default_durations)
        pulumi.set(__self__, "max_durations", max_durations)

    @property
    @pulumi.getter(name="defaultDurations")
    def default_durations(self) -> Sequence['outputs.DirectCloudwatchHistoricalDataRetrievalDefaultDuration']:
        """
        Used by default for any SLOs connected to this data source.
        """
        return pulumi.get(self, "default_durations")

    @property
    @pulumi.getter(name="maxDurations")
    def max_durations(self) -> Sequence['outputs.DirectCloudwatchHistoricalDataRetrievalMaxDuration']:
        """
        Defines the maximum period for which data can be retrieved.
        """
        return pulumi.get(self, "max_durations")


@pulumi.output_type
class DirectCloudwatchHistoricalDataRetrievalDefaultDuration(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute, Hour, or Day.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute, Hour, or Day.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectCloudwatchHistoricalDataRetrievalMaxDuration(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute, Hour, or Day.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute, Hour, or Day.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectCloudwatchQueryDelay(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute or Second.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute or Second.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectDatadogHistoricalDataRetrieval(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultDurations":
            suggest = "default_durations"
        elif key == "maxDurations":
            suggest = "max_durations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DirectDatadogHistoricalDataRetrieval. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DirectDatadogHistoricalDataRetrieval.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DirectDatadogHistoricalDataRetrieval.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_durations: Sequence['outputs.DirectDatadogHistoricalDataRetrievalDefaultDuration'],
                 max_durations: Sequence['outputs.DirectDatadogHistoricalDataRetrievalMaxDuration']):
        """
        :param Sequence['DirectDatadogHistoricalDataRetrievalDefaultDurationArgs'] default_durations: Used by default for any SLOs connected to this data source.
        :param Sequence['DirectDatadogHistoricalDataRetrievalMaxDurationArgs'] max_durations: Defines the maximum period for which data can be retrieved.
        """
        pulumi.set(__self__, "default_durations", default_durations)
        pulumi.set(__self__, "max_durations", max_durations)

    @property
    @pulumi.getter(name="defaultDurations")
    def default_durations(self) -> Sequence['outputs.DirectDatadogHistoricalDataRetrievalDefaultDuration']:
        """
        Used by default for any SLOs connected to this data source.
        """
        return pulumi.get(self, "default_durations")

    @property
    @pulumi.getter(name="maxDurations")
    def max_durations(self) -> Sequence['outputs.DirectDatadogHistoricalDataRetrievalMaxDuration']:
        """
        Defines the maximum period for which data can be retrieved.
        """
        return pulumi.get(self, "max_durations")


@pulumi.output_type
class DirectDatadogHistoricalDataRetrievalDefaultDuration(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute, Hour, or Day.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute, Hour, or Day.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectDatadogHistoricalDataRetrievalMaxDuration(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute, Hour, or Day.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute, Hour, or Day.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectDatadogQueryDelay(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute or Second.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute or Second.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectDynatraceHistoricalDataRetrieval(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultDurations":
            suggest = "default_durations"
        elif key == "maxDurations":
            suggest = "max_durations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DirectDynatraceHistoricalDataRetrieval. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DirectDynatraceHistoricalDataRetrieval.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DirectDynatraceHistoricalDataRetrieval.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_durations: Sequence['outputs.DirectDynatraceHistoricalDataRetrievalDefaultDuration'],
                 max_durations: Sequence['outputs.DirectDynatraceHistoricalDataRetrievalMaxDuration']):
        """
        :param Sequence['DirectDynatraceHistoricalDataRetrievalDefaultDurationArgs'] default_durations: Used by default for any SLOs connected to this data source.
        :param Sequence['DirectDynatraceHistoricalDataRetrievalMaxDurationArgs'] max_durations: Defines the maximum period for which data can be retrieved.
        """
        pulumi.set(__self__, "default_durations", default_durations)
        pulumi.set(__self__, "max_durations", max_durations)

    @property
    @pulumi.getter(name="defaultDurations")
    def default_durations(self) -> Sequence['outputs.DirectDynatraceHistoricalDataRetrievalDefaultDuration']:
        """
        Used by default for any SLOs connected to this data source.
        """
        return pulumi.get(self, "default_durations")

    @property
    @pulumi.getter(name="maxDurations")
    def max_durations(self) -> Sequence['outputs.DirectDynatraceHistoricalDataRetrievalMaxDuration']:
        """
        Defines the maximum period for which data can be retrieved.
        """
        return pulumi.get(self, "max_durations")


@pulumi.output_type
class DirectDynatraceHistoricalDataRetrievalDefaultDuration(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute, Hour, or Day.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute, Hour, or Day.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectDynatraceHistoricalDataRetrievalMaxDuration(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute, Hour, or Day.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute, Hour, or Day.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectDynatraceQueryDelay(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute or Second.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute or Second.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectGcmQueryDelay(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute or Second.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute or Second.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectHoneycombHistoricalDataRetrieval(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultDurations":
            suggest = "default_durations"
        elif key == "maxDurations":
            suggest = "max_durations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DirectHoneycombHistoricalDataRetrieval. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DirectHoneycombHistoricalDataRetrieval.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DirectHoneycombHistoricalDataRetrieval.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_durations: Sequence['outputs.DirectHoneycombHistoricalDataRetrievalDefaultDuration'],
                 max_durations: Sequence['outputs.DirectHoneycombHistoricalDataRetrievalMaxDuration']):
        """
        :param Sequence['DirectHoneycombHistoricalDataRetrievalDefaultDurationArgs'] default_durations: Used by default for any SLOs connected to this data source.
        :param Sequence['DirectHoneycombHistoricalDataRetrievalMaxDurationArgs'] max_durations: Defines the maximum period for which data can be retrieved.
        """
        pulumi.set(__self__, "default_durations", default_durations)
        pulumi.set(__self__, "max_durations", max_durations)

    @property
    @pulumi.getter(name="defaultDurations")
    def default_durations(self) -> Sequence['outputs.DirectHoneycombHistoricalDataRetrievalDefaultDuration']:
        """
        Used by default for any SLOs connected to this data source.
        """
        return pulumi.get(self, "default_durations")

    @property
    @pulumi.getter(name="maxDurations")
    def max_durations(self) -> Sequence['outputs.DirectHoneycombHistoricalDataRetrievalMaxDuration']:
        """
        Defines the maximum period for which data can be retrieved.
        """
        return pulumi.get(self, "max_durations")


@pulumi.output_type
class DirectHoneycombHistoricalDataRetrievalDefaultDuration(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute, Hour, or Day.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute, Hour, or Day.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectHoneycombHistoricalDataRetrievalMaxDuration(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute, Hour, or Day.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute, Hour, or Day.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectHoneycombQueryDelay(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute or Second.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute or Second.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectInfluxdbQueryDelay(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute or Second.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute or Second.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectInstanaQueryDelay(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute or Second.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute or Second.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectLightstepHistoricalDataRetrieval(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultDurations":
            suggest = "default_durations"
        elif key == "maxDurations":
            suggest = "max_durations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DirectLightstepHistoricalDataRetrieval. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DirectLightstepHistoricalDataRetrieval.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DirectLightstepHistoricalDataRetrieval.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_durations: Sequence['outputs.DirectLightstepHistoricalDataRetrievalDefaultDuration'],
                 max_durations: Sequence['outputs.DirectLightstepHistoricalDataRetrievalMaxDuration']):
        """
        :param Sequence['DirectLightstepHistoricalDataRetrievalDefaultDurationArgs'] default_durations: Used by default for any SLOs connected to this data source.
        :param Sequence['DirectLightstepHistoricalDataRetrievalMaxDurationArgs'] max_durations: Defines the maximum period for which data can be retrieved.
        """
        pulumi.set(__self__, "default_durations", default_durations)
        pulumi.set(__self__, "max_durations", max_durations)

    @property
    @pulumi.getter(name="defaultDurations")
    def default_durations(self) -> Sequence['outputs.DirectLightstepHistoricalDataRetrievalDefaultDuration']:
        """
        Used by default for any SLOs connected to this data source.
        """
        return pulumi.get(self, "default_durations")

    @property
    @pulumi.getter(name="maxDurations")
    def max_durations(self) -> Sequence['outputs.DirectLightstepHistoricalDataRetrievalMaxDuration']:
        """
        Defines the maximum period for which data can be retrieved.
        """
        return pulumi.get(self, "max_durations")


@pulumi.output_type
class DirectLightstepHistoricalDataRetrievalDefaultDuration(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute, Hour, or Day.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute, Hour, or Day.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectLightstepHistoricalDataRetrievalMaxDuration(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute, Hour, or Day.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute, Hour, or Day.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectLightstepQueryDelay(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute or Second.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute or Second.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectNewrelicHistoricalDataRetrieval(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultDurations":
            suggest = "default_durations"
        elif key == "maxDurations":
            suggest = "max_durations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DirectNewrelicHistoricalDataRetrieval. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DirectNewrelicHistoricalDataRetrieval.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DirectNewrelicHistoricalDataRetrieval.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_durations: Sequence['outputs.DirectNewrelicHistoricalDataRetrievalDefaultDuration'],
                 max_durations: Sequence['outputs.DirectNewrelicHistoricalDataRetrievalMaxDuration']):
        """
        :param Sequence['DirectNewrelicHistoricalDataRetrievalDefaultDurationArgs'] default_durations: Used by default for any SLOs connected to this data source.
        :param Sequence['DirectNewrelicHistoricalDataRetrievalMaxDurationArgs'] max_durations: Defines the maximum period for which data can be retrieved.
        """
        pulumi.set(__self__, "default_durations", default_durations)
        pulumi.set(__self__, "max_durations", max_durations)

    @property
    @pulumi.getter(name="defaultDurations")
    def default_durations(self) -> Sequence['outputs.DirectNewrelicHistoricalDataRetrievalDefaultDuration']:
        """
        Used by default for any SLOs connected to this data source.
        """
        return pulumi.get(self, "default_durations")

    @property
    @pulumi.getter(name="maxDurations")
    def max_durations(self) -> Sequence['outputs.DirectNewrelicHistoricalDataRetrievalMaxDuration']:
        """
        Defines the maximum period for which data can be retrieved.
        """
        return pulumi.get(self, "max_durations")


@pulumi.output_type
class DirectNewrelicHistoricalDataRetrievalDefaultDuration(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute, Hour, or Day.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute, Hour, or Day.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectNewrelicHistoricalDataRetrievalMaxDuration(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute, Hour, or Day.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute, Hour, or Day.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectNewrelicQueryDelay(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute or Second.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute or Second.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectPingdomQueryDelay(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute or Second.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute or Second.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectRedshiftQueryDelay(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute or Second.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute or Second.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectSplunkHistoricalDataRetrieval(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultDurations":
            suggest = "default_durations"
        elif key == "maxDurations":
            suggest = "max_durations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DirectSplunkHistoricalDataRetrieval. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DirectSplunkHistoricalDataRetrieval.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DirectSplunkHistoricalDataRetrieval.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_durations: Sequence['outputs.DirectSplunkHistoricalDataRetrievalDefaultDuration'],
                 max_durations: Sequence['outputs.DirectSplunkHistoricalDataRetrievalMaxDuration']):
        """
        :param Sequence['DirectSplunkHistoricalDataRetrievalDefaultDurationArgs'] default_durations: Used by default for any SLOs connected to this data source.
        :param Sequence['DirectSplunkHistoricalDataRetrievalMaxDurationArgs'] max_durations: Defines the maximum period for which data can be retrieved.
        """
        pulumi.set(__self__, "default_durations", default_durations)
        pulumi.set(__self__, "max_durations", max_durations)

    @property
    @pulumi.getter(name="defaultDurations")
    def default_durations(self) -> Sequence['outputs.DirectSplunkHistoricalDataRetrievalDefaultDuration']:
        """
        Used by default for any SLOs connected to this data source.
        """
        return pulumi.get(self, "default_durations")

    @property
    @pulumi.getter(name="maxDurations")
    def max_durations(self) -> Sequence['outputs.DirectSplunkHistoricalDataRetrievalMaxDuration']:
        """
        Defines the maximum period for which data can be retrieved.
        """
        return pulumi.get(self, "max_durations")


@pulumi.output_type
class DirectSplunkHistoricalDataRetrievalDefaultDuration(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute, Hour, or Day.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute, Hour, or Day.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectSplunkHistoricalDataRetrievalMaxDuration(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute, Hour, or Day.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute, Hour, or Day.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectSplunkObservabilityQueryDelay(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute or Second.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute or Second.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectSplunkQueryDelay(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute or Second.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute or Second.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectSumologicQueryDelay(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute or Second.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute or Second.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DirectThousandeyesQueryDelay(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Must be one of Minute or Second.
        :param int value: Must be an integer greater than or equal to 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Must be one of Minute or Second.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Must be an integer greater than or equal to 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProjectLabel(dict):
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str]):
        """
        :param str key: A key for the label, unique within the associated resource.
        :param Sequence[str] values: A list of unique values for a single key.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        A key for the label, unique within the associated resource.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        A list of unique values for a single key.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class ServiceLabel(dict):
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str]):
        """
        :param str key: A key for the label, unique within the associated resource.
        :param Sequence[str] values: A list of unique values for a single key.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        A key for the label, unique within the associated resource.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        A list of unique values for a single key.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class SloAnomalyConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noData":
            suggest = "no_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloAnomalyConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloAnomalyConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloAnomalyConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 no_data: 'outputs.SloAnomalyConfigNoData'):
        """
        :param 'SloAnomalyConfigNoDataArgs' no_data: Alert Policies attached to SLO
        """
        pulumi.set(__self__, "no_data", no_data)

    @property
    @pulumi.getter(name="noData")
    def no_data(self) -> 'outputs.SloAnomalyConfigNoData':
        """
        Alert Policies attached to SLO
        """
        return pulumi.get(self, "no_data")


@pulumi.output_type
class SloAnomalyConfigNoData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertMethods":
            suggest = "alert_methods"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloAnomalyConfigNoData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloAnomalyConfigNoData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloAnomalyConfigNoData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_methods: Sequence['outputs.SloAnomalyConfigNoDataAlertMethod']):
        """
        :param Sequence['SloAnomalyConfigNoDataAlertMethodArgs'] alert_methods: Alert methods attached to Anomaly Config
        """
        pulumi.set(__self__, "alert_methods", alert_methods)

    @property
    @pulumi.getter(name="alertMethods")
    def alert_methods(self) -> Sequence['outputs.SloAnomalyConfigNoDataAlertMethod']:
        """
        Alert methods attached to Anomaly Config
        """
        return pulumi.get(self, "alert_methods")


@pulumi.output_type
class SloAnomalyConfigNoDataAlertMethod(dict):
    def __init__(__self__, *,
                 name: str,
                 project: str):
        """
        :param str name: The name of the previously defined alert method.
        :param str project: Project name the Alert Method is in,  must conform to the naming convention from [DNS RFC1123](https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names). If not defined, Nobl9 returns a default value for this field.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project", project)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the previously defined alert method.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def project(self) -> str:
        """
        Project name the Alert Method is in,  must conform to the naming convention from [DNS RFC1123](https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names). If not defined, Nobl9 returns a default value for this field.
        """
        return pulumi.get(self, "project")


@pulumi.output_type
class SloAttachment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloAttachment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloAttachment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloAttachment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 display_name: Optional[str] = None):
        """
        :param str url: URL to the attachment
        :param str display_name: Name displayed for the attachment. Max. length: 63 characters.
        """
        pulumi.set(__self__, "url", url)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        URL to the attachment
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        Name displayed for the attachment. Max. length: 63 characters.
        """
        return pulumi.get(self, "display_name")


@pulumi.output_type
class SloComposite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "burnRateConditions":
            suggest = "burn_rate_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloComposite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloComposite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloComposite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target: float,
                 burn_rate_conditions: Optional[Sequence['outputs.SloCompositeBurnRateCondition']] = None):
        """
        :param float target: Designated value
        :param Sequence['SloCompositeBurnRateConditionArgs'] burn_rate_conditions: Condition when the Composite SLO’s error budget is burning.
        """
        pulumi.set(__self__, "target", target)
        if burn_rate_conditions is not None:
            pulumi.set(__self__, "burn_rate_conditions", burn_rate_conditions)

    @property
    @pulumi.getter
    def target(self) -> float:
        """
        Designated value
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="burnRateConditions")
    def burn_rate_conditions(self) -> Optional[Sequence['outputs.SloCompositeBurnRateCondition']]:
        """
        Condition when the Composite SLO’s error budget is burning.
        """
        return pulumi.get(self, "burn_rate_conditions")


@pulumi.output_type
class SloCompositeBurnRateCondition(dict):
    def __init__(__self__, *,
                 op: str,
                 value: float):
        """
        :param str op: Type of logical operation
        :param float value: Burn rate value.
        """
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def op(self) -> str:
        """
        Type of logical operation
        """
        return pulumi.get(self, "op")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        Burn rate value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SloIndicator(dict):
    def __init__(__self__, *,
                 name: str,
                 kind: Optional[str] = None,
                 project: Optional[str] = None):
        """
        :param str name: Name of the metric source (agent).
        :param str kind: Kind of the metric source. One of {Agent, Direct}.
        :param str project: Name of the metric source project.
        """
        pulumi.set(__self__, "name", name)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if project is not None:
            pulumi.set(__self__, "project", project)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the metric source (agent).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the metric source. One of {Agent, Direct}.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def project(self) -> Optional[str]:
        """
        Name of the metric source project.
        """
        return pulumi.get(self, "project")


@pulumi.output_type
class SloLabel(dict):
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str]):
        """
        :param str key: A key for the label, unique within the associated resource.
        :param Sequence[str] values: A list of unique values for a single key.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        A key for the label, unique within the associated resource.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        A list of unique values for a single key.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class SloObjective(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "countMetrics":
            suggest = "count_metrics"
        elif key == "rawMetrics":
            suggest = "raw_metrics"
        elif key == "timeSliceTarget":
            suggest = "time_slice_target"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjective. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjective.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjective.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: str,
                 target: float,
                 value: float,
                 count_metrics: Optional[Sequence['outputs.SloObjectiveCountMetric']] = None,
                 name: Optional[str] = None,
                 op: Optional[str] = None,
                 raw_metrics: Optional[Sequence['outputs.SloObjectiveRawMetric']] = None,
                 time_slice_target: Optional[float] = None):
        """
        :param str display_name: Name to be displayed
        :param float target: Designated value
        :param float value: Value
        :param Sequence['SloObjectiveCountMetricArgs'] count_metrics: Compares two time series, calculating the ratio of either good or bad values to the total number of values. Fill either the 'good' or 'bad' series, but not both.
        :param str name: Objective's name. This field is computed if not provided.
        :param str op: Type of logical operation
        :param Sequence['SloObjectiveRawMetricArgs'] raw_metrics: Raw data is used to compare objective values.
        :param float time_slice_target: Designated value for slice
        """
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "value", value)
        if count_metrics is not None:
            pulumi.set(__self__, "count_metrics", count_metrics)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if op is not None:
            pulumi.set(__self__, "op", op)
        if raw_metrics is not None:
            pulumi.set(__self__, "raw_metrics", raw_metrics)
        if time_slice_target is not None:
            pulumi.set(__self__, "time_slice_target", time_slice_target)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        Name to be displayed
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def target(self) -> float:
        """
        Designated value
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        Value
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="countMetrics")
    def count_metrics(self) -> Optional[Sequence['outputs.SloObjectiveCountMetric']]:
        """
        Compares two time series, calculating the ratio of either good or bad values to the total number of values. Fill either the 'good' or 'bad' series, but not both.
        """
        return pulumi.get(self, "count_metrics")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Objective's name. This field is computed if not provided.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def op(self) -> Optional[str]:
        """
        Type of logical operation
        """
        return pulumi.get(self, "op")

    @property
    @pulumi.getter(name="rawMetrics")
    def raw_metrics(self) -> Optional[Sequence['outputs.SloObjectiveRawMetric']]:
        """
        Raw data is used to compare objective values.
        """
        return pulumi.get(self, "raw_metrics")

    @property
    @pulumi.getter(name="timeSliceTarget")
    def time_slice_target(self) -> Optional[float]:
        """
        Designated value for slice
        """
        return pulumi.get(self, "time_slice_target")


@pulumi.output_type
class SloObjectiveCountMetric(dict):
    def __init__(__self__, *,
                 incremental: bool,
                 totals: Sequence['outputs.SloObjectiveCountMetricTotal'],
                 bads: Optional[Sequence['outputs.SloObjectiveCountMetricBad']] = None,
                 goods: Optional[Sequence['outputs.SloObjectiveCountMetricGood']] = None):
        """
        :param bool incremental: Should the metrics be incrementing or not
        :param Sequence['SloObjectiveCountMetricTotalArgs'] totals: Configuration for metric source
        :param Sequence['SloObjectiveCountMetricBadArgs'] bads: Configuration for bad time series metrics.
        :param Sequence['SloObjectiveCountMetricGoodArgs'] goods: Configuration for good time series metrics.
        """
        pulumi.set(__self__, "incremental", incremental)
        pulumi.set(__self__, "totals", totals)
        if bads is not None:
            pulumi.set(__self__, "bads", bads)
        if goods is not None:
            pulumi.set(__self__, "goods", goods)

    @property
    @pulumi.getter
    def incremental(self) -> bool:
        """
        Should the metrics be incrementing or not
        """
        return pulumi.get(self, "incremental")

    @property
    @pulumi.getter
    def totals(self) -> Sequence['outputs.SloObjectiveCountMetricTotal']:
        """
        Configuration for metric source
        """
        return pulumi.get(self, "totals")

    @property
    @pulumi.getter
    def bads(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricBad']]:
        """
        Configuration for bad time series metrics.
        """
        return pulumi.get(self, "bads")

    @property
    @pulumi.getter
    def goods(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGood']]:
        """
        Configuration for good time series metrics.
        """
        return pulumi.get(self, "goods")


@pulumi.output_type
class SloObjectiveCountMetricBad(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "amazonPrometheuses":
            suggest = "amazon_prometheuses"
        elif key == "azureMonitors":
            suggest = "azure_monitors"
        elif key == "grafanaLokis":
            suggest = "grafana_lokis"
        elif key == "splunkObservabilities":
            suggest = "splunk_observabilities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricBad. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricBad.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricBad.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amazon_prometheuses: Optional[Sequence['outputs.SloObjectiveCountMetricBadAmazonPrometheus']] = None,
                 appdynamics: Optional[Sequence['outputs.SloObjectiveCountMetricBadAppdynamic']] = None,
                 azure_monitors: Optional[Sequence['outputs.SloObjectiveCountMetricBadAzureMonitor']] = None,
                 bigqueries: Optional[Sequence['outputs.SloObjectiveCountMetricBadBigquery']] = None,
                 cloudwatches: Optional[Sequence['outputs.SloObjectiveCountMetricBadCloudwatch']] = None,
                 datadogs: Optional[Sequence['outputs.SloObjectiveCountMetricBadDatadog']] = None,
                 dynatraces: Optional[Sequence['outputs.SloObjectiveCountMetricBadDynatrace']] = None,
                 elasticsearches: Optional[Sequence['outputs.SloObjectiveCountMetricBadElasticsearch']] = None,
                 gcms: Optional[Sequence['outputs.SloObjectiveCountMetricBadGcm']] = None,
                 grafana_lokis: Optional[Sequence['outputs.SloObjectiveCountMetricBadGrafanaLoki']] = None,
                 graphites: Optional[Sequence['outputs.SloObjectiveCountMetricBadGraphite']] = None,
                 honeycombs: Optional[Sequence['outputs.SloObjectiveCountMetricBadHoneycomb']] = None,
                 influxdbs: Optional[Sequence['outputs.SloObjectiveCountMetricBadInfluxdb']] = None,
                 instanas: Optional[Sequence['outputs.SloObjectiveCountMetricBadInstana']] = None,
                 lightsteps: Optional[Sequence['outputs.SloObjectiveCountMetricBadLightstep']] = None,
                 newrelics: Optional[Sequence['outputs.SloObjectiveCountMetricBadNewrelic']] = None,
                 opentsdbs: Optional[Sequence['outputs.SloObjectiveCountMetricBadOpentsdb']] = None,
                 pingdoms: Optional[Sequence['outputs.SloObjectiveCountMetricBadPingdom']] = None,
                 prometheuses: Optional[Sequence['outputs.SloObjectiveCountMetricBadPrometheus']] = None,
                 redshifts: Optional[Sequence['outputs.SloObjectiveCountMetricBadRedshift']] = None,
                 splunk_observabilities: Optional[Sequence['outputs.SloObjectiveCountMetricBadSplunkObservability']] = None,
                 splunks: Optional[Sequence['outputs.SloObjectiveCountMetricBadSplunk']] = None,
                 sumologics: Optional[Sequence['outputs.SloObjectiveCountMetricBadSumologic']] = None,
                 thousandeyes: Optional[Sequence['outputs.SloObjectiveCountMetricBadThousandeye']] = None):
        """
        :param Sequence['SloObjectiveCountMetricBadAmazonPrometheusArgs'] amazon_prometheuses: [Configuration documentation](https://docs.nobl9.com/Sources/Amazon_Prometheus/#creating-slos-with-ams-prometheus)
        :param Sequence['SloObjectiveCountMetricBadAppdynamicArgs'] appdynamics: [Configuration documentation](https://docs.nobl9.com/Sources/appdynamics#creating-slos-with-appdynamics)
        :param Sequence['SloObjectiveCountMetricBadAzureMonitorArgs'] azure_monitors: [Configuration documentation](https://docs.nobl9.com/Sources/azure-monitor#creating-slos-with-azure-monitor)
        :param Sequence['SloObjectiveCountMetricBadBigqueryArgs'] bigqueries: [Configuration documentation](https://docs.nobl9.com/Sources/bigquery#creating-slos-with-bigquery)
        :param Sequence['SloObjectiveCountMetricBadCloudwatchArgs'] cloudwatches: [Configuration documentation](https://docs.nobl9.com/Sources/Amazon_CloudWatch/#creating-slos-with-cloudwatch)
        :param Sequence['SloObjectiveCountMetricBadDatadogArgs'] datadogs: [Configuration documentation](https://docs.nobl9.com/Sources/datadog#creating-slos-with-datadog)
        :param Sequence['SloObjectiveCountMetricBadDynatraceArgs'] dynatraces: [Configuration documentation](https://docs.nobl9.com/Sources/dynatrace#creating-slos-with-dynatrace)
        :param Sequence['SloObjectiveCountMetricBadElasticsearchArgs'] elasticsearches: [Configuration documentation](https://docs.nobl9.com/Sources/elasticsearch#creating-slos-with-elasticsearch)
        :param Sequence['SloObjectiveCountMetricBadGcmArgs'] gcms: [Configuration documentation](https://docs.nobl9.com/Sources/google-cloud-monitoring#creating-slos-with-google-cloud-monitoring)
        :param Sequence['SloObjectiveCountMetricBadGrafanaLokiArgs'] grafana_lokis: [Configuration documentation](https://docs.nobl9.com/Sources/grafana-loki#creating-slos-with-grafana-loki)
        :param Sequence['SloObjectiveCountMetricBadGraphiteArgs'] graphites: [Configuration documentation](https://docs.nobl9.com/Sources/graphite#creating-slos-with-graphite)
        :param Sequence['SloObjectiveCountMetricBadHoneycombArgs'] honeycombs: [Configuration documentation](https://docs.nobl9.com/Sources/honeycomb#creating-slos-with-honeycomb)
        :param Sequence['SloObjectiveCountMetricBadInfluxdbArgs'] influxdbs: [Configuration documentation](https://docs.nobl9.com/Sources/influxdb#creating-slos-with-influxdb)
        :param Sequence['SloObjectiveCountMetricBadInstanaArgs'] instanas: [Configuration documentation](https://docs.nobl9.com/Sources/instana#creating-slos-with-instana)
        :param Sequence['SloObjectiveCountMetricBadLightstepArgs'] lightsteps: [Configuration documentation](https://docs.nobl9.com/Sources/lightstep#creating-slos-with-lightstep)
        :param Sequence['SloObjectiveCountMetricBadNewrelicArgs'] newrelics: [Configuration documentation](https://docs.nobl9.com/Sources/new-relic#creating-slos-with-new-relic)
        :param Sequence['SloObjectiveCountMetricBadOpentsdbArgs'] opentsdbs: [Configuration documentation](https://docs.nobl9.com/Sources/opentsdb#creating-slos-with-opentsdb)
        :param Sequence['SloObjectiveCountMetricBadPingdomArgs'] pingdoms: [Configuration documentation](https://docs.nobl9.com/Sources/pingdom#creating-slos-with-pingdom)
        :param Sequence['SloObjectiveCountMetricBadPrometheusArgs'] prometheuses: [Configuration documentation](https://docs.nobl9.com/Sources/prometheus#creating-slos-with-prometheus)
        :param Sequence['SloObjectiveCountMetricBadRedshiftArgs'] redshifts: [Configuration documentation](https://docs.nobl9.com/Sources/Amazon_Redshift/#creating-slos-with-amazon-redshift)
        :param Sequence['SloObjectiveCountMetricBadSplunkObservabilityArgs'] splunk_observabilities: [Configuration documentation](https://docs.nobl9.com/Sources/splunk#creating-slos-with-splunk-observability)
        :param Sequence['SloObjectiveCountMetricBadSplunkArgs'] splunks: [Configuration documentation](https://docs.nobl9.com/Sources/splunk#creating-slos-with-splunk)
        :param Sequence['SloObjectiveCountMetricBadSumologicArgs'] sumologics: [Configuration documentation](https://docs.nobl9.com/Sources/sumo-logic#creating-slos-with-sumo-logic)
        :param Sequence['SloObjectiveCountMetricBadThousandeyeArgs'] thousandeyes: [Configuration documentation](https://docs.nobl9.com/Sources/thousandeyes#creating-slos-with-thousandeyes)
        """
        if amazon_prometheuses is not None:
            pulumi.set(__self__, "amazon_prometheuses", amazon_prometheuses)
        if appdynamics is not None:
            pulumi.set(__self__, "appdynamics", appdynamics)
        if azure_monitors is not None:
            pulumi.set(__self__, "azure_monitors", azure_monitors)
        if bigqueries is not None:
            pulumi.set(__self__, "bigqueries", bigqueries)
        if cloudwatches is not None:
            pulumi.set(__self__, "cloudwatches", cloudwatches)
        if datadogs is not None:
            pulumi.set(__self__, "datadogs", datadogs)
        if dynatraces is not None:
            pulumi.set(__self__, "dynatraces", dynatraces)
        if elasticsearches is not None:
            pulumi.set(__self__, "elasticsearches", elasticsearches)
        if gcms is not None:
            pulumi.set(__self__, "gcms", gcms)
        if grafana_lokis is not None:
            pulumi.set(__self__, "grafana_lokis", grafana_lokis)
        if graphites is not None:
            pulumi.set(__self__, "graphites", graphites)
        if honeycombs is not None:
            pulumi.set(__self__, "honeycombs", honeycombs)
        if influxdbs is not None:
            pulumi.set(__self__, "influxdbs", influxdbs)
        if instanas is not None:
            pulumi.set(__self__, "instanas", instanas)
        if lightsteps is not None:
            pulumi.set(__self__, "lightsteps", lightsteps)
        if newrelics is not None:
            pulumi.set(__self__, "newrelics", newrelics)
        if opentsdbs is not None:
            pulumi.set(__self__, "opentsdbs", opentsdbs)
        if pingdoms is not None:
            pulumi.set(__self__, "pingdoms", pingdoms)
        if prometheuses is not None:
            pulumi.set(__self__, "prometheuses", prometheuses)
        if redshifts is not None:
            pulumi.set(__self__, "redshifts", redshifts)
        if splunk_observabilities is not None:
            pulumi.set(__self__, "splunk_observabilities", splunk_observabilities)
        if splunks is not None:
            pulumi.set(__self__, "splunks", splunks)
        if sumologics is not None:
            pulumi.set(__self__, "sumologics", sumologics)
        if thousandeyes is not None:
            pulumi.set(__self__, "thousandeyes", thousandeyes)

    @property
    @pulumi.getter(name="amazonPrometheuses")
    def amazon_prometheuses(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricBadAmazonPrometheus']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/Amazon_Prometheus/#creating-slos-with-ams-prometheus)
        """
        return pulumi.get(self, "amazon_prometheuses")

    @property
    @pulumi.getter
    def appdynamics(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricBadAppdynamic']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/appdynamics#creating-slos-with-appdynamics)
        """
        return pulumi.get(self, "appdynamics")

    @property
    @pulumi.getter(name="azureMonitors")
    def azure_monitors(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricBadAzureMonitor']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/azure-monitor#creating-slos-with-azure-monitor)
        """
        return pulumi.get(self, "azure_monitors")

    @property
    @pulumi.getter
    def bigqueries(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricBadBigquery']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/bigquery#creating-slos-with-bigquery)
        """
        return pulumi.get(self, "bigqueries")

    @property
    @pulumi.getter
    def cloudwatches(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricBadCloudwatch']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/Amazon_CloudWatch/#creating-slos-with-cloudwatch)
        """
        return pulumi.get(self, "cloudwatches")

    @property
    @pulumi.getter
    def datadogs(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricBadDatadog']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/datadog#creating-slos-with-datadog)
        """
        return pulumi.get(self, "datadogs")

    @property
    @pulumi.getter
    def dynatraces(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricBadDynatrace']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/dynatrace#creating-slos-with-dynatrace)
        """
        return pulumi.get(self, "dynatraces")

    @property
    @pulumi.getter
    def elasticsearches(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricBadElasticsearch']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/elasticsearch#creating-slos-with-elasticsearch)
        """
        return pulumi.get(self, "elasticsearches")

    @property
    @pulumi.getter
    def gcms(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricBadGcm']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/google-cloud-monitoring#creating-slos-with-google-cloud-monitoring)
        """
        return pulumi.get(self, "gcms")

    @property
    @pulumi.getter(name="grafanaLokis")
    def grafana_lokis(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricBadGrafanaLoki']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/grafana-loki#creating-slos-with-grafana-loki)
        """
        return pulumi.get(self, "grafana_lokis")

    @property
    @pulumi.getter
    def graphites(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricBadGraphite']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/graphite#creating-slos-with-graphite)
        """
        return pulumi.get(self, "graphites")

    @property
    @pulumi.getter
    def honeycombs(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricBadHoneycomb']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/honeycomb#creating-slos-with-honeycomb)
        """
        return pulumi.get(self, "honeycombs")

    @property
    @pulumi.getter
    def influxdbs(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricBadInfluxdb']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/influxdb#creating-slos-with-influxdb)
        """
        return pulumi.get(self, "influxdbs")

    @property
    @pulumi.getter
    def instanas(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricBadInstana']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/instana#creating-slos-with-instana)
        """
        return pulumi.get(self, "instanas")

    @property
    @pulumi.getter
    def lightsteps(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricBadLightstep']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/lightstep#creating-slos-with-lightstep)
        """
        return pulumi.get(self, "lightsteps")

    @property
    @pulumi.getter
    def newrelics(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricBadNewrelic']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/new-relic#creating-slos-with-new-relic)
        """
        return pulumi.get(self, "newrelics")

    @property
    @pulumi.getter
    def opentsdbs(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricBadOpentsdb']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/opentsdb#creating-slos-with-opentsdb)
        """
        return pulumi.get(self, "opentsdbs")

    @property
    @pulumi.getter
    def pingdoms(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricBadPingdom']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/pingdom#creating-slos-with-pingdom)
        """
        return pulumi.get(self, "pingdoms")

    @property
    @pulumi.getter
    def prometheuses(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricBadPrometheus']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/prometheus#creating-slos-with-prometheus)
        """
        return pulumi.get(self, "prometheuses")

    @property
    @pulumi.getter
    def redshifts(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricBadRedshift']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/Amazon_Redshift/#creating-slos-with-amazon-redshift)
        """
        return pulumi.get(self, "redshifts")

    @property
    @pulumi.getter(name="splunkObservabilities")
    def splunk_observabilities(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricBadSplunkObservability']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/splunk#creating-slos-with-splunk-observability)
        """
        return pulumi.get(self, "splunk_observabilities")

    @property
    @pulumi.getter
    def splunks(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricBadSplunk']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/splunk#creating-slos-with-splunk)
        """
        return pulumi.get(self, "splunks")

    @property
    @pulumi.getter
    def sumologics(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricBadSumologic']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/sumo-logic#creating-slos-with-sumo-logic)
        """
        return pulumi.get(self, "sumologics")

    @property
    @pulumi.getter
    def thousandeyes(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricBadThousandeye']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/thousandeyes#creating-slos-with-thousandeyes)
        """
        return pulumi.get(self, "thousandeyes")


@pulumi.output_type
class SloObjectiveCountMetricBadAmazonPrometheus(dict):
    def __init__(__self__, *,
                 promql: str):
        """
        :param str promql: Query for the metrics
        """
        pulumi.set(__self__, "promql", promql)

    @property
    @pulumi.getter
    def promql(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "promql")


@pulumi.output_type
class SloObjectiveCountMetricBadAppdynamic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationName":
            suggest = "application_name"
        elif key == "metricPath":
            suggest = "metric_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricBadAppdynamic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricBadAppdynamic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricBadAppdynamic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_name: str,
                 metric_path: str):
        """
        :param str application_name: Name of the added application
        :param str metric_path: Path to the metrics
        """
        pulumi.set(__self__, "application_name", application_name)
        pulumi.set(__self__, "metric_path", metric_path)

    @property
    @pulumi.getter(name="applicationName")
    def application_name(self) -> str:
        """
        Name of the added application
        """
        return pulumi.get(self, "application_name")

    @property
    @pulumi.getter(name="metricPath")
    def metric_path(self) -> str:
        """
        Path to the metrics
        """
        return pulumi.get(self, "metric_path")


@pulumi.output_type
class SloObjectiveCountMetricBadAzureMonitor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"
        elif key == "kqlQuery":
            suggest = "kql_query"
        elif key == "metricName":
            suggest = "metric_name"
        elif key == "metricNamespace":
            suggest = "metric_namespace"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricBadAzureMonitor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricBadAzureMonitor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricBadAzureMonitor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_type: str,
                 aggregation: Optional[str] = None,
                 dimensions: Optional[Sequence['outputs.SloObjectiveCountMetricBadAzureMonitorDimension']] = None,
                 kql_query: Optional[str] = None,
                 metric_name: Optional[str] = None,
                 metric_namespace: Optional[str] = None,
                 resource_id: Optional[str] = None,
                 workspaces: Optional[Sequence['outputs.SloObjectiveCountMetricBadAzureMonitorWorkspace']] = None):
        """
        :param str data_type: Specifies source: 'metrics' or 'logs'
        :param str aggregation: Aggregation type [Required for metrics]
        :param Sequence['SloObjectiveCountMetricBadAzureMonitorDimensionArgs'] dimensions: Dimensions of the metric [Optional for metrics]
        :param str kql_query: Logs query in Kusto Query Language [Required for logs]
        :param str metric_name: Name of the metric [Required for metrics]
        :param str metric_namespace: Namespace of the metric [Optional for metrics]
        :param str resource_id: Identifier of the Azure Cloud resource [Required for metrics]
        :param Sequence['SloObjectiveCountMetricBadAzureMonitorWorkspaceArgs'] workspaces: Log analytics workspace [Required for logs]
        """
        pulumi.set(__self__, "data_type", data_type)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if kql_query is not None:
            pulumi.set(__self__, "kql_query", kql_query)
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)
        if metric_namespace is not None:
            pulumi.set(__self__, "metric_namespace", metric_namespace)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if workspaces is not None:
            pulumi.set(__self__, "workspaces", workspaces)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> str:
        """
        Specifies source: 'metrics' or 'logs'
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[str]:
        """
        Aggregation type [Required for metrics]
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricBadAzureMonitorDimension']]:
        """
        Dimensions of the metric [Optional for metrics]
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="kqlQuery")
    def kql_query(self) -> Optional[str]:
        """
        Logs query in Kusto Query Language [Required for logs]
        """
        return pulumi.get(self, "kql_query")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[str]:
        """
        Name of the metric [Required for metrics]
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter(name="metricNamespace")
    def metric_namespace(self) -> Optional[str]:
        """
        Namespace of the metric [Optional for metrics]
        """
        return pulumi.get(self, "metric_namespace")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        """
        Identifier of the Azure Cloud resource [Required for metrics]
        """
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter
    def workspaces(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricBadAzureMonitorWorkspace']]:
        """
        Log analytics workspace [Required for logs]
        """
        return pulumi.get(self, "workspaces")


@pulumi.output_type
class SloObjectiveCountMetricBadAzureMonitorDimension(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The name of the previously defined alert method.
        :param str value: Burn rate value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the previously defined alert method.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Burn rate value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SloObjectiveCountMetricBadAzureMonitorWorkspace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceGroup":
            suggest = "resource_group"
        elif key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "workspaceId":
            suggest = "workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricBadAzureMonitorWorkspace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricBadAzureMonitorWorkspace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricBadAzureMonitorWorkspace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_group: str,
                 subscription_id: str,
                 workspace_id: str):
        """
        :param str resource_group: Resource group of the workspace
        :param str subscription_id: Subscription ID of the workspace
        :param str workspace_id: ID of the workspace
        """
        pulumi.set(__self__, "resource_group", resource_group)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "workspace_id", workspace_id)

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> str:
        """
        Resource group of the workspace
        """
        return pulumi.get(self, "resource_group")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> str:
        """
        Subscription ID of the workspace
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> str:
        """
        ID of the workspace
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class SloObjectiveCountMetricBadBigquery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricBadBigquery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricBadBigquery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricBadBigquery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 location: str,
                 project_id: str,
                 query: str):
        """
        :param str location: Location of you BigQuery
        :param str project_id: Project ID
        :param str query: Query for the metrics
        """
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        Location of you BigQuery
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        Project ID
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveCountMetricBadCloudwatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountId":
            suggest = "account_id"
        elif key == "metricName":
            suggest = "metric_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricBadCloudwatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricBadCloudwatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricBadCloudwatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region: str,
                 account_id: Optional[str] = None,
                 dimensions: Optional[Sequence['outputs.SloObjectiveCountMetricBadCloudwatchDimension']] = None,
                 json: Optional[str] = None,
                 metric_name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 sql: Optional[str] = None,
                 stat: Optional[str] = None):
        """
        :param str region: Region of the CloudWatch instance
        :param str account_id: AccountID used with cross-account observability feature
        :param Sequence['SloObjectiveCountMetricBadCloudwatchDimensionArgs'] dimensions: Dimensions of the metric [Optional for metrics]
        :param str json: JSON query
        :param str metric_name: Name of the metric [Required for metrics]
        :param str namespace: Namespace of the metric
        :param str sql: SQL query
        :param str stat: Metric data aggregations
        """
        pulumi.set(__self__, "region", region)
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if json is not None:
            pulumi.set(__self__, "json", json)
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if sql is not None:
            pulumi.set(__self__, "sql", sql)
        if stat is not None:
            pulumi.set(__self__, "stat", stat)

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Region of the CloudWatch instance
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[str]:
        """
        AccountID used with cross-account observability feature
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricBadCloudwatchDimension']]:
        """
        Dimensions of the metric [Optional for metrics]
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def json(self) -> Optional[str]:
        """
        JSON query
        """
        return pulumi.get(self, "json")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[str]:
        """
        Name of the metric [Required for metrics]
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the metric
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def sql(self) -> Optional[str]:
        """
        SQL query
        """
        return pulumi.get(self, "sql")

    @property
    @pulumi.getter
    def stat(self) -> Optional[str]:
        """
        Metric data aggregations
        """
        return pulumi.get(self, "stat")


@pulumi.output_type
class SloObjectiveCountMetricBadCloudwatchDimension(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The name of the previously defined alert method.
        :param str value: Burn rate value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the previously defined alert method.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Burn rate value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SloObjectiveCountMetricBadDatadog(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: Query for the metrics
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveCountMetricBadDynatrace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricSelector":
            suggest = "metric_selector"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricBadDynatrace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricBadDynatrace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricBadDynatrace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_selector: str):
        """
        :param str metric_selector: Selector for the metrics
        """
        pulumi.set(__self__, "metric_selector", metric_selector)

    @property
    @pulumi.getter(name="metricSelector")
    def metric_selector(self) -> str:
        """
        Selector for the metrics
        """
        return pulumi.get(self, "metric_selector")


@pulumi.output_type
class SloObjectiveCountMetricBadElasticsearch(dict):
    def __init__(__self__, *,
                 index: str,
                 query: str):
        """
        :param str index: Index of metrics we want to query
        :param str query: Query for the metrics
        """
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        Index of metrics we want to query
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveCountMetricBadGcm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricBadGcm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricBadGcm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricBadGcm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 project_id: str,
                 query: str):
        """
        :param str project_id: Project ID
        :param str query: Query for the metrics
        """
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        Project ID
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveCountMetricBadGrafanaLoki(dict):
    def __init__(__self__, *,
                 logql: str):
        """
        :param str logql: Query for the logs
        """
        pulumi.set(__self__, "logql", logql)

    @property
    @pulumi.getter
    def logql(self) -> str:
        """
        Query for the logs
        """
        return pulumi.get(self, "logql")


@pulumi.output_type
class SloObjectiveCountMetricBadGraphite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricPath":
            suggest = "metric_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricBadGraphite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricBadGraphite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricBadGraphite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_path: str):
        """
        :param str metric_path: Path to the metrics
        """
        pulumi.set(__self__, "metric_path", metric_path)

    @property
    @pulumi.getter(name="metricPath")
    def metric_path(self) -> str:
        """
        Path to the metrics
        """
        return pulumi.get(self, "metric_path")


@pulumi.output_type
class SloObjectiveCountMetricBadHoneycomb(dict):
    def __init__(__self__, *,
                 calculation: str,
                 attribute: Optional[str] = None):
        """
        :param str calculation: Calculation type
        :param str attribute: Column name - required for all calculation types besides 'CONCURRENCY' and 'COUNT'
        """
        pulumi.set(__self__, "calculation", calculation)
        if attribute is not None:
            pulumi.set(__self__, "attribute", attribute)

    @property
    @pulumi.getter
    def calculation(self) -> str:
        """
        Calculation type
        """
        return pulumi.get(self, "calculation")

    @property
    @pulumi.getter
    def attribute(self) -> Optional[str]:
        """
        Column name - required for all calculation types besides 'CONCURRENCY' and 'COUNT'
        """
        return pulumi.get(self, "attribute")


@pulumi.output_type
class SloObjectiveCountMetricBadInfluxdb(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: Query for the metrics
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveCountMetricBadInstana(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricType":
            suggest = "metric_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricBadInstana. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricBadInstana.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricBadInstana.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_type: str,
                 applications: Optional[Sequence['outputs.SloObjectiveCountMetricBadInstanaApplication']] = None,
                 infrastructures: Optional[Sequence['outputs.SloObjectiveCountMetricBadInstanaInfrastructure']] = None):
        """
        :param str metric_type: Instana metric type 'application' or 'infrastructure'
        :param Sequence['SloObjectiveCountMetricBadInstanaApplicationArgs'] applications: Infrastructure metric type
        :param Sequence['SloObjectiveCountMetricBadInstanaInfrastructureArgs'] infrastructures: Infrastructure metric type
        """
        pulumi.set(__self__, "metric_type", metric_type)
        if applications is not None:
            pulumi.set(__self__, "applications", applications)
        if infrastructures is not None:
            pulumi.set(__self__, "infrastructures", infrastructures)

    @property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> str:
        """
        Instana metric type 'application' or 'infrastructure'
        """
        return pulumi.get(self, "metric_type")

    @property
    @pulumi.getter
    def applications(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricBadInstanaApplication']]:
        """
        Infrastructure metric type
        """
        return pulumi.get(self, "applications")

    @property
    @pulumi.getter
    def infrastructures(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricBadInstanaInfrastructure']]:
        """
        Infrastructure metric type
        """
        return pulumi.get(self, "infrastructures")


@pulumi.output_type
class SloObjectiveCountMetricBadInstanaApplication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiQuery":
            suggest = "api_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "metricId":
            suggest = "metric_id"
        elif key == "includeInternal":
            suggest = "include_internal"
        elif key == "includeSynthetic":
            suggest = "include_synthetic"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricBadInstanaApplication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricBadInstanaApplication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricBadInstanaApplication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation: str,
                 api_query: str,
                 group_bies: Sequence['outputs.SloObjectiveCountMetricBadInstanaApplicationGroupBy'],
                 metric_id: str,
                 include_internal: Optional[bool] = None,
                 include_synthetic: Optional[bool] = None):
        """
        :param str aggregation: Aggregation type [Required for metrics]
        :param str api_query: API query user passes in a JSON format
        :param Sequence['SloObjectiveCountMetricBadInstanaApplicationGroupByArgs'] group_bies: Group by method
        :param str metric_id: Metric ID one of 'calls', 'erroneousCalls', 'errors', 'latency'
        :param bool include_internal: Include internal
        :param bool include_synthetic: Include synthetic
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "api_query", api_query)
        pulumi.set(__self__, "group_bies", group_bies)
        pulumi.set(__self__, "metric_id", metric_id)
        if include_internal is not None:
            pulumi.set(__self__, "include_internal", include_internal)
        if include_synthetic is not None:
            pulumi.set(__self__, "include_synthetic", include_synthetic)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        Aggregation type [Required for metrics]
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="apiQuery")
    def api_query(self) -> str:
        """
        API query user passes in a JSON format
        """
        return pulumi.get(self, "api_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Sequence['outputs.SloObjectiveCountMetricBadInstanaApplicationGroupBy']:
        """
        Group by method
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="metricId")
    def metric_id(self) -> str:
        """
        Metric ID one of 'calls', 'erroneousCalls', 'errors', 'latency'
        """
        return pulumi.get(self, "metric_id")

    @property
    @pulumi.getter(name="includeInternal")
    def include_internal(self) -> Optional[bool]:
        """
        Include internal
        """
        return pulumi.get(self, "include_internal")

    @property
    @pulumi.getter(name="includeSynthetic")
    def include_synthetic(self) -> Optional[bool]:
        """
        Include synthetic
        """
        return pulumi.get(self, "include_synthetic")


@pulumi.output_type
class SloObjectiveCountMetricBadInstanaApplicationGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagEntity":
            suggest = "tag_entity"
        elif key == "tagSecondLevelKey":
            suggest = "tag_second_level_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricBadInstanaApplicationGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricBadInstanaApplicationGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricBadInstanaApplicationGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tag: str,
                 tag_entity: str,
                 tag_second_level_key: Optional[str] = None):
        """
        :param str tag: Group by tag
        :param str tag_entity: Tag entity - one of 'DESTINATION', 'SOURCE', 'NOT_APPLICABLE'
        """
        pulumi.set(__self__, "tag", tag)
        pulumi.set(__self__, "tag_entity", tag_entity)
        if tag_second_level_key is not None:
            pulumi.set(__self__, "tag_second_level_key", tag_second_level_key)

    @property
    @pulumi.getter
    def tag(self) -> str:
        """
        Group by tag
        """
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter(name="tagEntity")
    def tag_entity(self) -> str:
        """
        Tag entity - one of 'DESTINATION', 'SOURCE', 'NOT_APPLICABLE'
        """
        return pulumi.get(self, "tag_entity")

    @property
    @pulumi.getter(name="tagSecondLevelKey")
    def tag_second_level_key(self) -> Optional[str]:
        return pulumi.get(self, "tag_second_level_key")


@pulumi.output_type
class SloObjectiveCountMetricBadInstanaInfrastructure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricId":
            suggest = "metric_id"
        elif key == "metricRetrievalMethod":
            suggest = "metric_retrieval_method"
        elif key == "pluginId":
            suggest = "plugin_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricBadInstanaInfrastructure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricBadInstanaInfrastructure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricBadInstanaInfrastructure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_id: str,
                 metric_retrieval_method: str,
                 plugin_id: str,
                 query: Optional[str] = None,
                 snapshot_id: Optional[str] = None):
        """
        :param str metric_id: Metric ID one of 'calls', 'erroneousCalls', 'errors', 'latency'
        :param str metric_retrieval_method: Metric retrieval method 'query' or 'snapshot'
        :param str plugin_id: Plugin ID
        :param str query: Query for the metrics
        :param str snapshot_id: Snapshot ID
        """
        pulumi.set(__self__, "metric_id", metric_id)
        pulumi.set(__self__, "metric_retrieval_method", metric_retrieval_method)
        pulumi.set(__self__, "plugin_id", plugin_id)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)

    @property
    @pulumi.getter(name="metricId")
    def metric_id(self) -> str:
        """
        Metric ID one of 'calls', 'erroneousCalls', 'errors', 'latency'
        """
        return pulumi.get(self, "metric_id")

    @property
    @pulumi.getter(name="metricRetrievalMethod")
    def metric_retrieval_method(self) -> str:
        """
        Metric retrieval method 'query' or 'snapshot'
        """
        return pulumi.get(self, "metric_retrieval_method")

    @property
    @pulumi.getter(name="pluginId")
    def plugin_id(self) -> str:
        """
        Plugin ID
        """
        return pulumi.get(self, "plugin_id")

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        """
        Snapshot ID
        """
        return pulumi.get(self, "snapshot_id")


@pulumi.output_type
class SloObjectiveCountMetricBadLightstep(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeOfData":
            suggest = "type_of_data"
        elif key == "streamId":
            suggest = "stream_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricBadLightstep. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricBadLightstep.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricBadLightstep.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type_of_data: str,
                 percentile: Optional[float] = None,
                 stream_id: Optional[str] = None,
                 uql: Optional[str] = None):
        """
        :param str type_of_data: Type of data to filter by
        :param float percentile: Optional value to filter by percentiles
        :param str stream_id: ID of the metrics stream
        :param str uql: UQL query
        """
        pulumi.set(__self__, "type_of_data", type_of_data)
        if percentile is not None:
            pulumi.set(__self__, "percentile", percentile)
        if stream_id is not None:
            pulumi.set(__self__, "stream_id", stream_id)
        if uql is not None:
            pulumi.set(__self__, "uql", uql)

    @property
    @pulumi.getter(name="typeOfData")
    def type_of_data(self) -> str:
        """
        Type of data to filter by
        """
        return pulumi.get(self, "type_of_data")

    @property
    @pulumi.getter
    def percentile(self) -> Optional[float]:
        """
        Optional value to filter by percentiles
        """
        return pulumi.get(self, "percentile")

    @property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> Optional[str]:
        """
        ID of the metrics stream
        """
        return pulumi.get(self, "stream_id")

    @property
    @pulumi.getter
    def uql(self) -> Optional[str]:
        """
        UQL query
        """
        return pulumi.get(self, "uql")


@pulumi.output_type
class SloObjectiveCountMetricBadNewrelic(dict):
    def __init__(__self__, *,
                 nrql: str):
        """
        :param str nrql: Query for the metrics
        """
        pulumi.set(__self__, "nrql", nrql)

    @property
    @pulumi.getter
    def nrql(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "nrql")


@pulumi.output_type
class SloObjectiveCountMetricBadOpentsdb(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: Query for the metrics
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveCountMetricBadPingdom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkId":
            suggest = "check_id"
        elif key == "checkType":
            suggest = "check_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricBadPingdom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricBadPingdom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricBadPingdom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check_id: str,
                 check_type: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param str check_id: Pingdom uptime or transaction check's ID
        :param str check_type: Pingdom check type - uptime or transaction
        :param str status: Optional for the Uptime checks. Use it to filter the Pingdom check results by status
        """
        pulumi.set(__self__, "check_id", check_id)
        if check_type is not None:
            pulumi.set(__self__, "check_type", check_type)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="checkId")
    def check_id(self) -> str:
        """
        Pingdom uptime or transaction check's ID
        """
        return pulumi.get(self, "check_id")

    @property
    @pulumi.getter(name="checkType")
    def check_type(self) -> Optional[str]:
        """
        Pingdom check type - uptime or transaction
        """
        return pulumi.get(self, "check_type")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Optional for the Uptime checks. Use it to filter the Pingdom check results by status
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class SloObjectiveCountMetricBadPrometheus(dict):
    def __init__(__self__, *,
                 promql: str):
        """
        :param str promql: Query for the metrics
        """
        pulumi.set(__self__, "promql", promql)

    @property
    @pulumi.getter
    def promql(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "promql")


@pulumi.output_type
class SloObjectiveCountMetricBadRedshift(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterId":
            suggest = "cluster_id"
        elif key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricBadRedshift. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricBadRedshift.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricBadRedshift.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_id: str,
                 database_name: str,
                 query: str,
                 region: str):
        """
        :param str cluster_id: Redshift custer ID
        :param str database_name: Database name
        :param str query: Query for the metrics
        :param str region: Region of the CloudWatch instance
        """
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> str:
        """
        Redshift custer ID
        """
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Database name
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Region of the CloudWatch instance
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class SloObjectiveCountMetricBadSplunk(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: Query for the metrics
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveCountMetricBadSplunkObservability(dict):
    def __init__(__self__, *,
                 program: str):
        """
        :param str program: Query for the metrics
        """
        pulumi.set(__self__, "program", program)

    @property
    @pulumi.getter
    def program(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "program")


@pulumi.output_type
class SloObjectiveCountMetricBadSumologic(dict):
    def __init__(__self__, *,
                 query: str,
                 type: str,
                 quantization: Optional[str] = None,
                 rollup: Optional[str] = None):
        """
        :param str query: Query for the metrics
        :param str type: Sumologic source - metrics or logs
        :param str quantization: Period of data aggregation
        :param str rollup: Aggregation function - avg, sum, min, max, count, none
        """
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "type", type)
        if quantization is not None:
            pulumi.set(__self__, "quantization", quantization)
        if rollup is not None:
            pulumi.set(__self__, "rollup", rollup)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Sumologic source - metrics or logs
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def quantization(self) -> Optional[str]:
        """
        Period of data aggregation
        """
        return pulumi.get(self, "quantization")

    @property
    @pulumi.getter
    def rollup(self) -> Optional[str]:
        """
        Aggregation function - avg, sum, min, max, count, none
        """
        return pulumi.get(self, "rollup")


@pulumi.output_type
class SloObjectiveCountMetricBadThousandeye(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "testId":
            suggest = "test_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricBadThousandeye. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricBadThousandeye.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricBadThousandeye.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 test_id: int):
        """
        :param int test_id: ID of the test
        """
        pulumi.set(__self__, "test_id", test_id)

    @property
    @pulumi.getter(name="testId")
    def test_id(self) -> int:
        """
        ID of the test
        """
        return pulumi.get(self, "test_id")


@pulumi.output_type
class SloObjectiveCountMetricGood(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "amazonPrometheuses":
            suggest = "amazon_prometheuses"
        elif key == "azureMonitors":
            suggest = "azure_monitors"
        elif key == "grafanaLokis":
            suggest = "grafana_lokis"
        elif key == "splunkObservabilities":
            suggest = "splunk_observabilities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricGood. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricGood.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricGood.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amazon_prometheuses: Optional[Sequence['outputs.SloObjectiveCountMetricGoodAmazonPrometheus']] = None,
                 appdynamics: Optional[Sequence['outputs.SloObjectiveCountMetricGoodAppdynamic']] = None,
                 azure_monitors: Optional[Sequence['outputs.SloObjectiveCountMetricGoodAzureMonitor']] = None,
                 bigqueries: Optional[Sequence['outputs.SloObjectiveCountMetricGoodBigquery']] = None,
                 cloudwatches: Optional[Sequence['outputs.SloObjectiveCountMetricGoodCloudwatch']] = None,
                 datadogs: Optional[Sequence['outputs.SloObjectiveCountMetricGoodDatadog']] = None,
                 dynatraces: Optional[Sequence['outputs.SloObjectiveCountMetricGoodDynatrace']] = None,
                 elasticsearches: Optional[Sequence['outputs.SloObjectiveCountMetricGoodElasticsearch']] = None,
                 gcms: Optional[Sequence['outputs.SloObjectiveCountMetricGoodGcm']] = None,
                 grafana_lokis: Optional[Sequence['outputs.SloObjectiveCountMetricGoodGrafanaLoki']] = None,
                 graphites: Optional[Sequence['outputs.SloObjectiveCountMetricGoodGraphite']] = None,
                 honeycombs: Optional[Sequence['outputs.SloObjectiveCountMetricGoodHoneycomb']] = None,
                 influxdbs: Optional[Sequence['outputs.SloObjectiveCountMetricGoodInfluxdb']] = None,
                 instanas: Optional[Sequence['outputs.SloObjectiveCountMetricGoodInstana']] = None,
                 lightsteps: Optional[Sequence['outputs.SloObjectiveCountMetricGoodLightstep']] = None,
                 newrelics: Optional[Sequence['outputs.SloObjectiveCountMetricGoodNewrelic']] = None,
                 opentsdbs: Optional[Sequence['outputs.SloObjectiveCountMetricGoodOpentsdb']] = None,
                 pingdoms: Optional[Sequence['outputs.SloObjectiveCountMetricGoodPingdom']] = None,
                 prometheuses: Optional[Sequence['outputs.SloObjectiveCountMetricGoodPrometheus']] = None,
                 redshifts: Optional[Sequence['outputs.SloObjectiveCountMetricGoodRedshift']] = None,
                 splunk_observabilities: Optional[Sequence['outputs.SloObjectiveCountMetricGoodSplunkObservability']] = None,
                 splunks: Optional[Sequence['outputs.SloObjectiveCountMetricGoodSplunk']] = None,
                 sumologics: Optional[Sequence['outputs.SloObjectiveCountMetricGoodSumologic']] = None,
                 thousandeyes: Optional[Sequence['outputs.SloObjectiveCountMetricGoodThousandeye']] = None):
        """
        :param Sequence['SloObjectiveCountMetricGoodAmazonPrometheusArgs'] amazon_prometheuses: [Configuration documentation](https://docs.nobl9.com/Sources/Amazon_Prometheus/#creating-slos-with-ams-prometheus)
        :param Sequence['SloObjectiveCountMetricGoodAppdynamicArgs'] appdynamics: [Configuration documentation](https://docs.nobl9.com/Sources/appdynamics#creating-slos-with-appdynamics)
        :param Sequence['SloObjectiveCountMetricGoodAzureMonitorArgs'] azure_monitors: [Configuration documentation](https://docs.nobl9.com/Sources/azure-monitor#creating-slos-with-azure-monitor)
        :param Sequence['SloObjectiveCountMetricGoodBigqueryArgs'] bigqueries: [Configuration documentation](https://docs.nobl9.com/Sources/bigquery#creating-slos-with-bigquery)
        :param Sequence['SloObjectiveCountMetricGoodCloudwatchArgs'] cloudwatches: [Configuration documentation](https://docs.nobl9.com/Sources/Amazon_CloudWatch/#creating-slos-with-cloudwatch)
        :param Sequence['SloObjectiveCountMetricGoodDatadogArgs'] datadogs: [Configuration documentation](https://docs.nobl9.com/Sources/datadog#creating-slos-with-datadog)
        :param Sequence['SloObjectiveCountMetricGoodDynatraceArgs'] dynatraces: [Configuration documentation](https://docs.nobl9.com/Sources/dynatrace#creating-slos-with-dynatrace)
        :param Sequence['SloObjectiveCountMetricGoodElasticsearchArgs'] elasticsearches: [Configuration documentation](https://docs.nobl9.com/Sources/elasticsearch#creating-slos-with-elasticsearch)
        :param Sequence['SloObjectiveCountMetricGoodGcmArgs'] gcms: [Configuration documentation](https://docs.nobl9.com/Sources/google-cloud-monitoring#creating-slos-with-google-cloud-monitoring)
        :param Sequence['SloObjectiveCountMetricGoodGrafanaLokiArgs'] grafana_lokis: [Configuration documentation](https://docs.nobl9.com/Sources/grafana-loki#creating-slos-with-grafana-loki)
        :param Sequence['SloObjectiveCountMetricGoodGraphiteArgs'] graphites: [Configuration documentation](https://docs.nobl9.com/Sources/graphite#creating-slos-with-graphite)
        :param Sequence['SloObjectiveCountMetricGoodHoneycombArgs'] honeycombs: [Configuration documentation](https://docs.nobl9.com/Sources/honeycomb#creating-slos-with-honeycomb)
        :param Sequence['SloObjectiveCountMetricGoodInfluxdbArgs'] influxdbs: [Configuration documentation](https://docs.nobl9.com/Sources/influxdb#creating-slos-with-influxdb)
        :param Sequence['SloObjectiveCountMetricGoodInstanaArgs'] instanas: [Configuration documentation](https://docs.nobl9.com/Sources/instana#creating-slos-with-instana)
        :param Sequence['SloObjectiveCountMetricGoodLightstepArgs'] lightsteps: [Configuration documentation](https://docs.nobl9.com/Sources/lightstep#creating-slos-with-lightstep)
        :param Sequence['SloObjectiveCountMetricGoodNewrelicArgs'] newrelics: [Configuration documentation](https://docs.nobl9.com/Sources/new-relic#creating-slos-with-new-relic)
        :param Sequence['SloObjectiveCountMetricGoodOpentsdbArgs'] opentsdbs: [Configuration documentation](https://docs.nobl9.com/Sources/opentsdb#creating-slos-with-opentsdb)
        :param Sequence['SloObjectiveCountMetricGoodPingdomArgs'] pingdoms: [Configuration documentation](https://docs.nobl9.com/Sources/pingdom#creating-slos-with-pingdom)
        :param Sequence['SloObjectiveCountMetricGoodPrometheusArgs'] prometheuses: [Configuration documentation](https://docs.nobl9.com/Sources/prometheus#creating-slos-with-prometheus)
        :param Sequence['SloObjectiveCountMetricGoodRedshiftArgs'] redshifts: [Configuration documentation](https://docs.nobl9.com/Sources/Amazon_Redshift/#creating-slos-with-amazon-redshift)
        :param Sequence['SloObjectiveCountMetricGoodSplunkObservabilityArgs'] splunk_observabilities: [Configuration documentation](https://docs.nobl9.com/Sources/splunk#creating-slos-with-splunk-observability)
        :param Sequence['SloObjectiveCountMetricGoodSplunkArgs'] splunks: [Configuration documentation](https://docs.nobl9.com/Sources/splunk#creating-slos-with-splunk)
        :param Sequence['SloObjectiveCountMetricGoodSumologicArgs'] sumologics: [Configuration documentation](https://docs.nobl9.com/Sources/sumo-logic#creating-slos-with-sumo-logic)
        :param Sequence['SloObjectiveCountMetricGoodThousandeyeArgs'] thousandeyes: [Configuration documentation](https://docs.nobl9.com/Sources/thousandeyes#creating-slos-with-thousandeyes)
        """
        if amazon_prometheuses is not None:
            pulumi.set(__self__, "amazon_prometheuses", amazon_prometheuses)
        if appdynamics is not None:
            pulumi.set(__self__, "appdynamics", appdynamics)
        if azure_monitors is not None:
            pulumi.set(__self__, "azure_monitors", azure_monitors)
        if bigqueries is not None:
            pulumi.set(__self__, "bigqueries", bigqueries)
        if cloudwatches is not None:
            pulumi.set(__self__, "cloudwatches", cloudwatches)
        if datadogs is not None:
            pulumi.set(__self__, "datadogs", datadogs)
        if dynatraces is not None:
            pulumi.set(__self__, "dynatraces", dynatraces)
        if elasticsearches is not None:
            pulumi.set(__self__, "elasticsearches", elasticsearches)
        if gcms is not None:
            pulumi.set(__self__, "gcms", gcms)
        if grafana_lokis is not None:
            pulumi.set(__self__, "grafana_lokis", grafana_lokis)
        if graphites is not None:
            pulumi.set(__self__, "graphites", graphites)
        if honeycombs is not None:
            pulumi.set(__self__, "honeycombs", honeycombs)
        if influxdbs is not None:
            pulumi.set(__self__, "influxdbs", influxdbs)
        if instanas is not None:
            pulumi.set(__self__, "instanas", instanas)
        if lightsteps is not None:
            pulumi.set(__self__, "lightsteps", lightsteps)
        if newrelics is not None:
            pulumi.set(__self__, "newrelics", newrelics)
        if opentsdbs is not None:
            pulumi.set(__self__, "opentsdbs", opentsdbs)
        if pingdoms is not None:
            pulumi.set(__self__, "pingdoms", pingdoms)
        if prometheuses is not None:
            pulumi.set(__self__, "prometheuses", prometheuses)
        if redshifts is not None:
            pulumi.set(__self__, "redshifts", redshifts)
        if splunk_observabilities is not None:
            pulumi.set(__self__, "splunk_observabilities", splunk_observabilities)
        if splunks is not None:
            pulumi.set(__self__, "splunks", splunks)
        if sumologics is not None:
            pulumi.set(__self__, "sumologics", sumologics)
        if thousandeyes is not None:
            pulumi.set(__self__, "thousandeyes", thousandeyes)

    @property
    @pulumi.getter(name="amazonPrometheuses")
    def amazon_prometheuses(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodAmazonPrometheus']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/Amazon_Prometheus/#creating-slos-with-ams-prometheus)
        """
        return pulumi.get(self, "amazon_prometheuses")

    @property
    @pulumi.getter
    def appdynamics(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodAppdynamic']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/appdynamics#creating-slos-with-appdynamics)
        """
        return pulumi.get(self, "appdynamics")

    @property
    @pulumi.getter(name="azureMonitors")
    def azure_monitors(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodAzureMonitor']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/azure-monitor#creating-slos-with-azure-monitor)
        """
        return pulumi.get(self, "azure_monitors")

    @property
    @pulumi.getter
    def bigqueries(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodBigquery']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/bigquery#creating-slos-with-bigquery)
        """
        return pulumi.get(self, "bigqueries")

    @property
    @pulumi.getter
    def cloudwatches(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodCloudwatch']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/Amazon_CloudWatch/#creating-slos-with-cloudwatch)
        """
        return pulumi.get(self, "cloudwatches")

    @property
    @pulumi.getter
    def datadogs(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodDatadog']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/datadog#creating-slos-with-datadog)
        """
        return pulumi.get(self, "datadogs")

    @property
    @pulumi.getter
    def dynatraces(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodDynatrace']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/dynatrace#creating-slos-with-dynatrace)
        """
        return pulumi.get(self, "dynatraces")

    @property
    @pulumi.getter
    def elasticsearches(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodElasticsearch']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/elasticsearch#creating-slos-with-elasticsearch)
        """
        return pulumi.get(self, "elasticsearches")

    @property
    @pulumi.getter
    def gcms(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodGcm']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/google-cloud-monitoring#creating-slos-with-google-cloud-monitoring)
        """
        return pulumi.get(self, "gcms")

    @property
    @pulumi.getter(name="grafanaLokis")
    def grafana_lokis(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodGrafanaLoki']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/grafana-loki#creating-slos-with-grafana-loki)
        """
        return pulumi.get(self, "grafana_lokis")

    @property
    @pulumi.getter
    def graphites(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodGraphite']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/graphite#creating-slos-with-graphite)
        """
        return pulumi.get(self, "graphites")

    @property
    @pulumi.getter
    def honeycombs(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodHoneycomb']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/honeycomb#creating-slos-with-honeycomb)
        """
        return pulumi.get(self, "honeycombs")

    @property
    @pulumi.getter
    def influxdbs(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodInfluxdb']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/influxdb#creating-slos-with-influxdb)
        """
        return pulumi.get(self, "influxdbs")

    @property
    @pulumi.getter
    def instanas(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodInstana']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/instana#creating-slos-with-instana)
        """
        return pulumi.get(self, "instanas")

    @property
    @pulumi.getter
    def lightsteps(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodLightstep']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/lightstep#creating-slos-with-lightstep)
        """
        return pulumi.get(self, "lightsteps")

    @property
    @pulumi.getter
    def newrelics(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodNewrelic']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/new-relic#creating-slos-with-new-relic)
        """
        return pulumi.get(self, "newrelics")

    @property
    @pulumi.getter
    def opentsdbs(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodOpentsdb']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/opentsdb#creating-slos-with-opentsdb)
        """
        return pulumi.get(self, "opentsdbs")

    @property
    @pulumi.getter
    def pingdoms(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodPingdom']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/pingdom#creating-slos-with-pingdom)
        """
        return pulumi.get(self, "pingdoms")

    @property
    @pulumi.getter
    def prometheuses(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodPrometheus']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/prometheus#creating-slos-with-prometheus)
        """
        return pulumi.get(self, "prometheuses")

    @property
    @pulumi.getter
    def redshifts(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodRedshift']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/Amazon_Redshift/#creating-slos-with-amazon-redshift)
        """
        return pulumi.get(self, "redshifts")

    @property
    @pulumi.getter(name="splunkObservabilities")
    def splunk_observabilities(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodSplunkObservability']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/splunk#creating-slos-with-splunk-observability)
        """
        return pulumi.get(self, "splunk_observabilities")

    @property
    @pulumi.getter
    def splunks(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodSplunk']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/splunk#creating-slos-with-splunk)
        """
        return pulumi.get(self, "splunks")

    @property
    @pulumi.getter
    def sumologics(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodSumologic']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/sumo-logic#creating-slos-with-sumo-logic)
        """
        return pulumi.get(self, "sumologics")

    @property
    @pulumi.getter
    def thousandeyes(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodThousandeye']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/thousandeyes#creating-slos-with-thousandeyes)
        """
        return pulumi.get(self, "thousandeyes")


@pulumi.output_type
class SloObjectiveCountMetricGoodAmazonPrometheus(dict):
    def __init__(__self__, *,
                 promql: str):
        """
        :param str promql: Query for the metrics
        """
        pulumi.set(__self__, "promql", promql)

    @property
    @pulumi.getter
    def promql(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "promql")


@pulumi.output_type
class SloObjectiveCountMetricGoodAppdynamic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationName":
            suggest = "application_name"
        elif key == "metricPath":
            suggest = "metric_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricGoodAppdynamic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricGoodAppdynamic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricGoodAppdynamic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_name: str,
                 metric_path: str):
        """
        :param str application_name: Name of the added application
        :param str metric_path: Path to the metrics
        """
        pulumi.set(__self__, "application_name", application_name)
        pulumi.set(__self__, "metric_path", metric_path)

    @property
    @pulumi.getter(name="applicationName")
    def application_name(self) -> str:
        """
        Name of the added application
        """
        return pulumi.get(self, "application_name")

    @property
    @pulumi.getter(name="metricPath")
    def metric_path(self) -> str:
        """
        Path to the metrics
        """
        return pulumi.get(self, "metric_path")


@pulumi.output_type
class SloObjectiveCountMetricGoodAzureMonitor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"
        elif key == "kqlQuery":
            suggest = "kql_query"
        elif key == "metricName":
            suggest = "metric_name"
        elif key == "metricNamespace":
            suggest = "metric_namespace"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricGoodAzureMonitor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricGoodAzureMonitor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricGoodAzureMonitor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_type: str,
                 aggregation: Optional[str] = None,
                 dimensions: Optional[Sequence['outputs.SloObjectiveCountMetricGoodAzureMonitorDimension']] = None,
                 kql_query: Optional[str] = None,
                 metric_name: Optional[str] = None,
                 metric_namespace: Optional[str] = None,
                 resource_id: Optional[str] = None,
                 workspaces: Optional[Sequence['outputs.SloObjectiveCountMetricGoodAzureMonitorWorkspace']] = None):
        """
        :param str data_type: Specifies source: 'metrics' or 'logs'
        :param str aggregation: Aggregation type [Required for metrics]
        :param Sequence['SloObjectiveCountMetricGoodAzureMonitorDimensionArgs'] dimensions: Dimensions of the metric [Optional for metrics]
        :param str kql_query: Logs query in Kusto Query Language [Required for logs]
        :param str metric_name: Name of the metric [Required for metrics]
        :param str metric_namespace: Namespace of the metric [Optional for metrics]
        :param str resource_id: Identifier of the Azure Cloud resource [Required for metrics]
        :param Sequence['SloObjectiveCountMetricGoodAzureMonitorWorkspaceArgs'] workspaces: Log analytics workspace [Required for logs]
        """
        pulumi.set(__self__, "data_type", data_type)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if kql_query is not None:
            pulumi.set(__self__, "kql_query", kql_query)
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)
        if metric_namespace is not None:
            pulumi.set(__self__, "metric_namespace", metric_namespace)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if workspaces is not None:
            pulumi.set(__self__, "workspaces", workspaces)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> str:
        """
        Specifies source: 'metrics' or 'logs'
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[str]:
        """
        Aggregation type [Required for metrics]
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodAzureMonitorDimension']]:
        """
        Dimensions of the metric [Optional for metrics]
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="kqlQuery")
    def kql_query(self) -> Optional[str]:
        """
        Logs query in Kusto Query Language [Required for logs]
        """
        return pulumi.get(self, "kql_query")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[str]:
        """
        Name of the metric [Required for metrics]
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter(name="metricNamespace")
    def metric_namespace(self) -> Optional[str]:
        """
        Namespace of the metric [Optional for metrics]
        """
        return pulumi.get(self, "metric_namespace")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        """
        Identifier of the Azure Cloud resource [Required for metrics]
        """
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter
    def workspaces(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodAzureMonitorWorkspace']]:
        """
        Log analytics workspace [Required for logs]
        """
        return pulumi.get(self, "workspaces")


@pulumi.output_type
class SloObjectiveCountMetricGoodAzureMonitorDimension(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The name of the previously defined alert method.
        :param str value: Burn rate value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the previously defined alert method.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Burn rate value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SloObjectiveCountMetricGoodAzureMonitorWorkspace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceGroup":
            suggest = "resource_group"
        elif key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "workspaceId":
            suggest = "workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricGoodAzureMonitorWorkspace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricGoodAzureMonitorWorkspace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricGoodAzureMonitorWorkspace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_group: str,
                 subscription_id: str,
                 workspace_id: str):
        """
        :param str resource_group: Resource group of the workspace
        :param str subscription_id: Subscription ID of the workspace
        :param str workspace_id: ID of the workspace
        """
        pulumi.set(__self__, "resource_group", resource_group)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "workspace_id", workspace_id)

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> str:
        """
        Resource group of the workspace
        """
        return pulumi.get(self, "resource_group")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> str:
        """
        Subscription ID of the workspace
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> str:
        """
        ID of the workspace
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class SloObjectiveCountMetricGoodBigquery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricGoodBigquery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricGoodBigquery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricGoodBigquery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 location: str,
                 project_id: str,
                 query: str):
        """
        :param str location: Location of you BigQuery
        :param str project_id: Project ID
        :param str query: Query for the metrics
        """
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        Location of you BigQuery
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        Project ID
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveCountMetricGoodCloudwatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountId":
            suggest = "account_id"
        elif key == "metricName":
            suggest = "metric_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricGoodCloudwatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricGoodCloudwatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricGoodCloudwatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region: str,
                 account_id: Optional[str] = None,
                 dimensions: Optional[Sequence['outputs.SloObjectiveCountMetricGoodCloudwatchDimension']] = None,
                 json: Optional[str] = None,
                 metric_name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 sql: Optional[str] = None,
                 stat: Optional[str] = None):
        """
        :param str region: Region of the CloudWatch instance
        :param str account_id: AccountID used with cross-account observability feature
        :param Sequence['SloObjectiveCountMetricGoodCloudwatchDimensionArgs'] dimensions: Dimensions of the metric [Optional for metrics]
        :param str json: JSON query
        :param str metric_name: Name of the metric [Required for metrics]
        :param str namespace: Namespace of the metric
        :param str sql: SQL query
        :param str stat: Metric data aggregations
        """
        pulumi.set(__self__, "region", region)
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if json is not None:
            pulumi.set(__self__, "json", json)
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if sql is not None:
            pulumi.set(__self__, "sql", sql)
        if stat is not None:
            pulumi.set(__self__, "stat", stat)

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Region of the CloudWatch instance
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[str]:
        """
        AccountID used with cross-account observability feature
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodCloudwatchDimension']]:
        """
        Dimensions of the metric [Optional for metrics]
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def json(self) -> Optional[str]:
        """
        JSON query
        """
        return pulumi.get(self, "json")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[str]:
        """
        Name of the metric [Required for metrics]
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the metric
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def sql(self) -> Optional[str]:
        """
        SQL query
        """
        return pulumi.get(self, "sql")

    @property
    @pulumi.getter
    def stat(self) -> Optional[str]:
        """
        Metric data aggregations
        """
        return pulumi.get(self, "stat")


@pulumi.output_type
class SloObjectiveCountMetricGoodCloudwatchDimension(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The name of the previously defined alert method.
        :param str value: Burn rate value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the previously defined alert method.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Burn rate value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SloObjectiveCountMetricGoodDatadog(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: Query for the metrics
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveCountMetricGoodDynatrace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricSelector":
            suggest = "metric_selector"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricGoodDynatrace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricGoodDynatrace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricGoodDynatrace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_selector: str):
        """
        :param str metric_selector: Selector for the metrics
        """
        pulumi.set(__self__, "metric_selector", metric_selector)

    @property
    @pulumi.getter(name="metricSelector")
    def metric_selector(self) -> str:
        """
        Selector for the metrics
        """
        return pulumi.get(self, "metric_selector")


@pulumi.output_type
class SloObjectiveCountMetricGoodElasticsearch(dict):
    def __init__(__self__, *,
                 index: str,
                 query: str):
        """
        :param str index: Index of metrics we want to query
        :param str query: Query for the metrics
        """
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        Index of metrics we want to query
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveCountMetricGoodGcm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricGoodGcm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricGoodGcm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricGoodGcm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 project_id: str,
                 query: str):
        """
        :param str project_id: Project ID
        :param str query: Query for the metrics
        """
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        Project ID
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveCountMetricGoodGrafanaLoki(dict):
    def __init__(__self__, *,
                 logql: str):
        """
        :param str logql: Query for the logs
        """
        pulumi.set(__self__, "logql", logql)

    @property
    @pulumi.getter
    def logql(self) -> str:
        """
        Query for the logs
        """
        return pulumi.get(self, "logql")


@pulumi.output_type
class SloObjectiveCountMetricGoodGraphite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricPath":
            suggest = "metric_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricGoodGraphite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricGoodGraphite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricGoodGraphite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_path: str):
        """
        :param str metric_path: Path to the metrics
        """
        pulumi.set(__self__, "metric_path", metric_path)

    @property
    @pulumi.getter(name="metricPath")
    def metric_path(self) -> str:
        """
        Path to the metrics
        """
        return pulumi.get(self, "metric_path")


@pulumi.output_type
class SloObjectiveCountMetricGoodHoneycomb(dict):
    def __init__(__self__, *,
                 calculation: str,
                 attribute: Optional[str] = None):
        """
        :param str calculation: Calculation type
        :param str attribute: Column name - required for all calculation types besides 'CONCURRENCY' and 'COUNT'
        """
        pulumi.set(__self__, "calculation", calculation)
        if attribute is not None:
            pulumi.set(__self__, "attribute", attribute)

    @property
    @pulumi.getter
    def calculation(self) -> str:
        """
        Calculation type
        """
        return pulumi.get(self, "calculation")

    @property
    @pulumi.getter
    def attribute(self) -> Optional[str]:
        """
        Column name - required for all calculation types besides 'CONCURRENCY' and 'COUNT'
        """
        return pulumi.get(self, "attribute")


@pulumi.output_type
class SloObjectiveCountMetricGoodInfluxdb(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: Query for the metrics
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveCountMetricGoodInstana(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricType":
            suggest = "metric_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricGoodInstana. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricGoodInstana.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricGoodInstana.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_type: str,
                 applications: Optional[Sequence['outputs.SloObjectiveCountMetricGoodInstanaApplication']] = None,
                 infrastructures: Optional[Sequence['outputs.SloObjectiveCountMetricGoodInstanaInfrastructure']] = None):
        """
        :param str metric_type: Instana metric type 'application' or 'infrastructure'
        :param Sequence['SloObjectiveCountMetricGoodInstanaApplicationArgs'] applications: Infrastructure metric type
        :param Sequence['SloObjectiveCountMetricGoodInstanaInfrastructureArgs'] infrastructures: Infrastructure metric type
        """
        pulumi.set(__self__, "metric_type", metric_type)
        if applications is not None:
            pulumi.set(__self__, "applications", applications)
        if infrastructures is not None:
            pulumi.set(__self__, "infrastructures", infrastructures)

    @property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> str:
        """
        Instana metric type 'application' or 'infrastructure'
        """
        return pulumi.get(self, "metric_type")

    @property
    @pulumi.getter
    def applications(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodInstanaApplication']]:
        """
        Infrastructure metric type
        """
        return pulumi.get(self, "applications")

    @property
    @pulumi.getter
    def infrastructures(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricGoodInstanaInfrastructure']]:
        """
        Infrastructure metric type
        """
        return pulumi.get(self, "infrastructures")


@pulumi.output_type
class SloObjectiveCountMetricGoodInstanaApplication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiQuery":
            suggest = "api_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "metricId":
            suggest = "metric_id"
        elif key == "includeInternal":
            suggest = "include_internal"
        elif key == "includeSynthetic":
            suggest = "include_synthetic"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricGoodInstanaApplication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricGoodInstanaApplication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricGoodInstanaApplication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation: str,
                 api_query: str,
                 group_bies: Sequence['outputs.SloObjectiveCountMetricGoodInstanaApplicationGroupBy'],
                 metric_id: str,
                 include_internal: Optional[bool] = None,
                 include_synthetic: Optional[bool] = None):
        """
        :param str aggregation: Aggregation type [Required for metrics]
        :param str api_query: API query user passes in a JSON format
        :param Sequence['SloObjectiveCountMetricGoodInstanaApplicationGroupByArgs'] group_bies: Group by method
        :param str metric_id: Metric ID one of 'calls', 'erroneousCalls', 'errors', 'latency'
        :param bool include_internal: Include internal
        :param bool include_synthetic: Include synthetic
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "api_query", api_query)
        pulumi.set(__self__, "group_bies", group_bies)
        pulumi.set(__self__, "metric_id", metric_id)
        if include_internal is not None:
            pulumi.set(__self__, "include_internal", include_internal)
        if include_synthetic is not None:
            pulumi.set(__self__, "include_synthetic", include_synthetic)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        Aggregation type [Required for metrics]
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="apiQuery")
    def api_query(self) -> str:
        """
        API query user passes in a JSON format
        """
        return pulumi.get(self, "api_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Sequence['outputs.SloObjectiveCountMetricGoodInstanaApplicationGroupBy']:
        """
        Group by method
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="metricId")
    def metric_id(self) -> str:
        """
        Metric ID one of 'calls', 'erroneousCalls', 'errors', 'latency'
        """
        return pulumi.get(self, "metric_id")

    @property
    @pulumi.getter(name="includeInternal")
    def include_internal(self) -> Optional[bool]:
        """
        Include internal
        """
        return pulumi.get(self, "include_internal")

    @property
    @pulumi.getter(name="includeSynthetic")
    def include_synthetic(self) -> Optional[bool]:
        """
        Include synthetic
        """
        return pulumi.get(self, "include_synthetic")


@pulumi.output_type
class SloObjectiveCountMetricGoodInstanaApplicationGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagEntity":
            suggest = "tag_entity"
        elif key == "tagSecondLevelKey":
            suggest = "tag_second_level_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricGoodInstanaApplicationGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricGoodInstanaApplicationGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricGoodInstanaApplicationGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tag: str,
                 tag_entity: str,
                 tag_second_level_key: Optional[str] = None):
        """
        :param str tag: Group by tag
        :param str tag_entity: Tag entity - one of 'DESTINATION', 'SOURCE', 'NOT_APPLICABLE'
        """
        pulumi.set(__self__, "tag", tag)
        pulumi.set(__self__, "tag_entity", tag_entity)
        if tag_second_level_key is not None:
            pulumi.set(__self__, "tag_second_level_key", tag_second_level_key)

    @property
    @pulumi.getter
    def tag(self) -> str:
        """
        Group by tag
        """
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter(name="tagEntity")
    def tag_entity(self) -> str:
        """
        Tag entity - one of 'DESTINATION', 'SOURCE', 'NOT_APPLICABLE'
        """
        return pulumi.get(self, "tag_entity")

    @property
    @pulumi.getter(name="tagSecondLevelKey")
    def tag_second_level_key(self) -> Optional[str]:
        return pulumi.get(self, "tag_second_level_key")


@pulumi.output_type
class SloObjectiveCountMetricGoodInstanaInfrastructure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricId":
            suggest = "metric_id"
        elif key == "metricRetrievalMethod":
            suggest = "metric_retrieval_method"
        elif key == "pluginId":
            suggest = "plugin_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricGoodInstanaInfrastructure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricGoodInstanaInfrastructure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricGoodInstanaInfrastructure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_id: str,
                 metric_retrieval_method: str,
                 plugin_id: str,
                 query: Optional[str] = None,
                 snapshot_id: Optional[str] = None):
        """
        :param str metric_id: Metric ID one of 'calls', 'erroneousCalls', 'errors', 'latency'
        :param str metric_retrieval_method: Metric retrieval method 'query' or 'snapshot'
        :param str plugin_id: Plugin ID
        :param str query: Query for the metrics
        :param str snapshot_id: Snapshot ID
        """
        pulumi.set(__self__, "metric_id", metric_id)
        pulumi.set(__self__, "metric_retrieval_method", metric_retrieval_method)
        pulumi.set(__self__, "plugin_id", plugin_id)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)

    @property
    @pulumi.getter(name="metricId")
    def metric_id(self) -> str:
        """
        Metric ID one of 'calls', 'erroneousCalls', 'errors', 'latency'
        """
        return pulumi.get(self, "metric_id")

    @property
    @pulumi.getter(name="metricRetrievalMethod")
    def metric_retrieval_method(self) -> str:
        """
        Metric retrieval method 'query' or 'snapshot'
        """
        return pulumi.get(self, "metric_retrieval_method")

    @property
    @pulumi.getter(name="pluginId")
    def plugin_id(self) -> str:
        """
        Plugin ID
        """
        return pulumi.get(self, "plugin_id")

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        """
        Snapshot ID
        """
        return pulumi.get(self, "snapshot_id")


@pulumi.output_type
class SloObjectiveCountMetricGoodLightstep(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeOfData":
            suggest = "type_of_data"
        elif key == "streamId":
            suggest = "stream_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricGoodLightstep. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricGoodLightstep.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricGoodLightstep.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type_of_data: str,
                 percentile: Optional[float] = None,
                 stream_id: Optional[str] = None,
                 uql: Optional[str] = None):
        """
        :param str type_of_data: Type of data to filter by
        :param float percentile: Optional value to filter by percentiles
        :param str stream_id: ID of the metrics stream
        :param str uql: UQL query
        """
        pulumi.set(__self__, "type_of_data", type_of_data)
        if percentile is not None:
            pulumi.set(__self__, "percentile", percentile)
        if stream_id is not None:
            pulumi.set(__self__, "stream_id", stream_id)
        if uql is not None:
            pulumi.set(__self__, "uql", uql)

    @property
    @pulumi.getter(name="typeOfData")
    def type_of_data(self) -> str:
        """
        Type of data to filter by
        """
        return pulumi.get(self, "type_of_data")

    @property
    @pulumi.getter
    def percentile(self) -> Optional[float]:
        """
        Optional value to filter by percentiles
        """
        return pulumi.get(self, "percentile")

    @property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> Optional[str]:
        """
        ID of the metrics stream
        """
        return pulumi.get(self, "stream_id")

    @property
    @pulumi.getter
    def uql(self) -> Optional[str]:
        """
        UQL query
        """
        return pulumi.get(self, "uql")


@pulumi.output_type
class SloObjectiveCountMetricGoodNewrelic(dict):
    def __init__(__self__, *,
                 nrql: str):
        """
        :param str nrql: Query for the metrics
        """
        pulumi.set(__self__, "nrql", nrql)

    @property
    @pulumi.getter
    def nrql(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "nrql")


@pulumi.output_type
class SloObjectiveCountMetricGoodOpentsdb(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: Query for the metrics
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveCountMetricGoodPingdom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkId":
            suggest = "check_id"
        elif key == "checkType":
            suggest = "check_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricGoodPingdom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricGoodPingdom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricGoodPingdom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check_id: str,
                 check_type: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param str check_id: Pingdom uptime or transaction check's ID
        :param str check_type: Pingdom check type - uptime or transaction
        :param str status: Optional for the Uptime checks. Use it to filter the Pingdom check results by status
        """
        pulumi.set(__self__, "check_id", check_id)
        if check_type is not None:
            pulumi.set(__self__, "check_type", check_type)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="checkId")
    def check_id(self) -> str:
        """
        Pingdom uptime or transaction check's ID
        """
        return pulumi.get(self, "check_id")

    @property
    @pulumi.getter(name="checkType")
    def check_type(self) -> Optional[str]:
        """
        Pingdom check type - uptime or transaction
        """
        return pulumi.get(self, "check_type")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Optional for the Uptime checks. Use it to filter the Pingdom check results by status
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class SloObjectiveCountMetricGoodPrometheus(dict):
    def __init__(__self__, *,
                 promql: str):
        """
        :param str promql: Query for the metrics
        """
        pulumi.set(__self__, "promql", promql)

    @property
    @pulumi.getter
    def promql(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "promql")


@pulumi.output_type
class SloObjectiveCountMetricGoodRedshift(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterId":
            suggest = "cluster_id"
        elif key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricGoodRedshift. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricGoodRedshift.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricGoodRedshift.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_id: str,
                 database_name: str,
                 query: str,
                 region: str):
        """
        :param str cluster_id: Redshift custer ID
        :param str database_name: Database name
        :param str query: Query for the metrics
        :param str region: Region of the CloudWatch instance
        """
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> str:
        """
        Redshift custer ID
        """
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Database name
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Region of the CloudWatch instance
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class SloObjectiveCountMetricGoodSplunk(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: Query for the metrics
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveCountMetricGoodSplunkObservability(dict):
    def __init__(__self__, *,
                 program: str):
        """
        :param str program: Query for the metrics
        """
        pulumi.set(__self__, "program", program)

    @property
    @pulumi.getter
    def program(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "program")


@pulumi.output_type
class SloObjectiveCountMetricGoodSumologic(dict):
    def __init__(__self__, *,
                 query: str,
                 type: str,
                 quantization: Optional[str] = None,
                 rollup: Optional[str] = None):
        """
        :param str query: Query for the metrics
        :param str type: Sumologic source - metrics or logs
        :param str quantization: Period of data aggregation
        :param str rollup: Aggregation function - avg, sum, min, max, count, none
        """
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "type", type)
        if quantization is not None:
            pulumi.set(__self__, "quantization", quantization)
        if rollup is not None:
            pulumi.set(__self__, "rollup", rollup)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Sumologic source - metrics or logs
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def quantization(self) -> Optional[str]:
        """
        Period of data aggregation
        """
        return pulumi.get(self, "quantization")

    @property
    @pulumi.getter
    def rollup(self) -> Optional[str]:
        """
        Aggregation function - avg, sum, min, max, count, none
        """
        return pulumi.get(self, "rollup")


@pulumi.output_type
class SloObjectiveCountMetricGoodThousandeye(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "testId":
            suggest = "test_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricGoodThousandeye. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricGoodThousandeye.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricGoodThousandeye.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 test_id: int):
        """
        :param int test_id: ID of the test
        """
        pulumi.set(__self__, "test_id", test_id)

    @property
    @pulumi.getter(name="testId")
    def test_id(self) -> int:
        """
        ID of the test
        """
        return pulumi.get(self, "test_id")


@pulumi.output_type
class SloObjectiveCountMetricTotal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "amazonPrometheuses":
            suggest = "amazon_prometheuses"
        elif key == "azureMonitors":
            suggest = "azure_monitors"
        elif key == "grafanaLokis":
            suggest = "grafana_lokis"
        elif key == "splunkObservabilities":
            suggest = "splunk_observabilities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricTotal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricTotal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricTotal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amazon_prometheuses: Optional[Sequence['outputs.SloObjectiveCountMetricTotalAmazonPrometheus']] = None,
                 appdynamics: Optional[Sequence['outputs.SloObjectiveCountMetricTotalAppdynamic']] = None,
                 azure_monitors: Optional[Sequence['outputs.SloObjectiveCountMetricTotalAzureMonitor']] = None,
                 bigqueries: Optional[Sequence['outputs.SloObjectiveCountMetricTotalBigquery']] = None,
                 cloudwatches: Optional[Sequence['outputs.SloObjectiveCountMetricTotalCloudwatch']] = None,
                 datadogs: Optional[Sequence['outputs.SloObjectiveCountMetricTotalDatadog']] = None,
                 dynatraces: Optional[Sequence['outputs.SloObjectiveCountMetricTotalDynatrace']] = None,
                 elasticsearches: Optional[Sequence['outputs.SloObjectiveCountMetricTotalElasticsearch']] = None,
                 gcms: Optional[Sequence['outputs.SloObjectiveCountMetricTotalGcm']] = None,
                 grafana_lokis: Optional[Sequence['outputs.SloObjectiveCountMetricTotalGrafanaLoki']] = None,
                 graphites: Optional[Sequence['outputs.SloObjectiveCountMetricTotalGraphite']] = None,
                 honeycombs: Optional[Sequence['outputs.SloObjectiveCountMetricTotalHoneycomb']] = None,
                 influxdbs: Optional[Sequence['outputs.SloObjectiveCountMetricTotalInfluxdb']] = None,
                 instanas: Optional[Sequence['outputs.SloObjectiveCountMetricTotalInstana']] = None,
                 lightsteps: Optional[Sequence['outputs.SloObjectiveCountMetricTotalLightstep']] = None,
                 newrelics: Optional[Sequence['outputs.SloObjectiveCountMetricTotalNewrelic']] = None,
                 opentsdbs: Optional[Sequence['outputs.SloObjectiveCountMetricTotalOpentsdb']] = None,
                 pingdoms: Optional[Sequence['outputs.SloObjectiveCountMetricTotalPingdom']] = None,
                 prometheuses: Optional[Sequence['outputs.SloObjectiveCountMetricTotalPrometheus']] = None,
                 redshifts: Optional[Sequence['outputs.SloObjectiveCountMetricTotalRedshift']] = None,
                 splunk_observabilities: Optional[Sequence['outputs.SloObjectiveCountMetricTotalSplunkObservability']] = None,
                 splunks: Optional[Sequence['outputs.SloObjectiveCountMetricTotalSplunk']] = None,
                 sumologics: Optional[Sequence['outputs.SloObjectiveCountMetricTotalSumologic']] = None,
                 thousandeyes: Optional[Sequence['outputs.SloObjectiveCountMetricTotalThousandeye']] = None):
        """
        :param Sequence['SloObjectiveCountMetricTotalAmazonPrometheusArgs'] amazon_prometheuses: [Configuration documentation](https://docs.nobl9.com/Sources/Amazon_Prometheus/#creating-slos-with-ams-prometheus)
        :param Sequence['SloObjectiveCountMetricTotalAppdynamicArgs'] appdynamics: [Configuration documentation](https://docs.nobl9.com/Sources/appdynamics#creating-slos-with-appdynamics)
        :param Sequence['SloObjectiveCountMetricTotalAzureMonitorArgs'] azure_monitors: [Configuration documentation](https://docs.nobl9.com/Sources/azure-monitor#creating-slos-with-azure-monitor)
        :param Sequence['SloObjectiveCountMetricTotalBigqueryArgs'] bigqueries: [Configuration documentation](https://docs.nobl9.com/Sources/bigquery#creating-slos-with-bigquery)
        :param Sequence['SloObjectiveCountMetricTotalCloudwatchArgs'] cloudwatches: [Configuration documentation](https://docs.nobl9.com/Sources/Amazon_CloudWatch/#creating-slos-with-cloudwatch)
        :param Sequence['SloObjectiveCountMetricTotalDatadogArgs'] datadogs: [Configuration documentation](https://docs.nobl9.com/Sources/datadog#creating-slos-with-datadog)
        :param Sequence['SloObjectiveCountMetricTotalDynatraceArgs'] dynatraces: [Configuration documentation](https://docs.nobl9.com/Sources/dynatrace#creating-slos-with-dynatrace)
        :param Sequence['SloObjectiveCountMetricTotalElasticsearchArgs'] elasticsearches: [Configuration documentation](https://docs.nobl9.com/Sources/elasticsearch#creating-slos-with-elasticsearch)
        :param Sequence['SloObjectiveCountMetricTotalGcmArgs'] gcms: [Configuration documentation](https://docs.nobl9.com/Sources/google-cloud-monitoring#creating-slos-with-google-cloud-monitoring)
        :param Sequence['SloObjectiveCountMetricTotalGrafanaLokiArgs'] grafana_lokis: [Configuration documentation](https://docs.nobl9.com/Sources/grafana-loki#creating-slos-with-grafana-loki)
        :param Sequence['SloObjectiveCountMetricTotalGraphiteArgs'] graphites: [Configuration documentation](https://docs.nobl9.com/Sources/graphite#creating-slos-with-graphite)
        :param Sequence['SloObjectiveCountMetricTotalHoneycombArgs'] honeycombs: [Configuration documentation](https://docs.nobl9.com/Sources/honeycomb#creating-slos-with-honeycomb)
        :param Sequence['SloObjectiveCountMetricTotalInfluxdbArgs'] influxdbs: [Configuration documentation](https://docs.nobl9.com/Sources/influxdb#creating-slos-with-influxdb)
        :param Sequence['SloObjectiveCountMetricTotalInstanaArgs'] instanas: [Configuration documentation](https://docs.nobl9.com/Sources/instana#creating-slos-with-instana)
        :param Sequence['SloObjectiveCountMetricTotalLightstepArgs'] lightsteps: [Configuration documentation](https://docs.nobl9.com/Sources/lightstep#creating-slos-with-lightstep)
        :param Sequence['SloObjectiveCountMetricTotalNewrelicArgs'] newrelics: [Configuration documentation](https://docs.nobl9.com/Sources/new-relic#creating-slos-with-new-relic)
        :param Sequence['SloObjectiveCountMetricTotalOpentsdbArgs'] opentsdbs: [Configuration documentation](https://docs.nobl9.com/Sources/opentsdb#creating-slos-with-opentsdb)
        :param Sequence['SloObjectiveCountMetricTotalPingdomArgs'] pingdoms: [Configuration documentation](https://docs.nobl9.com/Sources/pingdom#creating-slos-with-pingdom)
        :param Sequence['SloObjectiveCountMetricTotalPrometheusArgs'] prometheuses: [Configuration documentation](https://docs.nobl9.com/Sources/prometheus#creating-slos-with-prometheus)
        :param Sequence['SloObjectiveCountMetricTotalRedshiftArgs'] redshifts: [Configuration documentation](https://docs.nobl9.com/Sources/Amazon_Redshift/#creating-slos-with-amazon-redshift)
        :param Sequence['SloObjectiveCountMetricTotalSplunkObservabilityArgs'] splunk_observabilities: [Configuration documentation](https://docs.nobl9.com/Sources/splunk#creating-slos-with-splunk-observability)
        :param Sequence['SloObjectiveCountMetricTotalSplunkArgs'] splunks: [Configuration documentation](https://docs.nobl9.com/Sources/splunk#creating-slos-with-splunk)
        :param Sequence['SloObjectiveCountMetricTotalSumologicArgs'] sumologics: [Configuration documentation](https://docs.nobl9.com/Sources/sumo-logic#creating-slos-with-sumo-logic)
        :param Sequence['SloObjectiveCountMetricTotalThousandeyeArgs'] thousandeyes: [Configuration documentation](https://docs.nobl9.com/Sources/thousandeyes#creating-slos-with-thousandeyes)
        """
        if amazon_prometheuses is not None:
            pulumi.set(__self__, "amazon_prometheuses", amazon_prometheuses)
        if appdynamics is not None:
            pulumi.set(__self__, "appdynamics", appdynamics)
        if azure_monitors is not None:
            pulumi.set(__self__, "azure_monitors", azure_monitors)
        if bigqueries is not None:
            pulumi.set(__self__, "bigqueries", bigqueries)
        if cloudwatches is not None:
            pulumi.set(__self__, "cloudwatches", cloudwatches)
        if datadogs is not None:
            pulumi.set(__self__, "datadogs", datadogs)
        if dynatraces is not None:
            pulumi.set(__self__, "dynatraces", dynatraces)
        if elasticsearches is not None:
            pulumi.set(__self__, "elasticsearches", elasticsearches)
        if gcms is not None:
            pulumi.set(__self__, "gcms", gcms)
        if grafana_lokis is not None:
            pulumi.set(__self__, "grafana_lokis", grafana_lokis)
        if graphites is not None:
            pulumi.set(__self__, "graphites", graphites)
        if honeycombs is not None:
            pulumi.set(__self__, "honeycombs", honeycombs)
        if influxdbs is not None:
            pulumi.set(__self__, "influxdbs", influxdbs)
        if instanas is not None:
            pulumi.set(__self__, "instanas", instanas)
        if lightsteps is not None:
            pulumi.set(__self__, "lightsteps", lightsteps)
        if newrelics is not None:
            pulumi.set(__self__, "newrelics", newrelics)
        if opentsdbs is not None:
            pulumi.set(__self__, "opentsdbs", opentsdbs)
        if pingdoms is not None:
            pulumi.set(__self__, "pingdoms", pingdoms)
        if prometheuses is not None:
            pulumi.set(__self__, "prometheuses", prometheuses)
        if redshifts is not None:
            pulumi.set(__self__, "redshifts", redshifts)
        if splunk_observabilities is not None:
            pulumi.set(__self__, "splunk_observabilities", splunk_observabilities)
        if splunks is not None:
            pulumi.set(__self__, "splunks", splunks)
        if sumologics is not None:
            pulumi.set(__self__, "sumologics", sumologics)
        if thousandeyes is not None:
            pulumi.set(__self__, "thousandeyes", thousandeyes)

    @property
    @pulumi.getter(name="amazonPrometheuses")
    def amazon_prometheuses(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalAmazonPrometheus']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/Amazon_Prometheus/#creating-slos-with-ams-prometheus)
        """
        return pulumi.get(self, "amazon_prometheuses")

    @property
    @pulumi.getter
    def appdynamics(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalAppdynamic']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/appdynamics#creating-slos-with-appdynamics)
        """
        return pulumi.get(self, "appdynamics")

    @property
    @pulumi.getter(name="azureMonitors")
    def azure_monitors(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalAzureMonitor']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/azure-monitor#creating-slos-with-azure-monitor)
        """
        return pulumi.get(self, "azure_monitors")

    @property
    @pulumi.getter
    def bigqueries(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalBigquery']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/bigquery#creating-slos-with-bigquery)
        """
        return pulumi.get(self, "bigqueries")

    @property
    @pulumi.getter
    def cloudwatches(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalCloudwatch']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/Amazon_CloudWatch/#creating-slos-with-cloudwatch)
        """
        return pulumi.get(self, "cloudwatches")

    @property
    @pulumi.getter
    def datadogs(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalDatadog']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/datadog#creating-slos-with-datadog)
        """
        return pulumi.get(self, "datadogs")

    @property
    @pulumi.getter
    def dynatraces(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalDynatrace']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/dynatrace#creating-slos-with-dynatrace)
        """
        return pulumi.get(self, "dynatraces")

    @property
    @pulumi.getter
    def elasticsearches(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalElasticsearch']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/elasticsearch#creating-slos-with-elasticsearch)
        """
        return pulumi.get(self, "elasticsearches")

    @property
    @pulumi.getter
    def gcms(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalGcm']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/google-cloud-monitoring#creating-slos-with-google-cloud-monitoring)
        """
        return pulumi.get(self, "gcms")

    @property
    @pulumi.getter(name="grafanaLokis")
    def grafana_lokis(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalGrafanaLoki']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/grafana-loki#creating-slos-with-grafana-loki)
        """
        return pulumi.get(self, "grafana_lokis")

    @property
    @pulumi.getter
    def graphites(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalGraphite']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/graphite#creating-slos-with-graphite)
        """
        return pulumi.get(self, "graphites")

    @property
    @pulumi.getter
    def honeycombs(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalHoneycomb']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/honeycomb#creating-slos-with-honeycomb)
        """
        return pulumi.get(self, "honeycombs")

    @property
    @pulumi.getter
    def influxdbs(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalInfluxdb']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/influxdb#creating-slos-with-influxdb)
        """
        return pulumi.get(self, "influxdbs")

    @property
    @pulumi.getter
    def instanas(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalInstana']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/instana#creating-slos-with-instana)
        """
        return pulumi.get(self, "instanas")

    @property
    @pulumi.getter
    def lightsteps(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalLightstep']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/lightstep#creating-slos-with-lightstep)
        """
        return pulumi.get(self, "lightsteps")

    @property
    @pulumi.getter
    def newrelics(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalNewrelic']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/new-relic#creating-slos-with-new-relic)
        """
        return pulumi.get(self, "newrelics")

    @property
    @pulumi.getter
    def opentsdbs(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalOpentsdb']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/opentsdb#creating-slos-with-opentsdb)
        """
        return pulumi.get(self, "opentsdbs")

    @property
    @pulumi.getter
    def pingdoms(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalPingdom']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/pingdom#creating-slos-with-pingdom)
        """
        return pulumi.get(self, "pingdoms")

    @property
    @pulumi.getter
    def prometheuses(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalPrometheus']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/prometheus#creating-slos-with-prometheus)
        """
        return pulumi.get(self, "prometheuses")

    @property
    @pulumi.getter
    def redshifts(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalRedshift']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/Amazon_Redshift/#creating-slos-with-amazon-redshift)
        """
        return pulumi.get(self, "redshifts")

    @property
    @pulumi.getter(name="splunkObservabilities")
    def splunk_observabilities(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalSplunkObservability']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/splunk#creating-slos-with-splunk-observability)
        """
        return pulumi.get(self, "splunk_observabilities")

    @property
    @pulumi.getter
    def splunks(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalSplunk']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/splunk#creating-slos-with-splunk)
        """
        return pulumi.get(self, "splunks")

    @property
    @pulumi.getter
    def sumologics(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalSumologic']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/sumo-logic#creating-slos-with-sumo-logic)
        """
        return pulumi.get(self, "sumologics")

    @property
    @pulumi.getter
    def thousandeyes(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalThousandeye']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/thousandeyes#creating-slos-with-thousandeyes)
        """
        return pulumi.get(self, "thousandeyes")


@pulumi.output_type
class SloObjectiveCountMetricTotalAmazonPrometheus(dict):
    def __init__(__self__, *,
                 promql: str):
        """
        :param str promql: Query for the metrics
        """
        pulumi.set(__self__, "promql", promql)

    @property
    @pulumi.getter
    def promql(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "promql")


@pulumi.output_type
class SloObjectiveCountMetricTotalAppdynamic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationName":
            suggest = "application_name"
        elif key == "metricPath":
            suggest = "metric_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricTotalAppdynamic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricTotalAppdynamic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricTotalAppdynamic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_name: str,
                 metric_path: str):
        """
        :param str application_name: Name of the added application
        :param str metric_path: Path to the metrics
        """
        pulumi.set(__self__, "application_name", application_name)
        pulumi.set(__self__, "metric_path", metric_path)

    @property
    @pulumi.getter(name="applicationName")
    def application_name(self) -> str:
        """
        Name of the added application
        """
        return pulumi.get(self, "application_name")

    @property
    @pulumi.getter(name="metricPath")
    def metric_path(self) -> str:
        """
        Path to the metrics
        """
        return pulumi.get(self, "metric_path")


@pulumi.output_type
class SloObjectiveCountMetricTotalAzureMonitor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"
        elif key == "kqlQuery":
            suggest = "kql_query"
        elif key == "metricName":
            suggest = "metric_name"
        elif key == "metricNamespace":
            suggest = "metric_namespace"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricTotalAzureMonitor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricTotalAzureMonitor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricTotalAzureMonitor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_type: str,
                 aggregation: Optional[str] = None,
                 dimensions: Optional[Sequence['outputs.SloObjectiveCountMetricTotalAzureMonitorDimension']] = None,
                 kql_query: Optional[str] = None,
                 metric_name: Optional[str] = None,
                 metric_namespace: Optional[str] = None,
                 resource_id: Optional[str] = None,
                 workspaces: Optional[Sequence['outputs.SloObjectiveCountMetricTotalAzureMonitorWorkspace']] = None):
        """
        :param str data_type: Specifies source: 'metrics' or 'logs'
        :param str aggregation: Aggregation type [Required for metrics]
        :param Sequence['SloObjectiveCountMetricTotalAzureMonitorDimensionArgs'] dimensions: Dimensions of the metric [Optional for metrics]
        :param str kql_query: Logs query in Kusto Query Language [Required for logs]
        :param str metric_name: Name of the metric [Required for metrics]
        :param str metric_namespace: Namespace of the metric [Optional for metrics]
        :param str resource_id: Identifier of the Azure Cloud resource [Required for metrics]
        :param Sequence['SloObjectiveCountMetricTotalAzureMonitorWorkspaceArgs'] workspaces: Log analytics workspace [Required for logs]
        """
        pulumi.set(__self__, "data_type", data_type)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if kql_query is not None:
            pulumi.set(__self__, "kql_query", kql_query)
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)
        if metric_namespace is not None:
            pulumi.set(__self__, "metric_namespace", metric_namespace)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if workspaces is not None:
            pulumi.set(__self__, "workspaces", workspaces)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> str:
        """
        Specifies source: 'metrics' or 'logs'
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[str]:
        """
        Aggregation type [Required for metrics]
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalAzureMonitorDimension']]:
        """
        Dimensions of the metric [Optional for metrics]
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="kqlQuery")
    def kql_query(self) -> Optional[str]:
        """
        Logs query in Kusto Query Language [Required for logs]
        """
        return pulumi.get(self, "kql_query")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[str]:
        """
        Name of the metric [Required for metrics]
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter(name="metricNamespace")
    def metric_namespace(self) -> Optional[str]:
        """
        Namespace of the metric [Optional for metrics]
        """
        return pulumi.get(self, "metric_namespace")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        """
        Identifier of the Azure Cloud resource [Required for metrics]
        """
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter
    def workspaces(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalAzureMonitorWorkspace']]:
        """
        Log analytics workspace [Required for logs]
        """
        return pulumi.get(self, "workspaces")


@pulumi.output_type
class SloObjectiveCountMetricTotalAzureMonitorDimension(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The name of the previously defined alert method.
        :param str value: Burn rate value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the previously defined alert method.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Burn rate value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SloObjectiveCountMetricTotalAzureMonitorWorkspace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceGroup":
            suggest = "resource_group"
        elif key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "workspaceId":
            suggest = "workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricTotalAzureMonitorWorkspace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricTotalAzureMonitorWorkspace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricTotalAzureMonitorWorkspace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_group: str,
                 subscription_id: str,
                 workspace_id: str):
        """
        :param str resource_group: Resource group of the workspace
        :param str subscription_id: Subscription ID of the workspace
        :param str workspace_id: ID of the workspace
        """
        pulumi.set(__self__, "resource_group", resource_group)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "workspace_id", workspace_id)

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> str:
        """
        Resource group of the workspace
        """
        return pulumi.get(self, "resource_group")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> str:
        """
        Subscription ID of the workspace
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> str:
        """
        ID of the workspace
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class SloObjectiveCountMetricTotalBigquery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricTotalBigquery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricTotalBigquery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricTotalBigquery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 location: str,
                 project_id: str,
                 query: str):
        """
        :param str location: Location of you BigQuery
        :param str project_id: Project ID
        :param str query: Query for the metrics
        """
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        Location of you BigQuery
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        Project ID
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveCountMetricTotalCloudwatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountId":
            suggest = "account_id"
        elif key == "metricName":
            suggest = "metric_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricTotalCloudwatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricTotalCloudwatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricTotalCloudwatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region: str,
                 account_id: Optional[str] = None,
                 dimensions: Optional[Sequence['outputs.SloObjectiveCountMetricTotalCloudwatchDimension']] = None,
                 json: Optional[str] = None,
                 metric_name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 sql: Optional[str] = None,
                 stat: Optional[str] = None):
        """
        :param str region: Region of the CloudWatch instance
        :param str account_id: AccountID used with cross-account observability feature
        :param Sequence['SloObjectiveCountMetricTotalCloudwatchDimensionArgs'] dimensions: Dimensions of the metric [Optional for metrics]
        :param str json: JSON query
        :param str metric_name: Name of the metric [Required for metrics]
        :param str namespace: Namespace of the metric
        :param str sql: SQL query
        :param str stat: Metric data aggregations
        """
        pulumi.set(__self__, "region", region)
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if json is not None:
            pulumi.set(__self__, "json", json)
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if sql is not None:
            pulumi.set(__self__, "sql", sql)
        if stat is not None:
            pulumi.set(__self__, "stat", stat)

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Region of the CloudWatch instance
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[str]:
        """
        AccountID used with cross-account observability feature
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalCloudwatchDimension']]:
        """
        Dimensions of the metric [Optional for metrics]
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def json(self) -> Optional[str]:
        """
        JSON query
        """
        return pulumi.get(self, "json")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[str]:
        """
        Name of the metric [Required for metrics]
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the metric
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def sql(self) -> Optional[str]:
        """
        SQL query
        """
        return pulumi.get(self, "sql")

    @property
    @pulumi.getter
    def stat(self) -> Optional[str]:
        """
        Metric data aggregations
        """
        return pulumi.get(self, "stat")


@pulumi.output_type
class SloObjectiveCountMetricTotalCloudwatchDimension(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The name of the previously defined alert method.
        :param str value: Burn rate value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the previously defined alert method.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Burn rate value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SloObjectiveCountMetricTotalDatadog(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: Query for the metrics
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveCountMetricTotalDynatrace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricSelector":
            suggest = "metric_selector"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricTotalDynatrace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricTotalDynatrace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricTotalDynatrace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_selector: str):
        """
        :param str metric_selector: Selector for the metrics
        """
        pulumi.set(__self__, "metric_selector", metric_selector)

    @property
    @pulumi.getter(name="metricSelector")
    def metric_selector(self) -> str:
        """
        Selector for the metrics
        """
        return pulumi.get(self, "metric_selector")


@pulumi.output_type
class SloObjectiveCountMetricTotalElasticsearch(dict):
    def __init__(__self__, *,
                 index: str,
                 query: str):
        """
        :param str index: Index of metrics we want to query
        :param str query: Query for the metrics
        """
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        Index of metrics we want to query
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveCountMetricTotalGcm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricTotalGcm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricTotalGcm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricTotalGcm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 project_id: str,
                 query: str):
        """
        :param str project_id: Project ID
        :param str query: Query for the metrics
        """
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        Project ID
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveCountMetricTotalGrafanaLoki(dict):
    def __init__(__self__, *,
                 logql: str):
        """
        :param str logql: Query for the logs
        """
        pulumi.set(__self__, "logql", logql)

    @property
    @pulumi.getter
    def logql(self) -> str:
        """
        Query for the logs
        """
        return pulumi.get(self, "logql")


@pulumi.output_type
class SloObjectiveCountMetricTotalGraphite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricPath":
            suggest = "metric_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricTotalGraphite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricTotalGraphite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricTotalGraphite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_path: str):
        """
        :param str metric_path: Path to the metrics
        """
        pulumi.set(__self__, "metric_path", metric_path)

    @property
    @pulumi.getter(name="metricPath")
    def metric_path(self) -> str:
        """
        Path to the metrics
        """
        return pulumi.get(self, "metric_path")


@pulumi.output_type
class SloObjectiveCountMetricTotalHoneycomb(dict):
    def __init__(__self__, *,
                 calculation: str,
                 attribute: Optional[str] = None):
        """
        :param str calculation: Calculation type
        :param str attribute: Column name - required for all calculation types besides 'CONCURRENCY' and 'COUNT'
        """
        pulumi.set(__self__, "calculation", calculation)
        if attribute is not None:
            pulumi.set(__self__, "attribute", attribute)

    @property
    @pulumi.getter
    def calculation(self) -> str:
        """
        Calculation type
        """
        return pulumi.get(self, "calculation")

    @property
    @pulumi.getter
    def attribute(self) -> Optional[str]:
        """
        Column name - required for all calculation types besides 'CONCURRENCY' and 'COUNT'
        """
        return pulumi.get(self, "attribute")


@pulumi.output_type
class SloObjectiveCountMetricTotalInfluxdb(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: Query for the metrics
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveCountMetricTotalInstana(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricType":
            suggest = "metric_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricTotalInstana. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricTotalInstana.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricTotalInstana.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_type: str,
                 applications: Optional[Sequence['outputs.SloObjectiveCountMetricTotalInstanaApplication']] = None,
                 infrastructures: Optional[Sequence['outputs.SloObjectiveCountMetricTotalInstanaInfrastructure']] = None):
        """
        :param str metric_type: Instana metric type 'application' or 'infrastructure'
        :param Sequence['SloObjectiveCountMetricTotalInstanaApplicationArgs'] applications: Infrastructure metric type
        :param Sequence['SloObjectiveCountMetricTotalInstanaInfrastructureArgs'] infrastructures: Infrastructure metric type
        """
        pulumi.set(__self__, "metric_type", metric_type)
        if applications is not None:
            pulumi.set(__self__, "applications", applications)
        if infrastructures is not None:
            pulumi.set(__self__, "infrastructures", infrastructures)

    @property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> str:
        """
        Instana metric type 'application' or 'infrastructure'
        """
        return pulumi.get(self, "metric_type")

    @property
    @pulumi.getter
    def applications(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalInstanaApplication']]:
        """
        Infrastructure metric type
        """
        return pulumi.get(self, "applications")

    @property
    @pulumi.getter
    def infrastructures(self) -> Optional[Sequence['outputs.SloObjectiveCountMetricTotalInstanaInfrastructure']]:
        """
        Infrastructure metric type
        """
        return pulumi.get(self, "infrastructures")


@pulumi.output_type
class SloObjectiveCountMetricTotalInstanaApplication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiQuery":
            suggest = "api_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "metricId":
            suggest = "metric_id"
        elif key == "includeInternal":
            suggest = "include_internal"
        elif key == "includeSynthetic":
            suggest = "include_synthetic"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricTotalInstanaApplication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricTotalInstanaApplication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricTotalInstanaApplication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation: str,
                 api_query: str,
                 group_bies: Sequence['outputs.SloObjectiveCountMetricTotalInstanaApplicationGroupBy'],
                 metric_id: str,
                 include_internal: Optional[bool] = None,
                 include_synthetic: Optional[bool] = None):
        """
        :param str aggregation: Aggregation type [Required for metrics]
        :param str api_query: API query user passes in a JSON format
        :param Sequence['SloObjectiveCountMetricTotalInstanaApplicationGroupByArgs'] group_bies: Group by method
        :param str metric_id: Metric ID one of 'calls', 'erroneousCalls', 'errors', 'latency'
        :param bool include_internal: Include internal
        :param bool include_synthetic: Include synthetic
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "api_query", api_query)
        pulumi.set(__self__, "group_bies", group_bies)
        pulumi.set(__self__, "metric_id", metric_id)
        if include_internal is not None:
            pulumi.set(__self__, "include_internal", include_internal)
        if include_synthetic is not None:
            pulumi.set(__self__, "include_synthetic", include_synthetic)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        Aggregation type [Required for metrics]
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="apiQuery")
    def api_query(self) -> str:
        """
        API query user passes in a JSON format
        """
        return pulumi.get(self, "api_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Sequence['outputs.SloObjectiveCountMetricTotalInstanaApplicationGroupBy']:
        """
        Group by method
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="metricId")
    def metric_id(self) -> str:
        """
        Metric ID one of 'calls', 'erroneousCalls', 'errors', 'latency'
        """
        return pulumi.get(self, "metric_id")

    @property
    @pulumi.getter(name="includeInternal")
    def include_internal(self) -> Optional[bool]:
        """
        Include internal
        """
        return pulumi.get(self, "include_internal")

    @property
    @pulumi.getter(name="includeSynthetic")
    def include_synthetic(self) -> Optional[bool]:
        """
        Include synthetic
        """
        return pulumi.get(self, "include_synthetic")


@pulumi.output_type
class SloObjectiveCountMetricTotalInstanaApplicationGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagEntity":
            suggest = "tag_entity"
        elif key == "tagSecondLevelKey":
            suggest = "tag_second_level_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricTotalInstanaApplicationGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricTotalInstanaApplicationGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricTotalInstanaApplicationGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tag: str,
                 tag_entity: str,
                 tag_second_level_key: Optional[str] = None):
        """
        :param str tag: Group by tag
        :param str tag_entity: Tag entity - one of 'DESTINATION', 'SOURCE', 'NOT_APPLICABLE'
        """
        pulumi.set(__self__, "tag", tag)
        pulumi.set(__self__, "tag_entity", tag_entity)
        if tag_second_level_key is not None:
            pulumi.set(__self__, "tag_second_level_key", tag_second_level_key)

    @property
    @pulumi.getter
    def tag(self) -> str:
        """
        Group by tag
        """
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter(name="tagEntity")
    def tag_entity(self) -> str:
        """
        Tag entity - one of 'DESTINATION', 'SOURCE', 'NOT_APPLICABLE'
        """
        return pulumi.get(self, "tag_entity")

    @property
    @pulumi.getter(name="tagSecondLevelKey")
    def tag_second_level_key(self) -> Optional[str]:
        return pulumi.get(self, "tag_second_level_key")


@pulumi.output_type
class SloObjectiveCountMetricTotalInstanaInfrastructure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricId":
            suggest = "metric_id"
        elif key == "metricRetrievalMethod":
            suggest = "metric_retrieval_method"
        elif key == "pluginId":
            suggest = "plugin_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricTotalInstanaInfrastructure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricTotalInstanaInfrastructure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricTotalInstanaInfrastructure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_id: str,
                 metric_retrieval_method: str,
                 plugin_id: str,
                 query: Optional[str] = None,
                 snapshot_id: Optional[str] = None):
        """
        :param str metric_id: Metric ID one of 'calls', 'erroneousCalls', 'errors', 'latency'
        :param str metric_retrieval_method: Metric retrieval method 'query' or 'snapshot'
        :param str plugin_id: Plugin ID
        :param str query: Query for the metrics
        :param str snapshot_id: Snapshot ID
        """
        pulumi.set(__self__, "metric_id", metric_id)
        pulumi.set(__self__, "metric_retrieval_method", metric_retrieval_method)
        pulumi.set(__self__, "plugin_id", plugin_id)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)

    @property
    @pulumi.getter(name="metricId")
    def metric_id(self) -> str:
        """
        Metric ID one of 'calls', 'erroneousCalls', 'errors', 'latency'
        """
        return pulumi.get(self, "metric_id")

    @property
    @pulumi.getter(name="metricRetrievalMethod")
    def metric_retrieval_method(self) -> str:
        """
        Metric retrieval method 'query' or 'snapshot'
        """
        return pulumi.get(self, "metric_retrieval_method")

    @property
    @pulumi.getter(name="pluginId")
    def plugin_id(self) -> str:
        """
        Plugin ID
        """
        return pulumi.get(self, "plugin_id")

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        """
        Snapshot ID
        """
        return pulumi.get(self, "snapshot_id")


@pulumi.output_type
class SloObjectiveCountMetricTotalLightstep(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeOfData":
            suggest = "type_of_data"
        elif key == "streamId":
            suggest = "stream_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricTotalLightstep. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricTotalLightstep.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricTotalLightstep.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type_of_data: str,
                 percentile: Optional[float] = None,
                 stream_id: Optional[str] = None,
                 uql: Optional[str] = None):
        """
        :param str type_of_data: Type of data to filter by
        :param float percentile: Optional value to filter by percentiles
        :param str stream_id: ID of the metrics stream
        :param str uql: UQL query
        """
        pulumi.set(__self__, "type_of_data", type_of_data)
        if percentile is not None:
            pulumi.set(__self__, "percentile", percentile)
        if stream_id is not None:
            pulumi.set(__self__, "stream_id", stream_id)
        if uql is not None:
            pulumi.set(__self__, "uql", uql)

    @property
    @pulumi.getter(name="typeOfData")
    def type_of_data(self) -> str:
        """
        Type of data to filter by
        """
        return pulumi.get(self, "type_of_data")

    @property
    @pulumi.getter
    def percentile(self) -> Optional[float]:
        """
        Optional value to filter by percentiles
        """
        return pulumi.get(self, "percentile")

    @property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> Optional[str]:
        """
        ID of the metrics stream
        """
        return pulumi.get(self, "stream_id")

    @property
    @pulumi.getter
    def uql(self) -> Optional[str]:
        """
        UQL query
        """
        return pulumi.get(self, "uql")


@pulumi.output_type
class SloObjectiveCountMetricTotalNewrelic(dict):
    def __init__(__self__, *,
                 nrql: str):
        """
        :param str nrql: Query for the metrics
        """
        pulumi.set(__self__, "nrql", nrql)

    @property
    @pulumi.getter
    def nrql(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "nrql")


@pulumi.output_type
class SloObjectiveCountMetricTotalOpentsdb(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: Query for the metrics
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveCountMetricTotalPingdom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkId":
            suggest = "check_id"
        elif key == "checkType":
            suggest = "check_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricTotalPingdom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricTotalPingdom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricTotalPingdom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check_id: str,
                 check_type: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param str check_id: Pingdom uptime or transaction check's ID
        :param str check_type: Pingdom check type - uptime or transaction
        :param str status: Optional for the Uptime checks. Use it to filter the Pingdom check results by status
        """
        pulumi.set(__self__, "check_id", check_id)
        if check_type is not None:
            pulumi.set(__self__, "check_type", check_type)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="checkId")
    def check_id(self) -> str:
        """
        Pingdom uptime or transaction check's ID
        """
        return pulumi.get(self, "check_id")

    @property
    @pulumi.getter(name="checkType")
    def check_type(self) -> Optional[str]:
        """
        Pingdom check type - uptime or transaction
        """
        return pulumi.get(self, "check_type")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Optional for the Uptime checks. Use it to filter the Pingdom check results by status
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class SloObjectiveCountMetricTotalPrometheus(dict):
    def __init__(__self__, *,
                 promql: str):
        """
        :param str promql: Query for the metrics
        """
        pulumi.set(__self__, "promql", promql)

    @property
    @pulumi.getter
    def promql(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "promql")


@pulumi.output_type
class SloObjectiveCountMetricTotalRedshift(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterId":
            suggest = "cluster_id"
        elif key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricTotalRedshift. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricTotalRedshift.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricTotalRedshift.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_id: str,
                 database_name: str,
                 query: str,
                 region: str):
        """
        :param str cluster_id: Redshift custer ID
        :param str database_name: Database name
        :param str query: Query for the metrics
        :param str region: Region of the CloudWatch instance
        """
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> str:
        """
        Redshift custer ID
        """
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Database name
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Region of the CloudWatch instance
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class SloObjectiveCountMetricTotalSplunk(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: Query for the metrics
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveCountMetricTotalSplunkObservability(dict):
    def __init__(__self__, *,
                 program: str):
        """
        :param str program: Query for the metrics
        """
        pulumi.set(__self__, "program", program)

    @property
    @pulumi.getter
    def program(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "program")


@pulumi.output_type
class SloObjectiveCountMetricTotalSumologic(dict):
    def __init__(__self__, *,
                 query: str,
                 type: str,
                 quantization: Optional[str] = None,
                 rollup: Optional[str] = None):
        """
        :param str query: Query for the metrics
        :param str type: Sumologic source - metrics or logs
        :param str quantization: Period of data aggregation
        :param str rollup: Aggregation function - avg, sum, min, max, count, none
        """
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "type", type)
        if quantization is not None:
            pulumi.set(__self__, "quantization", quantization)
        if rollup is not None:
            pulumi.set(__self__, "rollup", rollup)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Sumologic source - metrics or logs
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def quantization(self) -> Optional[str]:
        """
        Period of data aggregation
        """
        return pulumi.get(self, "quantization")

    @property
    @pulumi.getter
    def rollup(self) -> Optional[str]:
        """
        Aggregation function - avg, sum, min, max, count, none
        """
        return pulumi.get(self, "rollup")


@pulumi.output_type
class SloObjectiveCountMetricTotalThousandeye(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "testId":
            suggest = "test_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveCountMetricTotalThousandeye. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveCountMetricTotalThousandeye.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveCountMetricTotalThousandeye.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 test_id: int):
        """
        :param int test_id: ID of the test
        """
        pulumi.set(__self__, "test_id", test_id)

    @property
    @pulumi.getter(name="testId")
    def test_id(self) -> int:
        """
        ID of the test
        """
        return pulumi.get(self, "test_id")


@pulumi.output_type
class SloObjectiveRawMetric(dict):
    def __init__(__self__, *,
                 queries: Sequence['outputs.SloObjectiveRawMetricQuery']):
        """
        :param Sequence['SloObjectiveRawMetricQueryArgs'] queries: Query for the metrics
        """
        pulumi.set(__self__, "queries", queries)

    @property
    @pulumi.getter
    def queries(self) -> Sequence['outputs.SloObjectiveRawMetricQuery']:
        """
        Query for the metrics
        """
        return pulumi.get(self, "queries")


@pulumi.output_type
class SloObjectiveRawMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "amazonPrometheuses":
            suggest = "amazon_prometheuses"
        elif key == "azureMonitors":
            suggest = "azure_monitors"
        elif key == "grafanaLokis":
            suggest = "grafana_lokis"
        elif key == "splunkObservabilities":
            suggest = "splunk_observabilities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveRawMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveRawMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveRawMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amazon_prometheuses: Optional[Sequence['outputs.SloObjectiveRawMetricQueryAmazonPrometheus']] = None,
                 appdynamics: Optional[Sequence['outputs.SloObjectiveRawMetricQueryAppdynamic']] = None,
                 azure_monitors: Optional[Sequence['outputs.SloObjectiveRawMetricQueryAzureMonitor']] = None,
                 bigqueries: Optional[Sequence['outputs.SloObjectiveRawMetricQueryBigquery']] = None,
                 cloudwatches: Optional[Sequence['outputs.SloObjectiveRawMetricQueryCloudwatch']] = None,
                 datadogs: Optional[Sequence['outputs.SloObjectiveRawMetricQueryDatadog']] = None,
                 dynatraces: Optional[Sequence['outputs.SloObjectiveRawMetricQueryDynatrace']] = None,
                 elasticsearches: Optional[Sequence['outputs.SloObjectiveRawMetricQueryElasticsearch']] = None,
                 gcms: Optional[Sequence['outputs.SloObjectiveRawMetricQueryGcm']] = None,
                 grafana_lokis: Optional[Sequence['outputs.SloObjectiveRawMetricQueryGrafanaLoki']] = None,
                 graphites: Optional[Sequence['outputs.SloObjectiveRawMetricQueryGraphite']] = None,
                 honeycombs: Optional[Sequence['outputs.SloObjectiveRawMetricQueryHoneycomb']] = None,
                 influxdbs: Optional[Sequence['outputs.SloObjectiveRawMetricQueryInfluxdb']] = None,
                 instanas: Optional[Sequence['outputs.SloObjectiveRawMetricQueryInstana']] = None,
                 lightsteps: Optional[Sequence['outputs.SloObjectiveRawMetricQueryLightstep']] = None,
                 newrelics: Optional[Sequence['outputs.SloObjectiveRawMetricQueryNewrelic']] = None,
                 opentsdbs: Optional[Sequence['outputs.SloObjectiveRawMetricQueryOpentsdb']] = None,
                 pingdoms: Optional[Sequence['outputs.SloObjectiveRawMetricQueryPingdom']] = None,
                 prometheuses: Optional[Sequence['outputs.SloObjectiveRawMetricQueryPrometheus']] = None,
                 redshifts: Optional[Sequence['outputs.SloObjectiveRawMetricQueryRedshift']] = None,
                 splunk_observabilities: Optional[Sequence['outputs.SloObjectiveRawMetricQuerySplunkObservability']] = None,
                 splunks: Optional[Sequence['outputs.SloObjectiveRawMetricQuerySplunk']] = None,
                 sumologics: Optional[Sequence['outputs.SloObjectiveRawMetricQuerySumologic']] = None,
                 thousandeyes: Optional[Sequence['outputs.SloObjectiveRawMetricQueryThousandeye']] = None):
        """
        :param Sequence['SloObjectiveRawMetricQueryAmazonPrometheusArgs'] amazon_prometheuses: [Configuration documentation](https://docs.nobl9.com/Sources/Amazon_Prometheus/#creating-slos-with-ams-prometheus)
        :param Sequence['SloObjectiveRawMetricQueryAppdynamicArgs'] appdynamics: [Configuration documentation](https://docs.nobl9.com/Sources/appdynamics#creating-slos-with-appdynamics)
        :param Sequence['SloObjectiveRawMetricQueryAzureMonitorArgs'] azure_monitors: [Configuration documentation](https://docs.nobl9.com/Sources/azure-monitor#creating-slos-with-azure-monitor)
        :param Sequence['SloObjectiveRawMetricQueryBigqueryArgs'] bigqueries: [Configuration documentation](https://docs.nobl9.com/Sources/bigquery#creating-slos-with-bigquery)
        :param Sequence['SloObjectiveRawMetricQueryCloudwatchArgs'] cloudwatches: [Configuration documentation](https://docs.nobl9.com/Sources/Amazon_CloudWatch/#creating-slos-with-cloudwatch)
        :param Sequence['SloObjectiveRawMetricQueryDatadogArgs'] datadogs: [Configuration documentation](https://docs.nobl9.com/Sources/datadog#creating-slos-with-datadog)
        :param Sequence['SloObjectiveRawMetricQueryDynatraceArgs'] dynatraces: [Configuration documentation](https://docs.nobl9.com/Sources/dynatrace#creating-slos-with-dynatrace)
        :param Sequence['SloObjectiveRawMetricQueryElasticsearchArgs'] elasticsearches: [Configuration documentation](https://docs.nobl9.com/Sources/elasticsearch#creating-slos-with-elasticsearch)
        :param Sequence['SloObjectiveRawMetricQueryGcmArgs'] gcms: [Configuration documentation](https://docs.nobl9.com/Sources/google-cloud-monitoring#creating-slos-with-google-cloud-monitoring)
        :param Sequence['SloObjectiveRawMetricQueryGrafanaLokiArgs'] grafana_lokis: [Configuration documentation](https://docs.nobl9.com/Sources/grafana-loki#creating-slos-with-grafana-loki)
        :param Sequence['SloObjectiveRawMetricQueryGraphiteArgs'] graphites: [Configuration documentation](https://docs.nobl9.com/Sources/graphite#creating-slos-with-graphite)
        :param Sequence['SloObjectiveRawMetricQueryHoneycombArgs'] honeycombs: [Configuration documentation](https://docs.nobl9.com/Sources/honeycomb#creating-slos-with-honeycomb)
        :param Sequence['SloObjectiveRawMetricQueryInfluxdbArgs'] influxdbs: [Configuration documentation](https://docs.nobl9.com/Sources/influxdb#creating-slos-with-influxdb)
        :param Sequence['SloObjectiveRawMetricQueryInstanaArgs'] instanas: [Configuration documentation](https://docs.nobl9.com/Sources/instana#creating-slos-with-instana)
        :param Sequence['SloObjectiveRawMetricQueryLightstepArgs'] lightsteps: [Configuration documentation](https://docs.nobl9.com/Sources/lightstep#creating-slos-with-lightstep)
        :param Sequence['SloObjectiveRawMetricQueryNewrelicArgs'] newrelics: [Configuration documentation](https://docs.nobl9.com/Sources/new-relic#creating-slos-with-new-relic)
        :param Sequence['SloObjectiveRawMetricQueryOpentsdbArgs'] opentsdbs: [Configuration documentation](https://docs.nobl9.com/Sources/opentsdb#creating-slos-with-opentsdb)
        :param Sequence['SloObjectiveRawMetricQueryPingdomArgs'] pingdoms: [Configuration documentation](https://docs.nobl9.com/Sources/pingdom#creating-slos-with-pingdom)
        :param Sequence['SloObjectiveRawMetricQueryPrometheusArgs'] prometheuses: [Configuration documentation](https://docs.nobl9.com/Sources/prometheus#creating-slos-with-prometheus)
        :param Sequence['SloObjectiveRawMetricQueryRedshiftArgs'] redshifts: [Configuration documentation](https://docs.nobl9.com/Sources/Amazon_Redshift/#creating-slos-with-amazon-redshift)
        :param Sequence['SloObjectiveRawMetricQuerySplunkObservabilityArgs'] splunk_observabilities: [Configuration documentation](https://docs.nobl9.com/Sources/splunk#creating-slos-with-splunk-observability)
        :param Sequence['SloObjectiveRawMetricQuerySplunkArgs'] splunks: [Configuration documentation](https://docs.nobl9.com/Sources/splunk#creating-slos-with-splunk)
        :param Sequence['SloObjectiveRawMetricQuerySumologicArgs'] sumologics: [Configuration documentation](https://docs.nobl9.com/Sources/sumo-logic#creating-slos-with-sumo-logic)
        :param Sequence['SloObjectiveRawMetricQueryThousandeyeArgs'] thousandeyes: [Configuration documentation](https://docs.nobl9.com/Sources/thousandeyes#creating-slos-with-thousandeyes)
        """
        if amazon_prometheuses is not None:
            pulumi.set(__self__, "amazon_prometheuses", amazon_prometheuses)
        if appdynamics is not None:
            pulumi.set(__self__, "appdynamics", appdynamics)
        if azure_monitors is not None:
            pulumi.set(__self__, "azure_monitors", azure_monitors)
        if bigqueries is not None:
            pulumi.set(__self__, "bigqueries", bigqueries)
        if cloudwatches is not None:
            pulumi.set(__self__, "cloudwatches", cloudwatches)
        if datadogs is not None:
            pulumi.set(__self__, "datadogs", datadogs)
        if dynatraces is not None:
            pulumi.set(__self__, "dynatraces", dynatraces)
        if elasticsearches is not None:
            pulumi.set(__self__, "elasticsearches", elasticsearches)
        if gcms is not None:
            pulumi.set(__self__, "gcms", gcms)
        if grafana_lokis is not None:
            pulumi.set(__self__, "grafana_lokis", grafana_lokis)
        if graphites is not None:
            pulumi.set(__self__, "graphites", graphites)
        if honeycombs is not None:
            pulumi.set(__self__, "honeycombs", honeycombs)
        if influxdbs is not None:
            pulumi.set(__self__, "influxdbs", influxdbs)
        if instanas is not None:
            pulumi.set(__self__, "instanas", instanas)
        if lightsteps is not None:
            pulumi.set(__self__, "lightsteps", lightsteps)
        if newrelics is not None:
            pulumi.set(__self__, "newrelics", newrelics)
        if opentsdbs is not None:
            pulumi.set(__self__, "opentsdbs", opentsdbs)
        if pingdoms is not None:
            pulumi.set(__self__, "pingdoms", pingdoms)
        if prometheuses is not None:
            pulumi.set(__self__, "prometheuses", prometheuses)
        if redshifts is not None:
            pulumi.set(__self__, "redshifts", redshifts)
        if splunk_observabilities is not None:
            pulumi.set(__self__, "splunk_observabilities", splunk_observabilities)
        if splunks is not None:
            pulumi.set(__self__, "splunks", splunks)
        if sumologics is not None:
            pulumi.set(__self__, "sumologics", sumologics)
        if thousandeyes is not None:
            pulumi.set(__self__, "thousandeyes", thousandeyes)

    @property
    @pulumi.getter(name="amazonPrometheuses")
    def amazon_prometheuses(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryAmazonPrometheus']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/Amazon_Prometheus/#creating-slos-with-ams-prometheus)
        """
        return pulumi.get(self, "amazon_prometheuses")

    @property
    @pulumi.getter
    def appdynamics(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryAppdynamic']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/appdynamics#creating-slos-with-appdynamics)
        """
        return pulumi.get(self, "appdynamics")

    @property
    @pulumi.getter(name="azureMonitors")
    def azure_monitors(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryAzureMonitor']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/azure-monitor#creating-slos-with-azure-monitor)
        """
        return pulumi.get(self, "azure_monitors")

    @property
    @pulumi.getter
    def bigqueries(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryBigquery']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/bigquery#creating-slos-with-bigquery)
        """
        return pulumi.get(self, "bigqueries")

    @property
    @pulumi.getter
    def cloudwatches(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryCloudwatch']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/Amazon_CloudWatch/#creating-slos-with-cloudwatch)
        """
        return pulumi.get(self, "cloudwatches")

    @property
    @pulumi.getter
    def datadogs(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryDatadog']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/datadog#creating-slos-with-datadog)
        """
        return pulumi.get(self, "datadogs")

    @property
    @pulumi.getter
    def dynatraces(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryDynatrace']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/dynatrace#creating-slos-with-dynatrace)
        """
        return pulumi.get(self, "dynatraces")

    @property
    @pulumi.getter
    def elasticsearches(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryElasticsearch']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/elasticsearch#creating-slos-with-elasticsearch)
        """
        return pulumi.get(self, "elasticsearches")

    @property
    @pulumi.getter
    def gcms(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryGcm']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/google-cloud-monitoring#creating-slos-with-google-cloud-monitoring)
        """
        return pulumi.get(self, "gcms")

    @property
    @pulumi.getter(name="grafanaLokis")
    def grafana_lokis(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryGrafanaLoki']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/grafana-loki#creating-slos-with-grafana-loki)
        """
        return pulumi.get(self, "grafana_lokis")

    @property
    @pulumi.getter
    def graphites(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryGraphite']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/graphite#creating-slos-with-graphite)
        """
        return pulumi.get(self, "graphites")

    @property
    @pulumi.getter
    def honeycombs(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryHoneycomb']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/honeycomb#creating-slos-with-honeycomb)
        """
        return pulumi.get(self, "honeycombs")

    @property
    @pulumi.getter
    def influxdbs(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryInfluxdb']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/influxdb#creating-slos-with-influxdb)
        """
        return pulumi.get(self, "influxdbs")

    @property
    @pulumi.getter
    def instanas(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryInstana']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/instana#creating-slos-with-instana)
        """
        return pulumi.get(self, "instanas")

    @property
    @pulumi.getter
    def lightsteps(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryLightstep']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/lightstep#creating-slos-with-lightstep)
        """
        return pulumi.get(self, "lightsteps")

    @property
    @pulumi.getter
    def newrelics(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryNewrelic']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/new-relic#creating-slos-with-new-relic)
        """
        return pulumi.get(self, "newrelics")

    @property
    @pulumi.getter
    def opentsdbs(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryOpentsdb']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/opentsdb#creating-slos-with-opentsdb)
        """
        return pulumi.get(self, "opentsdbs")

    @property
    @pulumi.getter
    def pingdoms(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryPingdom']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/pingdom#creating-slos-with-pingdom)
        """
        return pulumi.get(self, "pingdoms")

    @property
    @pulumi.getter
    def prometheuses(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryPrometheus']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/prometheus#creating-slos-with-prometheus)
        """
        return pulumi.get(self, "prometheuses")

    @property
    @pulumi.getter
    def redshifts(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryRedshift']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/Amazon_Redshift/#creating-slos-with-amazon-redshift)
        """
        return pulumi.get(self, "redshifts")

    @property
    @pulumi.getter(name="splunkObservabilities")
    def splunk_observabilities(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQuerySplunkObservability']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/splunk#creating-slos-with-splunk-observability)
        """
        return pulumi.get(self, "splunk_observabilities")

    @property
    @pulumi.getter
    def splunks(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQuerySplunk']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/splunk#creating-slos-with-splunk)
        """
        return pulumi.get(self, "splunks")

    @property
    @pulumi.getter
    def sumologics(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQuerySumologic']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/sumo-logic#creating-slos-with-sumo-logic)
        """
        return pulumi.get(self, "sumologics")

    @property
    @pulumi.getter
    def thousandeyes(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryThousandeye']]:
        """
        [Configuration documentation](https://docs.nobl9.com/Sources/thousandeyes#creating-slos-with-thousandeyes)
        """
        return pulumi.get(self, "thousandeyes")


@pulumi.output_type
class SloObjectiveRawMetricQueryAmazonPrometheus(dict):
    def __init__(__self__, *,
                 promql: str):
        """
        :param str promql: Query for the metrics
        """
        pulumi.set(__self__, "promql", promql)

    @property
    @pulumi.getter
    def promql(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "promql")


@pulumi.output_type
class SloObjectiveRawMetricQueryAppdynamic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationName":
            suggest = "application_name"
        elif key == "metricPath":
            suggest = "metric_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveRawMetricQueryAppdynamic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveRawMetricQueryAppdynamic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveRawMetricQueryAppdynamic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_name: str,
                 metric_path: str):
        """
        :param str application_name: Name of the added application
        :param str metric_path: Path to the metrics
        """
        pulumi.set(__self__, "application_name", application_name)
        pulumi.set(__self__, "metric_path", metric_path)

    @property
    @pulumi.getter(name="applicationName")
    def application_name(self) -> str:
        """
        Name of the added application
        """
        return pulumi.get(self, "application_name")

    @property
    @pulumi.getter(name="metricPath")
    def metric_path(self) -> str:
        """
        Path to the metrics
        """
        return pulumi.get(self, "metric_path")


@pulumi.output_type
class SloObjectiveRawMetricQueryAzureMonitor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"
        elif key == "kqlQuery":
            suggest = "kql_query"
        elif key == "metricName":
            suggest = "metric_name"
        elif key == "metricNamespace":
            suggest = "metric_namespace"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveRawMetricQueryAzureMonitor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveRawMetricQueryAzureMonitor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveRawMetricQueryAzureMonitor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_type: str,
                 aggregation: Optional[str] = None,
                 dimensions: Optional[Sequence['outputs.SloObjectiveRawMetricQueryAzureMonitorDimension']] = None,
                 kql_query: Optional[str] = None,
                 metric_name: Optional[str] = None,
                 metric_namespace: Optional[str] = None,
                 resource_id: Optional[str] = None,
                 workspaces: Optional[Sequence['outputs.SloObjectiveRawMetricQueryAzureMonitorWorkspace']] = None):
        """
        :param str data_type: Specifies source: 'metrics' or 'logs'
        :param str aggregation: Aggregation type [Required for metrics]
        :param Sequence['SloObjectiveRawMetricQueryAzureMonitorDimensionArgs'] dimensions: Dimensions of the metric [Optional for metrics]
        :param str kql_query: Logs query in Kusto Query Language [Required for logs]
        :param str metric_name: Name of the metric [Required for metrics]
        :param str metric_namespace: Namespace of the metric [Optional for metrics]
        :param str resource_id: Identifier of the Azure Cloud resource [Required for metrics]
        :param Sequence['SloObjectiveRawMetricQueryAzureMonitorWorkspaceArgs'] workspaces: Log analytics workspace [Required for logs]
        """
        pulumi.set(__self__, "data_type", data_type)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if kql_query is not None:
            pulumi.set(__self__, "kql_query", kql_query)
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)
        if metric_namespace is not None:
            pulumi.set(__self__, "metric_namespace", metric_namespace)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if workspaces is not None:
            pulumi.set(__self__, "workspaces", workspaces)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> str:
        """
        Specifies source: 'metrics' or 'logs'
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[str]:
        """
        Aggregation type [Required for metrics]
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryAzureMonitorDimension']]:
        """
        Dimensions of the metric [Optional for metrics]
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="kqlQuery")
    def kql_query(self) -> Optional[str]:
        """
        Logs query in Kusto Query Language [Required for logs]
        """
        return pulumi.get(self, "kql_query")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[str]:
        """
        Name of the metric [Required for metrics]
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter(name="metricNamespace")
    def metric_namespace(self) -> Optional[str]:
        """
        Namespace of the metric [Optional for metrics]
        """
        return pulumi.get(self, "metric_namespace")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        """
        Identifier of the Azure Cloud resource [Required for metrics]
        """
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter
    def workspaces(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryAzureMonitorWorkspace']]:
        """
        Log analytics workspace [Required for logs]
        """
        return pulumi.get(self, "workspaces")


@pulumi.output_type
class SloObjectiveRawMetricQueryAzureMonitorDimension(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The name of the previously defined alert method.
        :param str value: Burn rate value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the previously defined alert method.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Burn rate value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SloObjectiveRawMetricQueryAzureMonitorWorkspace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceGroup":
            suggest = "resource_group"
        elif key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "workspaceId":
            suggest = "workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveRawMetricQueryAzureMonitorWorkspace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveRawMetricQueryAzureMonitorWorkspace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveRawMetricQueryAzureMonitorWorkspace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_group: str,
                 subscription_id: str,
                 workspace_id: str):
        """
        :param str resource_group: Resource group of the workspace
        :param str subscription_id: Subscription ID of the workspace
        :param str workspace_id: ID of the workspace
        """
        pulumi.set(__self__, "resource_group", resource_group)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "workspace_id", workspace_id)

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> str:
        """
        Resource group of the workspace
        """
        return pulumi.get(self, "resource_group")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> str:
        """
        Subscription ID of the workspace
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> str:
        """
        ID of the workspace
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class SloObjectiveRawMetricQueryBigquery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveRawMetricQueryBigquery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveRawMetricQueryBigquery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveRawMetricQueryBigquery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 location: str,
                 project_id: str,
                 query: str):
        """
        :param str location: Location of you BigQuery
        :param str project_id: Project ID
        :param str query: Query for the metrics
        """
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        Location of you BigQuery
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        Project ID
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveRawMetricQueryCloudwatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountId":
            suggest = "account_id"
        elif key == "metricName":
            suggest = "metric_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveRawMetricQueryCloudwatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveRawMetricQueryCloudwatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveRawMetricQueryCloudwatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region: str,
                 account_id: Optional[str] = None,
                 dimensions: Optional[Sequence['outputs.SloObjectiveRawMetricQueryCloudwatchDimension']] = None,
                 json: Optional[str] = None,
                 metric_name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 sql: Optional[str] = None,
                 stat: Optional[str] = None):
        """
        :param str region: Region of the CloudWatch instance
        :param str account_id: AccountID used with cross-account observability feature
        :param Sequence['SloObjectiveRawMetricQueryCloudwatchDimensionArgs'] dimensions: Dimensions of the metric [Optional for metrics]
        :param str json: JSON query
        :param str metric_name: Name of the metric [Required for metrics]
        :param str namespace: Namespace of the metric
        :param str sql: SQL query
        :param str stat: Metric data aggregations
        """
        pulumi.set(__self__, "region", region)
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if json is not None:
            pulumi.set(__self__, "json", json)
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if sql is not None:
            pulumi.set(__self__, "sql", sql)
        if stat is not None:
            pulumi.set(__self__, "stat", stat)

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Region of the CloudWatch instance
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[str]:
        """
        AccountID used with cross-account observability feature
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryCloudwatchDimension']]:
        """
        Dimensions of the metric [Optional for metrics]
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def json(self) -> Optional[str]:
        """
        JSON query
        """
        return pulumi.get(self, "json")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[str]:
        """
        Name of the metric [Required for metrics]
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the metric
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def sql(self) -> Optional[str]:
        """
        SQL query
        """
        return pulumi.get(self, "sql")

    @property
    @pulumi.getter
    def stat(self) -> Optional[str]:
        """
        Metric data aggregations
        """
        return pulumi.get(self, "stat")


@pulumi.output_type
class SloObjectiveRawMetricQueryCloudwatchDimension(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The name of the previously defined alert method.
        :param str value: Burn rate value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the previously defined alert method.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Burn rate value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SloObjectiveRawMetricQueryDatadog(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: Query for the metrics
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveRawMetricQueryDynatrace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricSelector":
            suggest = "metric_selector"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveRawMetricQueryDynatrace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveRawMetricQueryDynatrace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveRawMetricQueryDynatrace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_selector: str):
        """
        :param str metric_selector: Selector for the metrics
        """
        pulumi.set(__self__, "metric_selector", metric_selector)

    @property
    @pulumi.getter(name="metricSelector")
    def metric_selector(self) -> str:
        """
        Selector for the metrics
        """
        return pulumi.get(self, "metric_selector")


@pulumi.output_type
class SloObjectiveRawMetricQueryElasticsearch(dict):
    def __init__(__self__, *,
                 index: str,
                 query: str):
        """
        :param str index: Index of metrics we want to query
        :param str query: Query for the metrics
        """
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        Index of metrics we want to query
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveRawMetricQueryGcm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveRawMetricQueryGcm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveRawMetricQueryGcm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveRawMetricQueryGcm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 project_id: str,
                 query: str):
        """
        :param str project_id: Project ID
        :param str query: Query for the metrics
        """
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        Project ID
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveRawMetricQueryGrafanaLoki(dict):
    def __init__(__self__, *,
                 logql: str):
        """
        :param str logql: Query for the logs
        """
        pulumi.set(__self__, "logql", logql)

    @property
    @pulumi.getter
    def logql(self) -> str:
        """
        Query for the logs
        """
        return pulumi.get(self, "logql")


@pulumi.output_type
class SloObjectiveRawMetricQueryGraphite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricPath":
            suggest = "metric_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveRawMetricQueryGraphite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveRawMetricQueryGraphite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveRawMetricQueryGraphite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_path: str):
        """
        :param str metric_path: Path to the metrics
        """
        pulumi.set(__self__, "metric_path", metric_path)

    @property
    @pulumi.getter(name="metricPath")
    def metric_path(self) -> str:
        """
        Path to the metrics
        """
        return pulumi.get(self, "metric_path")


@pulumi.output_type
class SloObjectiveRawMetricQueryHoneycomb(dict):
    def __init__(__self__, *,
                 calculation: str,
                 attribute: Optional[str] = None):
        """
        :param str calculation: Calculation type
        :param str attribute: Column name - required for all calculation types besides 'CONCURRENCY' and 'COUNT'
        """
        pulumi.set(__self__, "calculation", calculation)
        if attribute is not None:
            pulumi.set(__self__, "attribute", attribute)

    @property
    @pulumi.getter
    def calculation(self) -> str:
        """
        Calculation type
        """
        return pulumi.get(self, "calculation")

    @property
    @pulumi.getter
    def attribute(self) -> Optional[str]:
        """
        Column name - required for all calculation types besides 'CONCURRENCY' and 'COUNT'
        """
        return pulumi.get(self, "attribute")


@pulumi.output_type
class SloObjectiveRawMetricQueryInfluxdb(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: Query for the metrics
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveRawMetricQueryInstana(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricType":
            suggest = "metric_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveRawMetricQueryInstana. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveRawMetricQueryInstana.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveRawMetricQueryInstana.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_type: str,
                 applications: Optional[Sequence['outputs.SloObjectiveRawMetricQueryInstanaApplication']] = None,
                 infrastructures: Optional[Sequence['outputs.SloObjectiveRawMetricQueryInstanaInfrastructure']] = None):
        """
        :param str metric_type: Instana metric type 'application' or 'infrastructure'
        :param Sequence['SloObjectiveRawMetricQueryInstanaApplicationArgs'] applications: Infrastructure metric type
        :param Sequence['SloObjectiveRawMetricQueryInstanaInfrastructureArgs'] infrastructures: Infrastructure metric type
        """
        pulumi.set(__self__, "metric_type", metric_type)
        if applications is not None:
            pulumi.set(__self__, "applications", applications)
        if infrastructures is not None:
            pulumi.set(__self__, "infrastructures", infrastructures)

    @property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> str:
        """
        Instana metric type 'application' or 'infrastructure'
        """
        return pulumi.get(self, "metric_type")

    @property
    @pulumi.getter
    def applications(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryInstanaApplication']]:
        """
        Infrastructure metric type
        """
        return pulumi.get(self, "applications")

    @property
    @pulumi.getter
    def infrastructures(self) -> Optional[Sequence['outputs.SloObjectiveRawMetricQueryInstanaInfrastructure']]:
        """
        Infrastructure metric type
        """
        return pulumi.get(self, "infrastructures")


@pulumi.output_type
class SloObjectiveRawMetricQueryInstanaApplication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiQuery":
            suggest = "api_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "metricId":
            suggest = "metric_id"
        elif key == "includeInternal":
            suggest = "include_internal"
        elif key == "includeSynthetic":
            suggest = "include_synthetic"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveRawMetricQueryInstanaApplication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveRawMetricQueryInstanaApplication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveRawMetricQueryInstanaApplication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation: str,
                 api_query: str,
                 group_bies: Sequence['outputs.SloObjectiveRawMetricQueryInstanaApplicationGroupBy'],
                 metric_id: str,
                 include_internal: Optional[bool] = None,
                 include_synthetic: Optional[bool] = None):
        """
        :param str aggregation: Aggregation type [Required for metrics]
        :param str api_query: API query user passes in a JSON format
        :param Sequence['SloObjectiveRawMetricQueryInstanaApplicationGroupByArgs'] group_bies: Group by method
        :param str metric_id: Metric ID one of 'calls', 'erroneousCalls', 'errors', 'latency'
        :param bool include_internal: Include internal
        :param bool include_synthetic: Include synthetic
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "api_query", api_query)
        pulumi.set(__self__, "group_bies", group_bies)
        pulumi.set(__self__, "metric_id", metric_id)
        if include_internal is not None:
            pulumi.set(__self__, "include_internal", include_internal)
        if include_synthetic is not None:
            pulumi.set(__self__, "include_synthetic", include_synthetic)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        Aggregation type [Required for metrics]
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="apiQuery")
    def api_query(self) -> str:
        """
        API query user passes in a JSON format
        """
        return pulumi.get(self, "api_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Sequence['outputs.SloObjectiveRawMetricQueryInstanaApplicationGroupBy']:
        """
        Group by method
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="metricId")
    def metric_id(self) -> str:
        """
        Metric ID one of 'calls', 'erroneousCalls', 'errors', 'latency'
        """
        return pulumi.get(self, "metric_id")

    @property
    @pulumi.getter(name="includeInternal")
    def include_internal(self) -> Optional[bool]:
        """
        Include internal
        """
        return pulumi.get(self, "include_internal")

    @property
    @pulumi.getter(name="includeSynthetic")
    def include_synthetic(self) -> Optional[bool]:
        """
        Include synthetic
        """
        return pulumi.get(self, "include_synthetic")


@pulumi.output_type
class SloObjectiveRawMetricQueryInstanaApplicationGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagEntity":
            suggest = "tag_entity"
        elif key == "tagSecondLevelKey":
            suggest = "tag_second_level_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveRawMetricQueryInstanaApplicationGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveRawMetricQueryInstanaApplicationGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveRawMetricQueryInstanaApplicationGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tag: str,
                 tag_entity: str,
                 tag_second_level_key: Optional[str] = None):
        """
        :param str tag: Group by tag
        :param str tag_entity: Tag entity - one of 'DESTINATION', 'SOURCE', 'NOT_APPLICABLE'
        """
        pulumi.set(__self__, "tag", tag)
        pulumi.set(__self__, "tag_entity", tag_entity)
        if tag_second_level_key is not None:
            pulumi.set(__self__, "tag_second_level_key", tag_second_level_key)

    @property
    @pulumi.getter
    def tag(self) -> str:
        """
        Group by tag
        """
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter(name="tagEntity")
    def tag_entity(self) -> str:
        """
        Tag entity - one of 'DESTINATION', 'SOURCE', 'NOT_APPLICABLE'
        """
        return pulumi.get(self, "tag_entity")

    @property
    @pulumi.getter(name="tagSecondLevelKey")
    def tag_second_level_key(self) -> Optional[str]:
        return pulumi.get(self, "tag_second_level_key")


@pulumi.output_type
class SloObjectiveRawMetricQueryInstanaInfrastructure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricId":
            suggest = "metric_id"
        elif key == "metricRetrievalMethod":
            suggest = "metric_retrieval_method"
        elif key == "pluginId":
            suggest = "plugin_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveRawMetricQueryInstanaInfrastructure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveRawMetricQueryInstanaInfrastructure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveRawMetricQueryInstanaInfrastructure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_id: str,
                 metric_retrieval_method: str,
                 plugin_id: str,
                 query: Optional[str] = None,
                 snapshot_id: Optional[str] = None):
        """
        :param str metric_id: Metric ID one of 'calls', 'erroneousCalls', 'errors', 'latency'
        :param str metric_retrieval_method: Metric retrieval method 'query' or 'snapshot'
        :param str plugin_id: Plugin ID
        :param str query: Query for the metrics
        :param str snapshot_id: Snapshot ID
        """
        pulumi.set(__self__, "metric_id", metric_id)
        pulumi.set(__self__, "metric_retrieval_method", metric_retrieval_method)
        pulumi.set(__self__, "plugin_id", plugin_id)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)

    @property
    @pulumi.getter(name="metricId")
    def metric_id(self) -> str:
        """
        Metric ID one of 'calls', 'erroneousCalls', 'errors', 'latency'
        """
        return pulumi.get(self, "metric_id")

    @property
    @pulumi.getter(name="metricRetrievalMethod")
    def metric_retrieval_method(self) -> str:
        """
        Metric retrieval method 'query' or 'snapshot'
        """
        return pulumi.get(self, "metric_retrieval_method")

    @property
    @pulumi.getter(name="pluginId")
    def plugin_id(self) -> str:
        """
        Plugin ID
        """
        return pulumi.get(self, "plugin_id")

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        """
        Snapshot ID
        """
        return pulumi.get(self, "snapshot_id")


@pulumi.output_type
class SloObjectiveRawMetricQueryLightstep(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeOfData":
            suggest = "type_of_data"
        elif key == "streamId":
            suggest = "stream_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveRawMetricQueryLightstep. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveRawMetricQueryLightstep.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveRawMetricQueryLightstep.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type_of_data: str,
                 percentile: Optional[float] = None,
                 stream_id: Optional[str] = None,
                 uql: Optional[str] = None):
        """
        :param str type_of_data: Type of data to filter by
        :param float percentile: Optional value to filter by percentiles
        :param str stream_id: ID of the metrics stream
        :param str uql: UQL query
        """
        pulumi.set(__self__, "type_of_data", type_of_data)
        if percentile is not None:
            pulumi.set(__self__, "percentile", percentile)
        if stream_id is not None:
            pulumi.set(__self__, "stream_id", stream_id)
        if uql is not None:
            pulumi.set(__self__, "uql", uql)

    @property
    @pulumi.getter(name="typeOfData")
    def type_of_data(self) -> str:
        """
        Type of data to filter by
        """
        return pulumi.get(self, "type_of_data")

    @property
    @pulumi.getter
    def percentile(self) -> Optional[float]:
        """
        Optional value to filter by percentiles
        """
        return pulumi.get(self, "percentile")

    @property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> Optional[str]:
        """
        ID of the metrics stream
        """
        return pulumi.get(self, "stream_id")

    @property
    @pulumi.getter
    def uql(self) -> Optional[str]:
        """
        UQL query
        """
        return pulumi.get(self, "uql")


@pulumi.output_type
class SloObjectiveRawMetricQueryNewrelic(dict):
    def __init__(__self__, *,
                 nrql: str):
        """
        :param str nrql: Query for the metrics
        """
        pulumi.set(__self__, "nrql", nrql)

    @property
    @pulumi.getter
    def nrql(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "nrql")


@pulumi.output_type
class SloObjectiveRawMetricQueryOpentsdb(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: Query for the metrics
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveRawMetricQueryPingdom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkId":
            suggest = "check_id"
        elif key == "checkType":
            suggest = "check_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveRawMetricQueryPingdom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveRawMetricQueryPingdom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveRawMetricQueryPingdom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check_id: str,
                 check_type: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param str check_id: Pingdom uptime or transaction check's ID
        :param str check_type: Pingdom check type - uptime or transaction
        :param str status: Optional for the Uptime checks. Use it to filter the Pingdom check results by status
        """
        pulumi.set(__self__, "check_id", check_id)
        if check_type is not None:
            pulumi.set(__self__, "check_type", check_type)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="checkId")
    def check_id(self) -> str:
        """
        Pingdom uptime or transaction check's ID
        """
        return pulumi.get(self, "check_id")

    @property
    @pulumi.getter(name="checkType")
    def check_type(self) -> Optional[str]:
        """
        Pingdom check type - uptime or transaction
        """
        return pulumi.get(self, "check_type")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Optional for the Uptime checks. Use it to filter the Pingdom check results by status
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class SloObjectiveRawMetricQueryPrometheus(dict):
    def __init__(__self__, *,
                 promql: str):
        """
        :param str promql: Query for the metrics
        """
        pulumi.set(__self__, "promql", promql)

    @property
    @pulumi.getter
    def promql(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "promql")


@pulumi.output_type
class SloObjectiveRawMetricQueryRedshift(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterId":
            suggest = "cluster_id"
        elif key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveRawMetricQueryRedshift. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveRawMetricQueryRedshift.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveRawMetricQueryRedshift.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_id: str,
                 database_name: str,
                 query: str,
                 region: str):
        """
        :param str cluster_id: Redshift custer ID
        :param str database_name: Database name
        :param str query: Query for the metrics
        :param str region: Region of the CloudWatch instance
        """
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> str:
        """
        Redshift custer ID
        """
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Database name
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Region of the CloudWatch instance
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class SloObjectiveRawMetricQuerySplunk(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: Query for the metrics
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SloObjectiveRawMetricQuerySplunkObservability(dict):
    def __init__(__self__, *,
                 program: str):
        """
        :param str program: Query for the metrics
        """
        pulumi.set(__self__, "program", program)

    @property
    @pulumi.getter
    def program(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "program")


@pulumi.output_type
class SloObjectiveRawMetricQuerySumologic(dict):
    def __init__(__self__, *,
                 query: str,
                 type: str,
                 quantization: Optional[str] = None,
                 rollup: Optional[str] = None):
        """
        :param str query: Query for the metrics
        :param str type: Sumologic source - metrics or logs
        :param str quantization: Period of data aggregation
        :param str rollup: Aggregation function - avg, sum, min, max, count, none
        """
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "type", type)
        if quantization is not None:
            pulumi.set(__self__, "quantization", quantization)
        if rollup is not None:
            pulumi.set(__self__, "rollup", rollup)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for the metrics
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Sumologic source - metrics or logs
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def quantization(self) -> Optional[str]:
        """
        Period of data aggregation
        """
        return pulumi.get(self, "quantization")

    @property
    @pulumi.getter
    def rollup(self) -> Optional[str]:
        """
        Aggregation function - avg, sum, min, max, count, none
        """
        return pulumi.get(self, "rollup")


@pulumi.output_type
class SloObjectiveRawMetricQueryThousandeye(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "testId":
            suggest = "test_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloObjectiveRawMetricQueryThousandeye. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloObjectiveRawMetricQueryThousandeye.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloObjectiveRawMetricQueryThousandeye.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 test_id: int):
        """
        :param int test_id: ID of the test
        """
        pulumi.set(__self__, "test_id", test_id)

    @property
    @pulumi.getter(name="testId")
    def test_id(self) -> int:
        """
        ID of the test
        """
        return pulumi.get(self, "test_id")


@pulumi.output_type
class SloTimeWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isRolling":
            suggest = "is_rolling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloTimeWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloTimeWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloTimeWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: int,
                 unit: str,
                 calendars: Optional[Sequence['outputs.SloTimeWindowCalendar']] = None,
                 is_rolling: Optional[bool] = None,
                 period: Optional[Mapping[str, str]] = None):
        """
        :param int count: Count of the time unit
        :param str unit: Unit of time
        :param Sequence['SloTimeWindowCalendarArgs'] calendars: Alert Policies attached to SLO
        :param bool is_rolling: Is the window moving or not
        :param Mapping[str, str] period: Period between start time and added count
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "unit", unit)
        if calendars is not None:
            pulumi.set(__self__, "calendars", calendars)
        if is_rolling is not None:
            pulumi.set(__self__, "is_rolling", is_rolling)
        if period is not None:
            pulumi.set(__self__, "period", period)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        Count of the time unit
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Unit of time
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def calendars(self) -> Optional[Sequence['outputs.SloTimeWindowCalendar']]:
        """
        Alert Policies attached to SLO
        """
        return pulumi.get(self, "calendars")

    @property
    @pulumi.getter(name="isRolling")
    def is_rolling(self) -> Optional[bool]:
        """
        Is the window moving or not
        """
        return pulumi.get(self, "is_rolling")

    @property
    @pulumi.getter
    def period(self) -> Optional[Mapping[str, str]]:
        """
        Period between start time and added count
        """
        return pulumi.get(self, "period")


@pulumi.output_type
class SloTimeWindowCalendar(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startTime":
            suggest = "start_time"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloTimeWindowCalendar. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloTimeWindowCalendar.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloTimeWindowCalendar.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 start_time: str,
                 time_zone: str):
        """
        :param str start_time: Date of the start
        :param str time_zone: Timezone name in IANA Time Zone Database
        """
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        Date of the start
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> str:
        """
        Timezone name in IANA Time Zone Database
        """
        return pulumi.get(self, "time_zone")


